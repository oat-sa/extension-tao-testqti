/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
define('taoTests/runner/plugin',['lodash', 'core/plugin'], function(_, pluginFactory){
    'use strict';

    /**
     * A pluginFactory configured for the test runner
     * @returns {Function} the preconfigured plugin factory
     */
    return _.partialRight(pluginFactory, {
        //alias getHost to getTestRunner
        hostName : 'testRunner'
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA;
 */
/**
 * Test Runner Content Plugin: Focus the first element if possible
 *
 * @author Dieter Raber <dieter@taotesting.com>
 */
define('taoQtiTest/runner/plugins/content/accessibility/focusOnFirstField',[
    'jquery',
    'lodash',
    'taoTests/runner/plugin',
    'ckeditor'
], function ($, _, pluginFactory, ckEditor) {
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: 'focusOnFirstField',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;

            this.getTestRunner()
                .after('renderitem', function() {
                    var $input = self.getAreaBroker().getContentArea().find('.qti-itemBody')
                        .find('input, textarea, select')
                        .not(':input[type=button], :input[type=submit], :input[type=reset]')
                        .first();
                    var $cke = $input.closest('.qti-interaction').find('.cke');

                    if($cke.length) {
                        _.delay(function() {
                            ckEditor.instances[$cke.attr('id').replace(/^cke_/, '')].focus();
                        }, 100);
                    }
                    else {
                        $input.focus();
                    }
                });
        }
    });
});


define('css!taoQtiTestCss/plugins/key-navigation',[],function(){});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * Test Runner Content Plugin : Navigate through the item focusable elements using the keyboard
 *
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/content/accessibility/keyNavigation',[
    'jquery',
    'lodash',
    'ui/keyNavigation/navigator',
    'ui/keyNavigation/navigableDomElement',
    'ui/keyNavigation/navigableGroupElement',
    'util/shortcut',
    'util/namespace',
    'taoTests/runner/plugin',
    'css!taoQtiTestCss/plugins/key-navigation'
], function ($, _, keyNavigator, navigableDomElement, navigableGroupElement, shortcut, namespaceHelper, pluginFactory) {
    'use strict';

    /**
     * Init the navigation in the toolbar
     *
     * @param {Object} testRunner
     * @returns {Array}
     */
    function initToolbarNavigation(){
        var $navigationBar = $('.bottom-action-bar');
        var $focusables = $navigationBar.find('.action:not(.btn-group):visible, .action.btn-group .li-inner:visible');
        var navigables = navigableDomElement.createFromDoms($focusables);
        if (navigables.length) {
            return [keyNavigator({
                id : 'bottom-toolbar',
                replace : true,
                group : $navigationBar,
                elements : navigables,
                //start from the last button "goto next"
                defaultPosition : navigables.length - 1
            }).on('right down', function(){
                this.next();
            }).on('left up', function(){
                this.previous();
            }).on('activate', function(cursor){
                cursor.navigable.getElement().click().mousedown();
            })];
        }
        return [];
    }

    /**
     * Init the navigation in the header block
     *
     * @param {Object} testRunner
     * @returns {Array}
     */
    function initHeaderNavigation(){
        //need global selector as currently no way to access delivery frame from test runner
        var $headerElements = $('[data-control="exit"]:visible a');
        var navigables = navigableDomElement.createFromDoms($headerElements);
        if (navigables.length) {
            return [keyNavigator({
                id : 'header-toolbar',
                group : $headerElements.closest('.infoControl'),
                elements : navigables,
                loop : true,
                replace : true
            }).on('activate', function(cursor){
                cursor.navigable.getElement().click();
            })];
        }
        return [];
    }

    /**
     * Init the navigation in the review panel
     *
     * @param {Object} testRunner
     * @returns {Array} the keyNavigator of the main navigation group
     */
    function initNavigatorNavigation(testRunner){

        var $panel = testRunner.getAreaBroker().getPanelArea();
        var $navigator = $panel.find('.qti-navigator');
        var navigators = [];
        var filtersNavigator;
        var itemsNavigator;
        var $filters, $trees, navigableFilters, navigableTrees;

        //the tag to identify if the item listing has been browsed, to only "smart jump" to active item only on the first visit
        var itemListingVisited = false;
        //the position of the filter in memory, to only "smart jump" to active item only on the first visit
        var filterCursor;

        if($navigator.length && !$navigator.hasClass('disabled')){
            $filters = $navigator.find('.qti-navigator-filters .qti-navigator-filter');
            navigableFilters = navigableDomElement.createFromDoms($filters);
            if (navigableFilters.length) {
                filtersNavigator = keyNavigator({
                    keepState : true,
                    id : 'navigator-filters',
                    replace : true,
                    elements : navigableFilters,
                    group : $navigator
                }).on('right', function(){
                    this.next();
                }).on('left', function(){
                    this.previous();
                }).on('down', function(){
                    if(itemsNavigator){
                        _.defer(function(){
                            if(itemListingVisited){
                                itemsNavigator.focus().first();
                            }else{
                                itemsNavigator.focus();
                            }
                        });
                    }
                }).on('up', function(){
                    if(itemsNavigator){
                        _.defer(function(){
                            itemsNavigator.last();
                        });
                    }
                }).on('focus', function(cursor, origin){
                    //activate the tab in the navigators
                    cursor.navigable.getElement().click();

                    //reset the item listing browsed tag whenever the focus on the filter happens after a focus on another element
                    if((filterCursor && filterCursor.position !== cursor.position) || origin){
                        itemListingVisited = false;
                    }
                    //set the filter cursor in memory
                    filterCursor = cursor;
                });
                navigators.push(filtersNavigator);
            }

            $trees = $navigator.find('.qti-navigator-tree .qti-navigator-item:not(.unseen) .qti-navigator-label');
            navigableTrees = navigableDomElement.createFromDoms($trees);
            if (navigableTrees.length) {
                //instantiate a key navigator but do not add it to the returned list of navigators as this is not supposed to be reached with tab key
                itemsNavigator = keyNavigator({
                    id : 'navigator-items',
                    replace : true,
                    elements : navigableTrees,
                    defaultPosition : function defaultPosition(navigables){
                        var pos = 0;
                        if(filterCursor && filterCursor.navigable.getElement().data('mode') !== 'flagged'){
                            _.forIn(navigables, function(navigable, i){
                                var $parent = navigable.getElement().parent('.qti-navigator-item');
                                //find the first active and visible item
                                if($parent.hasClass('active') && $parent.is(':visible')){
                                    pos = i;
                                    return false;
                                }
                            });
                        }
                        return pos;
                    }
                }).on('down', function(){
                    this.next();
                }).on('up', function(){
                    this.previous();
                }).on('right', function(){
                    if(filtersNavigator){
                        filtersNavigator.focus().next();
                    }
                }).on('left', function(){
                    if(filtersNavigator){
                        filtersNavigator.focus().previous();
                    }
                }).on('activate', function(cursor){
                    cursor.navigable.getElement().click();
                }).on('lowerbound upperbound', function(){
                    if(filtersNavigator){
                        filtersNavigator.focus();
                    }
                }).on('focus', function(cursor){
                    itemListingVisited = true;
                    cursor.navigable.getElement().parent().addClass('key-navigation-highlight');
                }).on('blur', function(cursor){
                    cursor.navigable.getElement().parent().removeClass('key-navigation-highlight');
                });
            }

        }
        return navigators;
    }

    /**
     * Init the navigation in the item content
     * Navigable item content are interaction choices and body element with the special class "key-navigation-focusable"
     * It returns an array of keyNavigators as the content is dynamically determined
     *
     * @param {Object} testRunner
     * @returns {Array} of keyNavigator ids
     */
    function initContentNavigation(testRunner){

        var itemNavigators = [];
        var $content = testRunner.getAreaBroker().getContentArea();

        //the item focusable body elements are considered scrollable
        $content.find('.key-navigation-focusable').addClass('key-navigation-scrollable');
        $content.find('.key-navigation-focusable,.qti-interaction').filter(function(){
            //filter out interaction as it will be managed separately
            return (!$(this).parents('.qti-interaction').length);
        }).each(function(){
            var $itemElement = $(this);
            if($itemElement.hasClass('qti-interaction')){
                itemNavigators = _.union(itemNavigators, initInteractionNavigation($itemElement));
            }else{
                itemNavigators.push(keyNavigator({
                    elements : navigableDomElement.createFromDoms($itemElement),
                    group : $itemElement,
                    propagateTab : false
                }));
            }
        });

        return itemNavigators;
    }

    /**
     * Init interaction key navigation from the interaction navigator
     *
     * @param {JQuery} $interaction - the interaction container
     * @returns {Array} array of navigators created from interaction container
     */
    function initInteractionNavigation($interaction){

        var $inputs;
        var interactionNavigables;
        var interactionNavigators = [];

        //add navigable elements from prompt
        $interaction.find('.key-navigation-focusable').each(function(){
            var $nav = $(this);
            if(!$nav.closest('.qti-choice').length){
                interactionNavigators.push(keyNavigator({
                    elements : navigableDomElement.createFromDoms($nav),
                    group : $nav,
                    propagateTab : false
                }));
            }
        });

        //reset interaction custom key navigation to override the behaviour with the new one
        $interaction.off('.keyNavigation');

        //search for inputs that represent the interaction focusable choices
        $inputs = $interaction.is(':input') ? $interaction : $interaction.find(':input');
        interactionNavigables = navigableDomElement.createFromDoms($inputs);

        if (interactionNavigables.length) {
            interactionNavigators.push(keyNavigator({
                elements : interactionNavigables,
                group : $interaction,
                loop : false
            }).on('right down', function(){
                this.next();
            }).on('left up', function(){
                this.previous();
            }).on('activate', function(cursor){
                var $elt = cursor.navigable.getElement();

                //jQuery <= 1.9.0 the checkbox values are set
                //after the click event if triggerred with jQuery
                if($elt.is(':checkbox')){
                    $elt.each(function(){
                        this.click();
                    });
                } else {
                    $elt.click();
                }

            }).on('focus', function(cursor){
                cursor.navigable.getElement().closest('.qti-choice').addClass('key-navigation-highlight');
            }).on('blur', function(cursor){
                cursor.navigable.getElement().closest('.qti-choice').removeClass('key-navigation-highlight');
            }));
        }

        return interactionNavigators;
    }

    /**
     * Init the navigation of test rubric blocks
     * It returns an array of keyNavigator ids as the content is dynamically determined
     *
     * @param {Object} testRunner
     * @returns {Array} of keyNavigator ids
     */
    function initRubricNavigation(){
        var $itemElements;
        var rubricNavigators = [];
        var $rubricArea = $('#qti-rubrics');

        $itemElements = $rubricArea.find('.qti-rubricBlock');
        $itemElements.each(function(){
            var $itemElement = $(this);
            var id = 'rubric_element_navigation_group_'+rubricNavigators.length;

            rubricNavigators.push(keyNavigator({
                id : id,
                elements : navigableDomElement.createFromDoms($itemElement),
                group : $itemElement,
                replace : true
            }));
        });

        return rubricNavigators;
    }

    /**
     * Init test runner navigation
     * @param testRunner
     * @returns {*}
     */
    function initTestRunnerNavigation(testRunner){

        var navigators;

        //blur current focused element, to reinitialize keyboard navigation
        if (document.activeElement){
            document.activeElement.blur();
        }

        navigators = _.union(
            initRubricNavigation(testRunner),
            initContentNavigation(testRunner),
            initToolbarNavigation(testRunner),
            initNavigatorNavigation(testRunner),
            initHeaderNavigation(testRunner)
        );

        navigators = navigableGroupElement.createFromNavigators(navigators);

        return keyNavigator({
            id : 'test-runner',
            replace : true,
            loop : true,
            elements : navigators,
        }).on('tab', function(){
            this.next();
        }).on('shift+tab', function(){
            this.previous();
        });
    }

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: 'keyNavigation',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;
            var testRunner = this.getTestRunner();

            shortcut.add('tab shift+tab', function(){
                if(!self.groupNavigator.isFocused()){
                    self.groupNavigator.focus();
                }
            });

            //start disabled
            this.disable();

            //update plugin state based on changes
            testRunner
                .after('renderitem', function () {
                    self.groupNavigator = initTestRunnerNavigation(testRunner);
                    self.enable();
                })
                .on('unloaditem', function () {
                    self.disable();
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + this.getName());
            if(this.groupNavigator) {
                this.groupNavigator.destroy();
            }
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Content Plugin : Overlay
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/content/dialog/dialog',[
    'jquery',
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'ui/dialog/alert',
    'ui/dialog/confirm',
    'util/shortcut/registry',
    'util/shortcut',
    'util/namespace'
], function ($, _, __, pluginFactory, dialogAlert, dialogConfirm, shortcutRegistry, globalShortcut, namespaceHelper){
    'use strict';

    /**
     * The public name of the plugin
     * @type {String}
     */
    var pluginName = 'dialog';

    /**
     * The prefix of actions triggered through the event loop
     * @type {String}
     */
    var actionPrefix = 'tool-' + pluginName + '-';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({
        name : pluginName,

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[pluginName] || {};
            var alerts = [];
            var confirms = [];
            var opened = [];
            var dialogShortcut = shortcutRegistry($('body'), {
                propagate: false,
                prevent: true
            });

            /**
             * Closes a dialog with accept
             * @param {dialog} dialog - The instance of the dialog
             */
            function closeAccept(dialog) {
                // TODO: improve the dialog implementation in order to provide a better API
                dialog.trigger('okbtn.modal').hide();
            }

            /**
             * Closes a dialog with rejection
             * @param {dialog} dialog - The instance of the dialog
             */
            function closeReject(dialog) {
                dialog.hide();
            }

            /**
             * Closes the last opened dialog
             * @param {Boolean} accept Whether the dialog should be accepted or not
             * @param {String} [shortcut] The shortcut that caused the action
             */
            function closeLast(accept, shortcut) {
                var handle = opened.length && opened[opened.length - 1];
                if (handle) {
                    handle.shortcut = shortcut;
                    if (accept) {
                        closeAccept(handle.dialog);
                    } else {
                        closeReject(handle.dialog);
                    }
                }
            }

            /**
             * Add dialog on top of the provided stack
             * @param {String} namespace - The event namespace that scope the dialog
             * @param {Array} stack - The dialogs stack on which push the new instance
             * @param {Function} dialog - The constructor of the dialog
             * @param {String} message - The message to display
             * @param {Function} accept - The callback for accept
             * @param {Function} reject - The callback for reject
             * @param {Object} options - Dialog options
             */
            function addHandle(namespace, stack, dialog, message, accept, reject, options) {
                var handle = {
                    context: namespace,
                    dialog: dialog(message, doAccept, doReject, options)
                };

                function doAccept(e, reason) {
                    if (_.isFunction(accept)) {
                        accept(handle.shortcut || reason);
                    }
                }
                function doReject(e, reason) {
                    if (_.isFunction(reject)) {
                        reject(handle.shortcut || reason);
                    }
                }

                // prevents all registered shortcuts to be triggered
                // and brings back the dialog shortcuts
                globalShortcut.disable();
                dialogShortcut.enable();

                stack.push(handle);
                opened.push(handle);

                handle.dialog.focus();
                handle.dialog.on('closed.modal', function() {
                    removeHandle(stack, handle.dialog);
                    removeHandle(opened, handle.dialog);

                    // if all dialogs have been closed allows all registered shortcuts to be triggered
                    // also disables the dialog shortcuts
                    if (!opened.length) {
                        globalShortcut.enable();
                        dialogShortcut.disable();
                    }
                });
            }

            /**
             * Remove a dialog from the provided stack
             * @param {Array} stack - The dialogs stack from which remove the dialog instance
             * @param {dialog} dialog - The instance of the dialog
             */
            function removeHandle(stack, dialog) {
                if (dialog) {
                    _.remove(stack, function(handle) {
                        if (handle && dialog === handle.dialog) {
                            return true;
                        }
                    });
                }
            }

            /**
             * Closes all dialogs within the provided stack
             * @param {String} namespace - The event namespace that scope the dialogs to close
             * @param {Boolean} accept - Whether (`true`) or not (`false`) to close the dialogs with accept
             * @param {Array} stack - The dialogs stack in which close the dialogs
             */
            function closeDialogs(namespace, accept, stack) {
                if (stack) {
                    _.forEach(stack, function(handle) {
                        if (handle && (namespace === '@' || namespace === handle.context)) {
                            if (accept) {
                                closeAccept(handle.dialog);
                            } else {
                                closeReject(handle.dialog);
                            }
                        }
                    });
                } else {
                    closeDialogs(namespace, accept, alerts);
                    closeDialogs(namespace, accept, confirms);
                }
            }

            // starts with shortcuts disabled, prevents the TAB key to be used to move outside the dialog box
            dialogShortcut.disable().set('Tab Shift+Tab');

            // handle the plugin's shortcuts
            if (testConfig.allowShortcuts) {
                _.forEach(pluginShortcuts, function(command, key) {
                    dialogShortcut.add(namespaceHelper.namespaceAll(command, pluginName, true), function(e, shortcut) {
                        // just fire the action using the event loop
                        testRunner.trigger(actionPrefix + key, shortcut);
                    });
                });
            }

            //change plugin state
            testRunner
                .before('alert.*', function(e, msg, accept) {
                    addHandle(e.namespace, alerts, dialogAlert, msg, accept, accept);
                })
                .before('confirm.*', function(e, msg, accept, reject, options) {
                    addHandle(e.namespace, confirms, dialogConfirm, msg, accept, reject, options);
                })
                .before('closedialog.*', function(e, accept) {
                    closeDialogs(e.namespace, accept);
                })
                .on(actionPrefix + 'accept', function(shortcut) {
                    closeLast(true, shortcut);
                })
                .on(actionPrefix + 'reject', function(shortcut) {
                    closeLast(false, shortcut);
                })
                .on('destroy', function() {
                    closeDialogs('.@');

                    dialogShortcut.clear();
                    dialogShortcut = null;
                });
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/content/dialog/exitMessages',[
    'lodash',
    'core/promise',
    'taoTests/runner/plugin'
], function (_, Promise, pluginFactory) {
    'use strict';

    /**
     * Creates the testState plugin.
     * Displays exit message, then leaves the runner once the user has acknowledged
     */
    return pluginFactory({

        name: 'exitMessages',

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            // this function is mandatory
        },

        /**
         * Installs the plugin (called when the runner bind the plugin)
         */
        install: function install() {
            var testRunner = this.getTestRunner();

            // intercepts the `leave` event,
            // then if a message needs to be displayed displays it and waits the user acknowledges it
            testRunner.before('leave', function leave(e, data) {
                if (_.isObject(data) && data.message) {
                    return new Promise(function(resolve) {
                        var context = testRunner.getTestContext();

                        // the leave can occurs when the runner is in inconsistent state (i.e. error)
                        // prevent side error with item disabling
                        if (context && context.itemIdentifier) {
                            testRunner.disableItem(context.itemIdentifier);
                        }

                        // wait for the message acknowledge before leaving the runner
                        testRunner.trigger('alert.leave', data.message, resolve);
                    });
                }
            });
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016  (original work) Open Assessment Technologies SA;
 *
 * @author Alexander Zagovorichev <zagovorichev@1pt.com>
 */


/**
 * Create dialog form with message, with overlapped content
 */
define('taoQtiTest/runner/plugins/content/dialog/itemAlertMessage',[
    'jquery',
    'i18n',
    'ui/hider',
    'taoTests/runner/plugin'
], function($, __, hider, pluginFactory) {
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name : 'itemAlertMessage',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            this.$element = $(this.getContent().dom);

            this.$element
                // for GUI actions
                .on('closed.modal', function(){
                    $(this).modal('destroy');
                })
                .on('destroyed.modal', function(){
                    self.$element = null;
                    self.trigger('resume', self);
                });
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){
            var testRunner = this.getTestRunner();
            var itemRunner = testRunner.itemRunner;
            var $modalsContainer = this.getContent().$container;
            if (!$modalsContainer) {
                $modalsContainer = $('#modalFeedbacks', itemRunner._item.container);
            }
            $modalsContainer.append(this.$element);

            this.$element.modal();
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            if (this.$element && this.$element.length){
                this.$element.modal('close');
            }
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/templates/button', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += " ";
  if (helper = helpers.className) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.className); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "<span class=\"icon icon-";
  if (helper = helpers.icon) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.icon); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.text), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"></span>";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return " no-label";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "<span class=\"text\">";
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>";
  return buffer;
  }

  buffer += "<li data-control=\"";
  if (helper = helpers.control) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.control); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"small btn-info action";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.className), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" title=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <a class=\"li-inner\" href=\"#\">\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.icon), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.text), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n</li>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016  (original work) Open Assessment Technologies SA;
 *
 * @author Alexander Zagovorichev <zagovorichev@1pt.com>
 */

/**
 * Create form with message in test runner and replace all control buttons on his personal
 */

define('taoQtiTest/runner/plugins/content/dialog/itemInlineMessage',[
    'jquery',
    'i18n',
    'ui/hider',
    'taoTests/runner/plugin',
    'tpl!taoQtiTest/runner/plugins/templates/button'
], function($, __, hider, pluginFactory, buttonTpl) {
    'use strict';

    /**
     * The display of the next button
     */
    var buttonData = {
        next : {
            control : 'move-forward',
            title   : __('Submit and go to the next item'),
            icon    : 'forward',
            text    : __('OK')
        },
        end : {
            control : 'move-end',
            title   : __('Submit and go to the end of the test'),
            icon    : 'fast-forward',
            text    : __('OK & End test')
        }
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name : 'itemInlineMessage',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();

            /**
             * Create the button based on the current context
             * @returns {*|jQuery|HTMLElement} the button
             */
            var createOkButton = function createElement(){
                var dataType = !!testRunner.getTestContext().isLast ? 'end' : 'next';
                var $btn = $(buttonTpl(buttonData[dataType]));
                $btn.addClass('modalFeedback-button');

                //plugin behavior
                $btn.on('click', function(e){
                    e.preventDefault();

                    self.disable();
                    if($(this).data('control') === 'move-end'){
                        self.trigger('end');
                    }

                    $btn.remove();
                    self.$element.remove();

                    self.trigger('resume', self);
                });

                return $btn;
            };

            this.$button = createOkButton();
            this.$element = $(this.getContent().dom);
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){
            var $navigationContainer = this.getAreaBroker().getNavigationArea();
            var testRunner = this.getTestRunner();
            var itemRunner = testRunner.itemRunner;
            var $inlineContainer = this.getContent().$container;
            if (!$inlineContainer && itemRunner._item.container) {
                $inlineContainer = $('.qti-itemBody', itemRunner._item.container);
            }

            $inlineContainer.append(this.$element);

            // hide all navigation buttons, create new instead of
            if (!$('.modalFeedback-button', $navigationContainer).length){
                $navigationContainer.append(this.$button);
            }
        },

        /**
         * Enable the button
         */
        enable : function enable (){
            this.$button.removeProp('disabled')
                .removeClass('disabled');
        },

        disable: function disable (){
            this.$button.prop('disabled', true)
                .addClass('disabled');
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            this.$button.click();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Content Plugin : Feedback
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/content/feedback/feedback',[
    'jquery',
    'i18n',
    'taoTests/runner/plugin',
    'ui/feedback'
], function ($, __, pluginFactory, feedback){
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({
        name : 'feedback',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;

            //keep a ref of the feedbacks
            var currentFeedback;

            var testRunner = this.getTestRunner();

            /**
             * Close the current feedback
             */
            var closeCurrent = function closeCurrent(){
                if(currentFeedback){
                    currentFeedback.close();
                }
            };

            //change plugin state
            testRunner
                .on('error', function(err){
                    var message = err;
                    var type = 'error';

                    if ('object' === typeof err) {
                        message = err.message;
                        type = err.type;
                    }

                    if (!message) {
                        switch (type) {
                            case 'TestState':
                                message = __('The test has been closed/suspended!');
                                break;

                            case 'FileNotFound':
                                message = __('File not found!');
                                break;

                            default:
                                message = __('An error occurred!');
                        }
                    }

                    currentFeedback = feedback().error(message);
                })
                .on('danger', function(message){
                    currentFeedback = feedback().danger(message);
                })
                .on('warning', function(message){
                    currentFeedback = feedback().warning(message);
                })
                .on('info', function(message){
                    currentFeedback = feedback().info(message);
                })
                .on('alert.* confirm.* unloaditem', closeCurrent);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/content/loading/loading',[
    'layout/loading-bar',
    'taoTests/runner/plugin'
], function (loadingBar, pluginFactory) {
    'use strict';

    /**
     * Creates the loading bar plugin.
     * Displays a loading bar when a blocking task is running
     */
    return pluginFactory({

        name: 'loading',

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var testRunner = this.getTestRunner();
            testRunner
                .on('unloaditem', function () {
                    loadingBar.start();
                })
                .on('renderitem', function () {
                    loadingBar.stop();
                });
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016  (original work) Open Assessment Technologies SA;
 *
 * @author Alexander Zagovorichev <zagovorichev@1pt.com>
 */

/**
 * @see http://www.imsglobal.org/question/qtiv2p1/imsqti_implv2p1.html#section10008 modalFeedback
 */

define('taoQtiTest/runner/plugins/content/modalFeedback/modalFeedback',[
    'jquery',
    'lodash',
    'module',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/plugins/content/dialog/itemInlineMessage',
    'taoQtiTest/runner/plugins/content/dialog/itemAlertMessage',
    'ui/autoscroll'
], function ($, _, module, pluginFactory, inlineMessage, alertMessage, autoscroll) {
    'use strict';

    /**
     * Modal or inline type of the messages
     */
    var inlineMode;

    /**
     * Form of the feedback
     * by default dialog (modal) form
     */
    var messagePlugin;

    /**
     * All feedback messages
     */
    var renderedFeedbacks;

    /**
     * modalFeedback was resolved and all components were destroyed
     */
    var isDestroyed;

    /**
     * Method which should be halted after modalFeedbacks confirmation action
     */
    var nextStep;

    function destroyFeedback(feedback) {

        var removed = false;
        _.remove(renderedFeedbacks, function (storedFeedback) {

            var found = storedFeedback === feedback;
            if (found) {
                removed = true;
            }
            return found;
        });

        if (removed) {
            feedback.destroy();

            if (!renderedFeedbacks.length) {
                nextStep();
            }
        }
    }

    function defineMode(inline) {
        inlineMode = inline;
        messagePlugin = inlineMode ? inlineMessage : alertMessage;
    }

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: 'QtiModalFeedback',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            nextStep = function(){};

            defineMode(!!module.config().inlineModalFeedback);
        },

        /**
         * Called during the runner's render phase
         */
        render: function render() {
            var self = this;
            var testRunner = this.getTestRunner();

            var createMessages = function createMessages(renderingQueue, inline){

                var bInlineMode = inlineMode;

                isDestroyed = false;
                renderedFeedbacks = [];

                if (_.isBoolean(inline)) {
                    defineMode(inline);
                }

                if (renderingQueue.length) {

                    _.forEach(renderingQueue, function (renderingToken) {

                        var feedback = messagePlugin(testRunner, testRunner.getAreaBroker());
                        feedback.init({
                            dom: renderingToken.feedback.render({
                                inline: inlineMode
                            }),
                            // for alerts will be used #modalMessages container
                            $container: inlineMode ? renderingToken.$container : null
                        });
                        feedback.render();

                        renderedFeedbacks.push(feedback);
                    });

                    // auto scroll to the first feedback, only for the "inline" mode
                    if (inlineMode && renderedFeedbacks) {
                        autoscroll($('.qti-modalFeedback', testRunner.getAreaBroker().getContentArea()).first(), testRunner.getAreaBroker().getContentArea().parents('.content-wrapper'));
                    }
                } else {
                    nextStep();
                }

                // restore global feedback mode
                defineMode(bInlineMode);
            };

            if (inlineMode) {
                testRunner
                    .off('plugin-resume.itemInlineMessage')
                    .on('plugin-resume.itemInlineMessage', function () {
                        self.destroy();
                    });
            } else {
                testRunner
                    .off('plugin-resume.itemAlertMessage')
                    .on('plugin-resume.itemAlertMessage', function (feedback) {
                        destroyFeedback(feedback);
                    });
            }

            testRunner.on('modalFeedbacks', function(renderingQueue, done, inline) {
                nextStep = done;
                createMessages(renderingQueue, inline);
            });
        },

        /**
         * Called during the runner's destroy phase
         * allow to run that function only once
         */
        destroy: function destroy() {
            var tFeedbacks, i;
            if (!isDestroyed) {
                isDestroyed = true;

                if (!renderedFeedbacks) {
                    nextStep();
                } else {
                    tFeedbacks = renderedFeedbacks.slice(0);
                    for (i in tFeedbacks) {
                        destroyFeedback(tFeedbacks[i]);
                    }
                }
            }
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Content Plugin : Overlay
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/content/overlay/overlay',[
    'jquery',
    'i18n',
    'taoTests/runner/plugin'
], function ($, __, pluginFactory){
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({
        name : 'overlay',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();

            this.$element = $('<div />');
            this.$element.on('click mousedown mouseup touchstart touchend keyup keydow keypress scroll drop', function(e){
                e.stopImmediatePropagation();
                e.stopPropagation();
            });

            var shield = function shield(){
                self.enable();
            };
            var unshield = function unshield(itemRef){
                self.disable();
            };

            //change plugin state
            testRunner
                .on('disableitem',  shield)
                .on('enableitem unloaditem', unshield);
        },

        /**
         * Called during the runner's render phase
         */
        render : function render (){
            var $contentArea = this.getTestRunner().getAreaBroker().getContentArea();
            $contentArea.after(this.$element);
        },


        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            this.$element.remove();
        },

        /**
         * Enable the overlay
         */
        enable : function enable (){
            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginsConfig = testConfig.plugins || {};
            var overlayConfig = pluginsConfig.overlay || {};

            this.$element.addClass('overlay');

            if (overlayConfig.full) {
                this.$element.addClass('overlay-full');
            }
        },

        /**
         * Disable the overlay
         */
        disable : function disable (){
            this.$element.removeClass('overlay overlay-full');
        },

        /**
         * Show the overlay
         */
        show: function show(){
            this.enable();
        },

        /**
         * Hide the overlay
         */
        hide: function hide(){
            this.disable();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 * @author Christophe Noël <christophe@taotesting.com>
 * @author Dieter Raber <dieter@taotesting.com>
 */


define('taoQtiTest/runner/plugins/content/responsiveness/collapser',[
    'lodash',
    'jquery',
    'taoTests/runner/plugin'
], function (_, $, pluginFactory) {
    'use strict';

    /**
     * Event namespace
     * @type {String}
     */
    var ns = '.collapser';

    /**
     * Name of the CSS class used to collapse the buttons
     * @type {String}
     */
    var noLabelCls = 'tool-label-collapsed';

    /**
     * Name of the CSS class used to collapse the buttons and allow to expand on mouse over
     * @type {String}
     */
    var noLabelHoverCls = 'tool-label-collapsed-hover';

    /**
     * Name of the  CSS class used to hide the label of the button independently of responsiveness
     * @type {string}
     */
    var labelHiddenCls = 'no-tool-label';


    /**
     * Name of the  CSS class for separators
     * @type {string}
     */
    var separatorCls = 'separator';

    /**
     * Default plugin options
     * @type {Object}
     */
    var defaults = {
        collapseTools: true,        // collapse the tools buttons
        collapseNavigation: false,  // collapse the navigation buttons
        collapseInOrder: false,     // collapse any button in the given order
        hover: false,               // expand when the mouse is over a button,

        /**
         * Allow to set manually which buttons should collapse and in which order.
         * This can be set by triggering the "collapser-set-order" event on the testRunner.
         * Given as an array of jQuery selectors: first index will be the first to be collapsed, and so on.
         * If no selector is given for a button, then this one will never collapse.
         * ex:
         * var collapseOrder = [
         *      '[data-control="highlight-clear"],[data-control="highlight-trigger"]',  // those will collapse first...
         *      '[data-control="hide-review"]',                                         // this one second...
         *      '[data-control="set-item-flag"]',                                       // third...
         *      ...                                                                     // ...
         * ];
         * @type {String[]}
         */
        collapseOrder: []
    };

    var $window = $(window);

    /**
     * Creates the responsiveness collapser plugin.
     * Reduce the size of the action bar tools when the available space is below the needed one.
     */
    return pluginFactory({

        name: 'collapser',

        /**
         * Installs the plugin (called when the runner bind the plugin)
         */
        init: function init() {
            var testRunner = this.getTestRunner(),
                testData = testRunner.getTestData() || {},
                testConfig = testData.config || {},
                pluginsConfig = testConfig.plugins || {},
                config = _.defaults(pluginsConfig.collapser || {}, defaults),
                collapseCls = config.hover ? noLabelHoverCls : noLabelCls;

            var areaBroker = testRunner.getAreaBroker();

            var $actionsBar = areaBroker.getArea('actionsBar'),
                $toolbox = areaBroker.getToolboxArea(),
                $navigation = areaBroker.getNavigationArea();

            var allCollapsibles,
                availableWidth,
                previousAvailableWidth;

            /**
             * Get a reference of all collapsibles
             */
            function buildCollapsiblesList() {

                // use the given order to build the collapsibles list or generate on in natural order
                if(config.collapseInOrder && config.collapseOrder.length) {
                    allCollapsibles = getCollapsiblesFromConfig();
                }
                // get values from DOM, grouped by prefix
                else if(config.collapseInOrder) {
                    allCollapsibles = getSortedCollapsiblesFromDom();
                }
                // get all in one chunk
                else {
                    allCollapsibles = getUnsortedCollapsiblesFromDom();
                }
            }

            /**
             * @param {jQuery} $element
             * @returns {number} Size difference, in pixels, between collapsed and expanded state of $element
             */
            function getExtraWidth($element) {
                var expandedWidth,
                    collapsedWidth;

                $element.removeClass(collapseCls);
                expandedWidth = $element.outerWidth(true);
                $element.addClass(collapseCls);
                collapsedWidth = $element.outerWidth(true);
                $element.removeClass(collapseCls);

                return expandedWidth - collapsedWidth;
            }

            /**
             * Expand or collapse elements
             */
            function toggleCollapsibles() {
                availableWidth = getAvailableWidth();

                availableWidth < previousAvailableWidth ? collapseInOrder() : expandInOrder();

                previousAvailableWidth = availableWidth;
            }

            function collapseInOrder() {
                var collapsiblesCopy = _.clone(allCollapsibles),
                    toCollapse;

                while (collapseNeeded() && collapsiblesCopy.length) {
                    toCollapse = collapsiblesCopy.shift();
                    toCollapse.$elements.addClass(collapseCls);
                }
            }

            function collapseNeeded() {
                return getToolbarWidth() > getAvailableWidth();
            }

            function expandInOrder() {
                _.forEachRight(allCollapsibles, function(toExpand) {
                    if (toExpand.$elements.hasClass(collapseCls)) {
                        if (expandPossible(toExpand.extraWidth)) {
                            toExpand.$elements.removeClass(collapseCls);
                        } else {
                            return false;
                        }
                    }
                });
            }

            function expandPossible(extraWidth) {
                return (getToolbarWidth() + extraWidth) < getAvailableWidth();
            }

            function getAvailableWidth() {
                // Scrollbars are commonly between ~12px and ~18px in width. Subtracting 20px from the available width
                // makes sure that scrollbars are always taken in account. The worst case scenario is that the buttons
                // start to collapse, although they would still have had 20px available.
                return $actionsBar.width() - 20;
            }

            function getToolbarWidth() {
                return $toolbox.outerWidth(true) + $navigation.outerWidth(true);
            }

            /**
             * Parse DOM for controls that can be collapsed
             * @returns {*|jQuery|HTMLElement}
             */
            function getControlsFromDom() {
                var $controls = $(),
                    selector = '>ul>[data-control]';

                if(config.collapseTools) {
                    $controls = $controls.add($toolbox.find(selector).not('.' + labelHiddenCls).not('.' + separatorCls));
                }

                if(config.collapseNavigation) {
                    $controls = $controls.add($navigation.find(selector).not('.' + labelHiddenCls).not('.' + separatorCls));
                }

                return $controls;
            }

            /**
             * Get allCollapsibles based on configuration
             *
             * @returns {Array}
             */
            function getCollapsiblesFromConfig() {

                return _.compact(config.collapseOrder.map(function(selector) {
                    // some buttons are collapsed by configuration, some other are only separators: we should leave them alone
                    var $elements = $(selector).not('.' + labelHiddenCls).not('.' + separatorCls);
                    var extraWidth = 0;

                    if ($elements.length) {
                        $elements.each(function() {
                            extraWidth += getExtraWidth($(this));
                        });
                        return {
                            $elements: $elements,
                            extraWidth: extraWidth
                        };
                    }
                    return false;
                }));
            }

            /**
             * Get allCollapsibles based on DOM
             * Build the collapse order from the left to the right, related elements are grouped.
             *
             * @returns {Array}
             */
            function getSortedCollapsiblesFromDom() {

                var $elements = getControlsFromDom(),
                    _allCollapsibles = [],
                    order = {};

                // group items by prefix
                // eg. zoomIn and zoomOut -> zoom
                $elements.each(function() {
                    var ctrl = this.dataset.control,
                        // re makes group `foo` from `foo-bar`, `fooBar` and `foo_bar`
                        // if we do not have a prefix use the control name as key to ensure uniqueness
                        key = ctrl.substring(0, ctrl.search(/[A-Z-_]/)) || ctrl;

                    order[key] = order[key] || $();
                    order[key] = order[key].add($(this));
                });

                // move items to allCollapsibles
                _.forOwn(order, function($elements) {
                    var extraWidth = 0;
                    $elements.each(function() {
                        extraWidth += getExtraWidth($(this));
                    });
                    _allCollapsibles.push({
                        $elements: $elements,
                        extraWidth: extraWidth
                    })
                });

                return _.compact(_allCollapsibles);
            }

            /**
             * Get allCollapsibles based on DOM, all buttons will be collapsed at once
             *
             * @returns {Array}
             */
            function getUnsortedCollapsiblesFromDom() {
                var $elements = getControlsFromDom(),
                    _allCollapsibles = [],
                    extraWidth = 0;

                $elements.each(function() {
                    extraWidth += getExtraWidth($(this));
                });

                _allCollapsibles.push({
                    $elements: $elements,
                    extraWidth: extraWidth
                });

                return _.compact(_allCollapsibles);
            }



            $window.on('resize' + ns, _.throttle(function() {
                testRunner.trigger('collapseTools');
            }, 40));

            testRunner
                .after('renderitem loaditem', function() {
                    previousAvailableWidth = Infinity;

                    buildCollapsiblesList();

                    testRunner.trigger('collapseTools');
                })
                .on('collapseTools' + ns, function() {
                    toggleCollapsibles();
                });
        },

        destroy: function destroy() {
            $window.off(ns);
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/content/rubricBlock/rubricBlock', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div id=\"qti-rubrics\"></div>\n";
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Content Plugin : RubricBlock
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/content/rubricBlock/rubricBlock',[
    'jquery',
    'i18n',
    'core/promise',
    'ui/hider',
    'taoTests/runner/plugin',
    'tpl!taoQtiTest/runner/plugins/content/rubricBlock/rubricBlock'
], function ($, __, Promise, hider, pluginFactory, containerTpl){
    'use strict';

    /**
     * Ensure the <a> links opens to blank pages
     * @param {jQueryElement} $container - lookup scope
     */
    var blankifyLinks = function blankifyLinks($container){
        $('a', $container).attr('target', '_blank');
    };

    /**
     * Apply mathjax
     */
    var mathify = function mathify($container) {

        return new Promise(function(resolve){
            if($('math', $container).length > 0){
                //load mathjax only if necessary
                require(['mathJax'], function(MathJax){
                    if(MathJax){
                        MathJax.Hub.Queue(["Typeset", MathJax.Hub], $container[0]);
                        MathJax.Hub.Queue(resolve);
                    } else {
                        resolve();
                    }
                }, resolve);
            } else {
                resolve();
            }
        });
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({
        name : 'rubricBlock',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();

            this.$element = $(containerTpl());

            this.hide();

            //change plugin state
            testRunner
                .on('ready', function(){
                    self.hide();
                })
                .on('loaditem', function(){
                    var context = testRunner.getTestContext();
                    if(context.rubrics) {
                        self.$element.html(context.rubrics);

                        blankifyLinks(self.$element);
                        mathify(self.$element).then(function(){
                            // notify that the rubric blocks are loaded
                            testRunner.trigger('rubricblock');
                        });
                    }
                })
                .on('renderitem', function(){
                    self.show();
                })
                .on('unloaditem', function(){
                    self.hide();
                    self.$element.empty();
                });
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){
            //attach the element before the content area
            var $container = this.getAreaBroker().getContentArea();
            $container.before(this.$element);
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            this.$element.remove();
        },

        /**
         * Enable the container
         */
        enable : function enable (){
            this.$element.removeProp('disabled')
                         .removeClass('disabled');
        },

        /**
         * Disable the container
         */
        disable : function disable (){
            this.$element.prop('disabled', true)
                         .addClass('disabled');
        },

        /**
         * Show the container
         */
        show: function show(){
            hider.show(this.$element);
        },

        /**
         * Hide the container
         */
        hide: function hide(){
            hider.hide(this.$element);
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/controls/connectivity/connectivity', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<div class=\"connectivity-box ";
  if (helper = helpers.state) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.state); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <span data-control=\"connectivity-connected\" class=\"qti-controls icon-connect\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Connected to server", options) : helperMissing.call(depth0, "__", "Connected to server", options)))
    + "\"></span>\n    <span data-control=\"connectivity-disconnected\" class=\"qti-controls icon-disconnect\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Disconnected from server", options) : helperMissing.call(depth0, "__", "Disconnected from server", options)))
    + "\"></span>\n</div>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016-2017 (original work) Open Assessment Technologies SA ;
 */

/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/controls/connectivity/connectivity',[
    'jquery',
    'lodash',
    'i18n',
    'core/promise',
    'core/polling',
    'ui/waitingDialog/waitingDialog',
    'taoTests/runner/plugin',
    'tpl!taoQtiTest/runner/plugins/controls/connectivity/connectivity'
], function ($, _, __, Promise, pollingFactory, waitingDialog, pluginFactory, connectivityTpl) {
    'use strict';


    /**
     * The plugin default configuration
     * @type {Object}
     * @property {Number} checkInterval - when offline, interval to check if we're back online
     * @property {Boolean} indicator - do we display the indicator in the test UI
     */
    var defaultConfig = {
        checkInterval : 30 * 1000,
        indicator     : true
    };


    /**
     * Creates the connectivity plugin.
     * Detects connectivity issues
     */
    return pluginFactory({

        name: 'connectivity',

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var self       = this;
            var testRunner = this.getTestRunner();
            var proxy      = testRunner.getProxy();
            var config     = _.defaults(this.getConfig() || {}, defaultConfig);

            //Displays a connectivity indicator
            if(config && config.indicator){

                //create the indicator
                this.$element = $(connectivityTpl({
                    state: proxy.isOnline() ? 'connected' : 'disconnected'
                }));

                testRunner
                    .on('disconnect', function(){
                        self.$element.removeClass('connected').addClass('disconnected');
                    })
                    .on('reconnect', function() {
                        self.$element.removeClass('disconnected').addClass('connected');
                    });
            }

            //update the interval, with the new value
            if(this.polling && _.isNumber(config.checkInterval)){
                this.polling.setInterval(config.checkInterval);
            }
        },

        /**
         * Installs the plugin (called when the runner bind the plugin)
         * We do it before init to catch even offline during the init sequence
         */
        install: function install() {
            var self = this;

            var waiting    = false;

            var testRunner = this.getTestRunner();
            var proxy      = testRunner.getProxy();

            /**
             * Display the waiting dialog, while waiting the connection to be back
             * @param {String} [messsage] - additional message for the dialog
             * @returns {Promise} resolves once the wait is over and the user click on 'proceed'
             */
            this.displayWaitingDialog = function displayWaitingDialog(message){

                var dialog;
                return new Promise(function(resolve) {
                    if(!waiting){
                        waiting = true;

                        //if a pause event occurs while waiting,
                        //we also wait the connection to be back
                        testRunner.before('pause.waiting', function(){
                            return new Promise(function(pauseResolve){
                                proxy.off('reconnect.pausing')
                                    .after('reconnect.pausing', pauseResolve);
                            });
                        });

                        //creates the waiting modal dialog
                        dialog = waitingDialog({
                            message : __('You are encountering a prolonged connectivity loss. ') + message,
                            waitContent : __('Please wait while we try to restore the connection.'),
                            proceedContent : __('The connection seems to be back, please proceed')
                        })
                        .on('proceed', function(){
                            resolve();
                        })
                        .on('render', function(){
                            proxy
                                .off('reconnect.waiting')
                                .after('reconnect.waiting', function(){
                                    testRunner.off('pause.waiting');
                                    waiting = false;
                                    dialog.endWait();
                                });
                        });
                    }
                });
            };

            //Last chance to check the connection,
            //by regular polling on the "up" signal
            this.polling = pollingFactory({
                action: function action () {
                    testRunner.getProxy()
                        .telemetry(testRunner.getTestContext().itemIdentifier, 'up')
                        .catch(_.noop);
                },
                interval: defaultConfig.checkInterval,
                autoStart: false
            });


            //the Proxy is the only one to know something about connectivity
            proxy.on('disconnect', function disconnect(source) {
                if (!testRunner.getState('disconnected')) {
                    testRunner.setState('disconnected', true);
                    testRunner.trigger('disconnect', source);
                    self.polling.start();
                }
            })
            .on('reconnect', function reconnect() {
                if (testRunner.getState('disconnected')) {
                    testRunner.setState('disconnected', false);
                    testRunner.trigger('reconnect');
                    self.polling.stop();
                }
            });

            //intercept tries to leave while offline
            //this could be caused by pauses for example.
            //If caused by an action like exitTest it will be handled
            //by navigation errors (see below)
            testRunner.before('leave', function(e, data){
                if (proxy.isOffline()) {
                    self.displayWaitingDialog(data.message)
                        .then(function(){
                            testRunner.trigger('leave', data);
                        })
                        .catch(function(generalErr){
                            testRunner.trigger('error', generalErr);
                        });

                    return false;
                }
            });

            //intercept offline navigation errors
            testRunner.before('error', function(e, err) {

                // detect and prevent connectivity errors
                if (proxy.isConnectivityError(err)){
                    return false;
                }

                if (proxy.isOffline()) {
                    self.displayWaitingDialog(err.message)
                        .then(function(){
                            if(err.type === 'nav'){
                                testRunner.loadItem(testRunner.getTestContext().itemIdentifier);
                            }
                            if(err.type === 'finish'){
                                testRunner.finish();
                            }
                            if(err.type === 'pause'){
                                testRunner.trigger('pause', {
                                    reasons: err.data && err.data.reasons,
                                    message : err.data && err.data.comment
                                });
                            }
                        })
                        .catch(function(generalErr){
                            testRunner.trigger('error', generalErr);
                        });
                    return false;
                }
            });
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){
            var $container = this.getAreaBroker().getControlArea();
            if(this.$element){
                $container.append(this.$element);
            }
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Control Plugin : Duration (record exact spent time duration)
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/duration/duration',[
    'lodash',
    'core/polling',
    'core/timer',
    'core/promise',
    'taoTests/runner/plugin',
], function(_, pollingFactory, timerFactory, Promise, pluginFactory) {
    'use strict';

    /**
     * Time interval between duration capture in ms
     * @type {Number}
     */
    var refresh = 1000;


    /**
     * Creates the timer plugin
     */
    return pluginFactory({

        name: 'duration',

        /**
         * Install step, add behavior before the lifecycle.
         */
        install: function install() {
            //define the "duration" store as "volatile" (removed on browser change).
            this.getTestRunner().getTestStore().setVolatile(this.getName());
        },


        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {

            var self = this;
            var testRunner = this.getTestRunner();

            //where the duration of attempts are stored
            return testRunner.getPluginStore(this.getName())
                .then(function(durationStore) {

                    /**
                     * Gets the duration of a particular item from the store
                     * @param {String} attemptId - the attempt id to get the duration for
                     * @returns {Promise}
                     */
                    function getItemDuration(attemptId) {
                        if (!/^(.*)+#+\d+$/.test(attemptId)) {
                            return Promise.reject(new Error('Is it really an attempt id, like "itemid#attempt"'));
                        }

                        return durationStore.getItem(attemptId);
                    }

                    //one stopwatch to count the time
                    self.stopwatch = timerFactory({
                        autoStart: false
                    });

                    //update the duration on a regular basis
                    self.polling = pollingFactory({

                        action: function updateDuration() {

                            //how many time elapsed from the last tick ?

                            var context = testRunner.getTestContext();

                            //store by attempt
                            var itemAttemptId = context.itemIdentifier + '#' + context.attempt;

                            durationStore.getItem(itemAttemptId).then(function(duration){
                                var elapsed = self.stopwatch.tick();
                                duration = _.isNumber(duration) ? duration : 0;
                                elapsed = _.isNumber(elapsed) && elapsed > 0 ? (elapsed / 1000) : 0;

                                //store the last duration
                                durationStore.setItem(itemAttemptId, duration + elapsed);
                            });
                        },
                        interval: refresh,
                        autoStart: false
                    });

                    //change plugin state
                    testRunner

                        .after('renderitem', function(){
                            self.enable();
                        })
                        .on('enableitem', function() {
                            self.enable();
                        })

                        .before('move skip exit timeout', function() {
                            var context = testRunner.getTestContext();
                            var itemAttemptId = context.itemIdentifier + '#' + context.attempt;

                            return getItemDuration(itemAttemptId).then(function(duration) {
                                var params = {
                                    itemDuration: 0
                                };
                                if (_.isNumber(duration) && duration > 0) {
                                    params.itemDuration = duration;
                                }

                                // the duration will be sent to the server with the next request,
                                // usually submitItem() or callItemAction()
                                testRunner.getProxy().addCallActionParams(params);
                            });
                        })

                        .on('move skip exit timeout error disableitem', function(){
                            self.disable();
                        })

                        /**
                          * @event duration.get
                          * @param {String} attemptId - the attempt id to get the duration for
                          * @param {getDuration} getDuration - a receiver callback
                          */
                        .on('plugin-get.duration', function(e, attemptId, getDuration) {
                            if (_.isFunction(getDuration)) {
                                getDuration(getItemDuration(attemptId));
                            }
                        });
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            this.polling.stop();
            this.stopwatch.stop();
        },

        /**
         * Enables the duration count
         */
        enable: function enable() {
            if (!this.getState('enabled')) {
                this.polling.start();
                this.stopwatch.resume();
            }
        },

        /**
         * Disables the duration count
         */
        disable: function disable() {
            if (this.getState('enabled')) {
                this.polling.stop();
                this.stopwatch.pause();
            }
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/helpers/map',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * @typedef {Object} itemStats
     * @property {Number} questions - the number of questions items
     * @property {Number} answered - the number of answered questions
     * @property {Number} flagged - the number of items flagged for review
     * @property {Number} viewed - the number of viewed items
     * @property {Number} total - the total number of items
     * @property {Number} questionsViewed - the number of viewed questions
     */

    /**
     * Gets an empty stats record
     * @returns {itemStats}
     */
    function getEmptyStats() {
        return {
            questions: 0,
            answered: 0,
            flagged: 0,
            viewed: 0,
            total: 0,
            questionsViewed: 0,
        };
    }

    /**
     * Defines a helper that provides extractors for an assessment test map
     */
    return {
        /**
         * Gets the jumps table
         * @param {Object} map - The assessment test map
         * @returns {Object}
         */
        getJumps: function getJumps(map) {
            return map && map.jumps;
        },

        /**
         * Gets the parts table
         * @param {Object} map - The assessment test map
         * @returns {Object}
         */
        getParts: function getParts(map) {
            return map && map.parts;
        },

        /**
         * Get sections table
         * @param {Object} map - The assessment test map
         * @returns {Object} the sections
         */
        getSections: function getSections(map) {
            var parts = this.getParts(map),
                result = {};

            _.forEach(parts, function (part) {
                var sections = part.sections;
                if (sections) {
                    _.forEach(sections, function (section) {
                        result[section.id] = section;
                    });
                }
            });
            return result;
        },

        /**
         * Return the list of remaining sections.
         * @param {Object} map - The assessment test map
         * @param {String} sectionId - The next sections will be gathered once this sectionId has been reached
         * @returns {Object} the next sections
         */
        getNextSections: function getNextSections(map, sectionId) {
            var sections = this.getSections(map),
                result = {},
                canList = false;

            _.forEach(sections, function (section) {
                if (canList) {
                    result[section.id] = section;
                }
                if (section.id === sectionId) {
                    canList = true;
                }
            });

            return result;
        },

        /**
         * Gets the jump at a particular position
         * @param {Object} map - The assessment test map
         * @param {Number} position - The position of the item
         * @returns {Object}
         */
        getJump: function getJump(map, position) {
            var jumps = this.getJumps(map);
            return jumps && jumps[position];
        },

        /**
         * Gets a test part by its identifier
         * @param {Object} map - The assessment test map
         * @param {String} partName - The identifier of the test part
         * @returns {Object}
         */
        getPart: function getPart(map, partName) {
            var parts = this.getParts(map);
            return parts && parts[partName];
        },

        /**
         * Gets a test section by its identifier
         * @param {Object} map - The assessment test map
         * @param {String} sectionName - The identifier of the test section
         * @returns {Object}
         */
        getSection: function getSection(map, sectionName) {
            var parts = this.getParts(map);
            var section = null;
            _.forEach(parts, function (part) {
                var sections = part.sections;
                if (sections && sections[sectionName]) {
                    section = sections[sectionName];
                    return false;
                }
            });
            return section;
        },

        /**
         * Gets a test item by its identifier
         * @param {Object} map - The assessment test map
         * @param {String} itemName - The identifier of the test item
         * @returns {Object}
         */
        getItem: function getItem(map, itemName) {
            var jump = _.find(this.getJumps(map), {identifier: itemName});
            return this.getItemAt(map, jump && jump.position);
        },

        /**
         * Gets the global stats of the assessment test
         * @param {Object} map - The assessment test map
         * @returns {itemStats}
         */
        getTestStats: function getTestStats(map) {
            return map && map.stats;
        },

        /**
         * Gets the stats of the test part containing a particular position
         * @param {Object} map - The assessment test map
         * @param {String} partName - The identifier of the test part
         * @returns {itemStats}
         */
        getPartStats: function getPartStats(map, partName) {
            var part = this.getPart(map, partName);
            return part && part.stats;
        },

        /**
         * Gets the stats of the test section containing a particular position
         * @param {Object} map - The assessment test map
         * @param {String} sectionName - The identifier of the test section
         * @returns {itemStats}
         */
        getSectionStats: function getSectionStats(map, sectionName) {
            var section = this.getSection(map, sectionName);
            return section && section.stats;
        },

        /**
         * Gets the stats related to a particular scope
         * @param {Object} map - The assessment test map
         * @param {Number} position - The current position
         * @param {String} [scope] - The name of the scope. Can be: test, part, section (default: test)
         * @returns {itemStats}
         */
        getScopeStats: function getScopeStats(map, position, scope) {
            var jump = this.getJump(map, position);
            switch (scope) {
                case 'section':
                case 'testSection':
                    return this.getSectionStats(map, jump && jump.section);

                case 'part':
                case 'testPart':
                    return this.getPartStats(map, jump && jump.part);

                default:
                case 'test':
                    return this.getTestStats(map);
            }
        },

        /**
         * Gets the map of a particular scope from a particular position
         * @param {Object} map - The assessment test map
         * @param {Number} position - The current position
         * @param {String} [scope] - The name of the scope. Can be: test, part, section (default: test)
         * @returns {object} The scoped map
         */
        getScopeMap: function getScopeMap(map, position, scope) {
            // need a clone of the map as we will change some properties
            var scopeMap = _.cloneDeep(map || {});

            // gets the current part and section
            var jump = this.getJump(scopeMap, position);
            var part = this.getPart(scopeMap, jump && jump.part);
            var section = this.getSection(scopeMap, jump && jump.section);

            // reduce the map to the scope part
            if (scope && scope !== 'test') {
                scopeMap.parts = {};
                if (part) {
                    scopeMap.parts[jump.part] = part;
                }
            }

            // reduce the map to the scope section
            if (part && (scope === 'section' || scope === 'testSection')) {
                part.sections = {};
                if (section) {
                    part.sections[jump.section] = section;
                }
            }

            // update the stats to reflect the scope
            if (section) {
                section.stats = this.computeItemStats(section.items);
            }
            if (part) {
                part.stats = this.computeStats(part.sections);
            }
            scopeMap.stats = this.computeStats(scopeMap.parts);

            return scopeMap;
        },

        /**
         * Gets the map of a particular scope from a current context
         * @param {Object} map - The assessment test map
         * @param {Object} context - The current session context
         * @param {String} [scope] - The name of the scope. Can be: test, part, section (default: test)
         * @returns {object} The scoped map
         */
        getScopeMapFromContext: function getScopeMapFromContext(map, context, scope) {
            // need a clone of the map as we will change some properties
            var scopeMap = _.cloneDeep(map || {});
            var part;
            var section;

            // gets the current part and section
            if (context && context.testPartId) {
                part = this.getPart(scopeMap, context.testPartId);
            }
            if (context && context.sectionId) {
                section = this.getSection(scopeMap, context.sectionId);
            }

            // reduce the map to the scope part
            if (scope && scope !== 'test') {
                scopeMap.parts = {};
                if (part) {
                    scopeMap.parts[context.testPartId] = part;
                }
            }

            // reduce the map to the scope section
            if (part && (scope === 'section' || scope === 'testSection')) {
                part.sections = {};
                if (section) {
                    part.sections[context.sectionId] = section;
                }
            }

            // update the stats to reflect the scope
            if (section) {
                section.stats = this.computeItemStats(section.items);
            }
            if (part) {
                part.stats = this.computeStats(part.sections);
            }
            scopeMap.stats = this.computeStats(scopeMap.parts);

            return scopeMap;
        },

        /**
         * Gets the test part containing a particular position
         * @param {Object} map - The assessment test map
         * @param {Number} position - The position of the item
         * @returns {Object}
         */
        getItemPart: function getItemPart(map, position) {
            var jump = this.getJump(map, position);
            return this.getPart(map, jump && jump.part);
        },

        /**
         * Gets the test section containing a particular position
         * @param {Object} map - The assessment test map
         * @param {Number} position - The position of the item
         * @returns {Object}
         */
        getItemSection: function getItemSection(map, position) {
            var jump = this.getJump(map, position);
            var part = this.getPart(map, jump && jump.part);
            var sections = part && part.sections;
            return sections && sections[jump && jump.section];
        },

        /**
         * Gets the item located at a particular position
         * @param {Object} map - The assessment test map
         * @param {Number} position - The position of the item
         * @returns {Object}
         */
        getItemAt: function getItemAt(map, position) {
            var jump = this.getJump(map, position);
            var part = this.getPart(map, jump && jump.part);
            var sections = part && part.sections;
            var section = sections && sections[jump && jump.section];
            var items = section && section.items;
            return items && items[jump && jump.identifier];
        },

        /**
         * Gets the identifier of an existing item
         * @param {Object} map - The assessment test map
         * @param {Number|String} position - The position of the item, can already be the identifier
         * @returns {String}
         */
        getItemIdentifier: function getItemIdentifier(map, position) {
            var item;
            if (_.isFinite(position)) {
                item = this.getItemAt(map, position);
            } else {
                item = this.getItem(map, position);
            }
            return item && item.id;
        },

        /**
         * Applies a callback on each item of the provided map
         * @param {Object} map - The assessment test map
         * @param {Function} callback(item, section, part, map) - A callback to apply on each item
         * @returns {Object}
         */
        each: function each(map, callback) {
            if (_.isFunction(callback)) {
                _.forEach(map && map.parts, function(part) {
                    _.forEach(part && part.sections, function(section) {
                        _.forEach(section && section.items, function(item) {
                            callback(item, section, part, map);
                        });
                    });
                });
            }
            return map;
        },

        /**
         * Update the map stats from a particular item
         * @param {Object} map - The assessment test map
         * @param {Number} position - The position of the item
         * @returns {Object}
         */
        updateItemStats: function updateItemStats(map, position) {
            var jump = this.getJump(map, position);
            var part = this.getPart(map, jump && jump.part);
            var sections = part && part.sections;
            var section = sections && sections[jump && jump.section];

            if (section) {
                section.stats = this.computeItemStats(section.items);
            }
            if (part) {
                part.stats = this.computeStats(part.sections);
            }
            if (map) {
                map.stats = this.computeStats(map.parts);
            }

            return map;
        },

        /**
         * Computes the stats for a list of items
         * @param {Object} items
         * @returns {itemStats}
         */
        computeItemStats: function computeItemStats(items) {
            return _.reduce(items, function accStats(acc, item) {
                if (!item.informational) {
                    acc.questions++;

                    if (item.answered) {
                        acc.answered++;
                    }

                    if (item.viewed) {
                        acc.questionsViewed++;
                    }
                }
                if (item.flagged) {
                    acc.flagged++;
                }
                if (item.viewed) {
                    acc.viewed++;
                }
                acc.total++;
                return acc;
            }, getEmptyStats());
        },

        /**
         * Computes the global stats of a collection of stats
         * @param {Object} collection
         * @returns {itemStats}
         */
        computeStats: function computeStats(collection) {
            return _.reduce(collection, function accStats(acc, item) {
                acc.questions += item.stats.questions;
                acc.answered += item.stats.answered;
                acc.flagged += item.stats.flagged;
                acc.viewed += item.stats.viewed;
                acc.total += item.stats.total;
                acc.questionsViewed += item.stats.questionsViewed;
                return acc;
            }, getEmptyStats());
        },

        /**
         * Patch a testMap with a partial testMap.
         *
         * If the currentMap is null or the scope is test,
         * we just use the partialMap as it is.
         *
         * Indexes, position and stats will be (re)built.
         *
         * @param {Object} currentMap - the map to patch
         * @param {Object} partialMap - the patch
         * @param {String} partialMap.scope - indicate the scope of the patch (test, part or section)
         * @returns {Object} the patched testMap
         * @throws {TypeError} if the partialMap is no a map
         */
        patch : function patch(currentMap, partialMap) {
            var self = this;
            var targetMap;

            if(!_.isPlainObject(partialMap) || !partialMap.parts) {
                throw new TypeError('Invalid test map format');
            }

            if(!currentMap || partialMap.scope === 'test'){
                targetMap = _.cloneDeep(partialMap);
            } else {

                targetMap = _.cloneDeep(currentMap);

                _.forEach(partialMap.parts, function(partialPart, targetPartId){
                    if (partialMap.scope === 'part') {
                        //replace the target part
                        targetMap.parts[targetPartId] = _.cloneDeep(partialPart);
                    }
                    if (partialMap.scope === 'section') {
                        _.forEach(partialPart.sections, function(partialSection, targetSectionId){
                            //replace the target section
                            targetMap.parts[targetPartId].sections[targetSectionId] = _.cloneDeep(partialSection);

                            //compte new section stats
                            targetMap.parts[targetPartId].sections[targetSectionId].stats = self.computeItemStats(targetMap.parts[targetPartId].sections[targetSectionId].items);
                        });
                    }
                    //compte new/updated part stats
                    targetMap.parts[targetPartId].stats = self.computeStats(targetMap.parts[targetPartId].sections);
                });
                //compte updated test stats
                targetMap.stats = this.computeStats(targetMap.parts);
            }

            //the updated map can have a different size than the original
            targetMap = this.reindex(targetMap);

            return targetMap;
        },

        /**
         * Rebuild the indexes, positions of all map parts.
         * Then recreate the jump table.
         *
         * @param {Object} map - the map to reindex
         * @returns {Object} the brand new map
         * @throws {TypeError} if the map is no a map
         */
        reindex : function reindex(map){
            var offset        = 0;
            var offsetPart    = 0;
            var offsetSection = 0;
            var lastPartId;
            var lastSectionId;

            if(!_.isPlainObject(map) || !map.parts) {
                throw new TypeError('Invalid test map format');
            }

            //remove the jump table
            map.jumps = [];

            //browse the test map, by position
            _.sortBy(map && map.parts, 'position').forEach(function(part) {
                _.sortBy(part && part.sections, 'position').forEach(function(section) {
                    _.sortBy(section && section.items, 'position').forEach(function(item) {

                        if(lastPartId !== part.id){
                            offsetPart = 0;
                            lastPartId = part.id;
                            part.position = offset;
                        }
                        if(lastSectionId !== section.id){
                            offsetSection = 0;
                            lastSectionId = section.id;
                            section.position = offset;
                        }
                        item.position = offset;
                        item.index    = offsetSection + 1;
                        item.positionInPart = offsetPart;
                        item.positionInSection = offsetSection;

                        map.jumps[offset] = {
                            identifier : item.id,
                            section    : section.id ,
                            part       : part.id,
                            position   : offset
                        };

                        offset++;
                        offsetSection++;
                        offsetPart++;
                    });
                });
            });

            return map;
        },

        /**
         * Create the jump table for a test map
         *
         * @param {Object} map - the map
         * @returns {Object} the brand new map with a jump table
         * @throws {TypeError} if the map is no a map
         */
        createJumpTable : function createJumpTable(map){

            if(!_.isPlainObject(map) || !map.parts) {
                throw new TypeError('Invalid test map format');
            }

            map.jumps = [];

            this.each(map, function (item, section, part){
                var offset = item.position;
                map.jumps[offset] = {
                    identifier : item.id,
                    section    : section.id ,
                    part       : part.id,
                    position   : offset
                };
            });

            return map;
        }
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Compute the current progress in the Test Runner
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/progressbar/progress',[
    'lodash',
    'i18n',
    'core/format',
    'taoQtiTest/runner/helpers/map'
], function (_, __, format, mapHelper) {
    'use strict';

    /**
     * @typedef {Object} progressDetails
     * @property {Number} position - the position in the current element
     * @property {Number} reached - the number of reached elements (at least one item viewed)
     * @property {Number} viewed - the number of viewed elements (all items viewed)
     * @property {Number} completed - the number of completed elements (all questions answered)
     * @property {Number} total - the total number of elements
     */

    /**
     * @typedef {itemStats} progressData
     * @property {Number} position - the position in the scope
     * @property {Number} overallCompleted - the number of completed items in the test
     * @property {Number} overall - the total number of items in the test
     * @property {progressDetails} sections - the details of testSections in the scope
     * @property {progressDetails} parts - the details of testParts in the scope
     * @property {progressDetails} answerableSections - the details of testSections that contain questions in the scope
     * @property {progressDetails} answerableParts - the details of testParts that contain questions in the scope
     * @property {progressDetails} matchedCategories - the details of items that match the expected categories in the scope
     */

    /**
     * @typedef {Object} progressIndicator
     * @property {Number} position - the position in the scope
     * @property {Number} total - the length of the scope
     * @property {Number} ratio - the progress ratio of the indicator
     * @property {String} label - the text to display for the indicator
     */

    /**
     * @typedef {Object} progressConfig
     * @property {String} scope - the scope of the progression
     * @property {String} indicator - the type of progression
     * @property {Bool} showTotal - display 'item x of y' (true) | 'item x'
     * @property {Array} categories - categories to count by them
     */

    /**
     * Default progress config
     * @type {Object}
     */
    var defaultConfig = {
        scope: 'test',
        indicator: 'percentage',
        showTotal: true,
        categories: []
    };

    /**
     * List of labels by types
     * @type {Object}
     */
    var labels = {
        item: {
            long: __('Item %d of %d'),
            short: __('Item %d')
        },
        section: {
            long: __('Section %d of %d'),
            short: __('Section %d')
        }
    };

    /**
     * Simple map of progress stats computers
     * @type {Object}
     */
    var scopes = {
        /**
         * Gets stats for the whole test
         * @param {Object} testMap - the actual test map
         * @param {Object} testContext - the actual test context
         * @param {progressConfig} config - a config object
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressData}
         */
        test: function test(testMap, testContext, config) {
            var stats = getProgressStats(testMap, testContext, config, 'test');
            var item = mapHelper.getItemAt(testMap, testContext.itemPosition);
            stats.position = item.position + 1;
            return stats;
        },

        /**
         * Gets stats for the current test part
         * @param {Object} testMap - the actual test map
         * @param {Object} testContext - the actual test context
         * @param {progressConfig} config - a config object
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressData}
         */
        testPart: function testPart(testMap, testContext, config) {
            var stats = getProgressStats(testMap, testContext, config, 'testPart');
            var item = mapHelper.getItemAt(testMap, testContext.itemPosition);
            stats.position = item.positionInPart + 1;
            return stats;
        },

        /**
         * Gets stats for the current test section
         * @param {Object} testMap - the actual test map
         * @param {Object} testContext - the actual test context
         * @param {progressConfig} config - a config object
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressData}
         */
        testSection: function testSection(testMap, testContext, config) {
            var stats = getProgressStats(testMap, testContext, config, 'testSection');
            var item = mapHelper.getItemAt(testMap, testContext.itemPosition);
            stats.position = item.positionInSection + 1;
            return stats;
        }
    };

    /**
     * Simple map of progress indicator computers
     * @type {Object}
     */
    var indicators = {
        /**
         * Indicator that shows the percentage of completed items
         * @param {progressData} stats
         * @returns {progressIndicator}
         */
        percentage: function percentage(stats) {
            return getRatioProgression(stats.answered, stats.questions);
        },

        /**
         * Indicator that shows the position of current item
         * @param {progressData} stats
         * @param {progressConfig} config
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressIndicator}
         */
        position: function position(stats, config) {
            return getPositionProgression(stats.position, stats.total, 'item', config);
        },

        /**
         * Indicator that shows the number of viewed questions
         * @param {progressData} stats
         * @param {progressConfig} config
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressIndicator}
         */
        questions: function questions(stats, config) {
            return getPositionProgression(stats.questionsViewed, stats.questions, 'item', config);
        },

        /**
         * Indicator that shows the number of reached answerable sections
         * @param {progressData} stats
         * @param {progressConfig} config
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressIndicator}
         */
        sections: function sections(stats, config) {
            return getPositionProgression(stats.answerableSections.reached, stats.answerableSections.total, 'section', config);
        },

        /**
         * Indicator that shows the number of viewed items which have categories from the configuration
         * (show all if categories are not set)
         * @param {progressData} stats
         * @param {progressConfig} config
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         */
        categories: function categories(stats, config) {
            return getPositionProgression(stats.matchedCategories.position, stats.matchedCategories.total, 'item', config);
        }
    };

    /**
     * Fix the test map if the current test part is linear, as the current item should not be answered.
     * @param {Object} testMap - the actual test map
     * @param {Object} testContext - the actual test context
     * @returns {Object} The fixed test map
     */
    function getFixedMap(testMap, testContext) {
        var item;
        if (testContext.itemAnswered && testContext.isLinear) {
            testMap = _.cloneDeep(testMap);
            item = mapHelper.getItemAt(testMap, testContext.itemPosition);
            item.answered = false;
        }
        return testMap;
    }

    /**
     * Gets an empty stats record
     * @returns {progressDetails}
     */
    function getEmptyStats() {
        return {
            position: 0,
            reached: 0,
            viewed: 0,
            completed: 0,
            total: 0
        };
    }

    /**
     * Updates the progress stats from the given element
     * @param {progressDetails} stats - The stats details to update
     * @param {Object} element - The element from which take the details
     * @param {Number} position - The current item position
     */
    function updateStats(stats, element, position) {
        if (element.position <= position) {
            stats.position++;
        }
        if (element.stats.viewed) {
            stats.reached++;

            if (element.stats.viewed === element.stats.total) {
                stats.viewed++;
            }
        }
        if (element.stats.answered) {
            if (element.stats.answered === element.stats.questions) {
                stats.completed++;
            }
        }
        stats.total++;
    }

    /**
     * Updates the progress stats from the given element
     * @param {progressDetails} stats - The stats details to update
     * @param {Object} element - The element from which take the details
     * @param {Number} position - The current item position
     */
    function updateItemStats(stats, element, position) {
        if (element.position <= position) {
            stats.position++;
        }
        if (element.viewed) {
            stats.reached++;
            stats.viewed++;
        }
        if (element.answered) {
            stats.completed++;
        }
        stats.total++;
    }

    /**
     * Convert list of the categories to the hashtable to improve performance
     * @param categories
     * @returns {*}
     */
    function getCategoriesToMatch(categories) {
        var matchSize = categories && categories.length;
        return matchSize && _.reduce(categories, function(map, category) {
            map[category] = true;
            return map;
        }, {});
    }

    /**
     * Completes the progression stats
     * @param {Object} testMap - the actual test map
     * @param {Object} testContext - the actual test context
     * @param {progressConfig} config
     * @param {String} config.scope - the scope of the progression
     * @param {Array} config.categories - categories to count by them
     * @param {String} [scope] - The name of the scope. Can be: test, part, section (default: test)
     * @returns {progressData}
     */
    function getProgressStats(testMap, testContext, config, scope) {
        var fixedMap = getFixedMap(testMap, testContext);
        var scopedMap = mapHelper.getScopeMap(fixedMap, testContext.itemPosition, scope);
        var stats = _.clone(scopedMap.stats);
        var categoriesToMatch;
        var matchSize;

        if (config.indicator === 'categories') {
            categoriesToMatch = getCategoriesToMatch(config.categories);
            matchSize = config.categories && config.categories.length;
            stats.matchedCategories = getEmptyStats();
        }

        stats.parts = getEmptyStats();
        stats.sections = getEmptyStats();
        stats.answerableParts = getEmptyStats();
        stats.answerableSections = getEmptyStats();

        _.forEach(scopedMap.parts, function (part) {
            updateStats(stats.parts, part, testContext.itemPosition);

            if (part.stats.questions > 0) {
                updateStats(stats.answerableParts, part, testContext.itemPosition);
            }

            _.forEach(part.sections, function (section) {
                updateStats(stats.sections, section, testContext.itemPosition);

                if (section.stats.questions > 0) {
                    updateStats(stats.answerableSections, section, testContext.itemPosition);
                }

                if (config.indicator === 'categories') {
                    _.forEach(section.items, function (item) {
                        if (matchCategories(item.categories, categoriesToMatch, matchSize)) {
                            updateItemStats(stats.matchedCategories, item, testContext.itemPosition);
                        }
                    });
                }
            });
        });

        return stats;
    }

    /**
     *
     * @param {Array} categories - List of categories to check
     * @param {Object} expectedCategories - Hashtable of expected categories
     * @param {Number} minWanted - Minimal number of expected categories that should match
     * @returns {Boolean}
     */
    function matchCategories(categories, expectedCategories, minWanted) {
        var matched = 0;

        if (expectedCategories) {
            _.forEach(categories, function(category) {
                if (expectedCategories[category]) {
                    matched ++;
                    if (matched >= minWanted) {
                        return false;
                    }
                }
            });
        }
        return matched === minWanted;
    }

    /**
     * Gets the progression ratio
     * @param {Number} position
     * @param {Number} total
     * @returns {Number}
     */
    function getRatio(position, total) {
        if (position && total > 0) {
            return Math.floor(position / total * 100);
        }
        return 0;
    }

    /**
     * Gets the label of the progress bar for an item
     * @param {Number} position - the current position
     * @param {Number} total - the total number of items
     * @param {String} type - the type of element that is represented
     * @param {progressConfig} config - a config object
     * @param {String} config.scope - the scope of the progression
     * @param {Array} config.categories - categories to count by them
     * @returns {String}
     */
    function getProgressionLabel(position, total, type, config) {
        var patterns = labels[type] || labels.item;
        var pattern = config.showTotal ? patterns.long : patterns.short;
        return format(pattern, position || '0', total || '0');
    }

    /**
     * Gets the progression based on position
     * @param {Number} position - the current position
     * @param {Number} total - the total number of items
     * @param {String} type - the type of element that is represented
     * @param {progressConfig} config - a config object
     * @param {String} config.scope - the scope of the progression
     * @param {Array} config.categories - categories to count by them
     * @returns {progressIndicator}
     */
    function getPositionProgression(position, total, type, config) {
        return {
            position: position || 0,
            total: total || 0,
            ratio: getRatio(position, total),
            label: getProgressionLabel(position, total, type, config)
        };
    }

    /**
     * Gets the progression based on a ratio
     * @param {Number} position - the current position
     * @param {Number} total - the total number of items
     * @returns {progressIndicator}
     */
    function getRatioProgression(position, total) {
        var ratio = getRatio(position, total);
        return {
            position: position || 0,
            total: total || 0,
            ratio: ratio,
            label: ratio + '%'
        };
    }

    return {

        /**
         * Checks that categories matched
         * @param categories
         * @param expectedCategories
         * @returns {Boolean}
         */
        isMatchedCategories: function validCategories(categories, expectedCategories) {
            var categoriesToMatch = getCategoriesToMatch(expectedCategories);
            var matchSize = expectedCategories && expectedCategories.length;
            return matchCategories(categories, categoriesToMatch, matchSize);
        },

        /**
         * Computes the progress stats for the specified scope
         * @param {Object} testMap - the actual test map
         * @param {Object} testContext - the actual test context
         * @param {progressConfig} config - a config object
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @returns {progressData}
         */
        computeStats: function computeStats(testMap, testContext, config) {
            var statsComputer = (config.scope && scopes[config.scope]) || scopes.test;
            var stats = statsComputer(testMap, testContext, config || defaultConfig);
            stats.overallCompleted = testContext.numberCompleted;
            stats.overall = testContext.numberItems;
            return stats;
        },

        /**
         * Computes the specified progress indicator
         * @param {progressData} stats - the progress stats
         * @param {String} type - the [type="percentage"] of indicator to compute (could be: percentage, position, questions, sections)
         * @param {progressConfig} [config] - a config object
         * @param {Boolean} [config.showTotal] - display 'item x of y' (true) | 'item x'
         * @returns {progressIndicator}
         */
        computeIndicator: function computeIndicator(stats, type, config) {
            var indicatorComputer = (type && indicators[type]) || indicators.percentage;
            return indicatorComputer(stats || {}, config || defaultConfig);
        },

        /**
         *
         * @param {Object} testMap - the actual test map
         * @param {Object} testContext - the actual test context
         * @param {progressConfig} config - a config object
         * @param {String} config.indicator - the type of progression
         * @param {String} config.scope - the scope of the progression
         * @param {Array} config.categories - categories to count by them
         * @param {Boolean} [config.showTotal=true] - display 'item x of y' (true) | 'item x'
         */
        computeProgress: function computeProgress(testMap, testContext, config) {
            var progressData;
            config = _.defaults(config || {}, defaultConfig);
            progressData = this.computeStats(testMap, testContext, config);
            return this.computeIndicator(progressData, config.indicator, config);
        }
    };
});


define('tpl!taoQtiTest/runner/plugins/controls/progressbar/renderer/percentage', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"progress-box\">\n    <div data-control=\"progress-bar\" class=\"qti-controls progressbar info\"></div>\n    <div data-control=\"progress-label\" class=\"qti-controls\"></div>\n</div>\n";
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/progressbar/renderer/percentage',[
    'ui/component',
    'tpl!taoQtiTest/runner/plugins/controls/progressbar/renderer/percentage',
    'ui/progressbar'
], function (component, percentageTpl) {
    'use strict';

    /**
     * Default config values
     * @type {Object}
     */
    var defaults = {
        showLabel: true
    };

    /**
     * Builds percentage indicator renderer
     * @param {Object} [config] - a config object
     * @param {Boolean} [config.showLabel=true] - show/hide the progress label
     * @param {Object} [progressData] - the initial dataset
     */
    return function percentageIndicatorRenderer(config, progressData) {
        var rendererApi = {
            /**
             * Update the progress bar according to the provided indicator data
             * @param {progressIndicator} data
             */
            update: function update(data) {
                progressData = data;
                if (this.is('rendered') && this.controls) {
                    this.controls.$label.text(progressData.label);
                    this.controls.$bar.progressbar('value', progressData.ratio);
                }

                /**
                 * Executes extra tasks on update
                 * @event percentageIndicatorRenderer#update
                 * @param {progressIndicator} data
                 */
                this.trigger('update', data);
            }
        };

        return component(rendererApi, defaults)
            .setTemplate(percentageTpl)
            .on('render', function() {
                // get access to the controls
                this.controls = {
                    $label: this.getElement().find('[data-control="progress-label"]'),
                    $bar: this.getElement().find('[data-control="progress-bar"]')
                };

                // apply option
                if (!this.config.showLabel) {
                    this.controls.$label.hide();
                }

                // and initialize the progress bar component
                this.controls.$bar.progressbar();

                // set the right progression according to init data
                if (progressData) {
                    this.update(progressData);
                }

                // forward the hidden state if it has been set before render
                if (this.is('hidden')) {
                    this.hide();
                }
            })
            .on('destroy', function() {
                this.controls = null;
            })
            .init(config);
    };
});


define('tpl!taoQtiTest/runner/plugins/controls/progressbar/renderer/position', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"progress-box\">\n    <div data-control=\"progress-bar\" class=\"qti-controls progressbar\">\n        <div class=\"progressbar-points\"></div>\n    </div>\n    <div data-control=\"progress-label\" class=\"qti-controls\"></div>\n</div>\n";
  });
});


define('tpl!taoQtiTest/runner/plugins/controls/progressbar/renderer/position-point', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "";
  buffer += "\n<span class=\"progressbar-point\" data-index=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"></span>\n";
  return buffer;
  }

  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/progressbar/renderer/position',[
    'lodash',
    'ui/component',
    'tpl!taoQtiTest/runner/plugins/controls/progressbar/renderer/position',
    'tpl!taoQtiTest/runner/plugins/controls/progressbar/renderer/position-point'
], function (_, component, positionTpl, pointTpl) {
    'use strict';

    /**
     * Default config values
     * @type {Object}
     */
    var defaults = {
        showLabel: true
    };

    /**
     * Builds percentage indicator renderer
     * @param {Object} [config] - a config object
     * @param {Boolean} [config.showLabel=true] - show/hide the progress label
     * @param {Object} [progressData] - the initial dataset
     */
    return function positionIndicatorRenderer(config, progressData) {
        var count = 0;

        var rendererApi = {
            /**
             * Update the progress bar according to the provided indicator data
             * @param {progressIndicator} data
             */
            update: function update(data) {
                progressData = data;
                if (this.is('rendered') && this.controls) {
                    if (count !== progressData.total) {
                        // the number of points have changed, regenerate the full bar
                        count = progressData.total;
                        this.controls.$bar.empty().append(pointTpl(_.range(count)));
                    }
                    this.controls.$label.text(progressData.label);
                    this.controls.$bar
                        // remove progression from all points
                        .children().removeClass('reached current')
                        // set progression to each reached point
                        .slice(0, progressData.position).addClass('reached')
                        // set current position
                        .slice(-1).addClass('current');
                }

                /**
                 * Executes extra tasks on update
                 * @event positionIndicatorRenderer#update
                 * @param {progressIndicator} data
                 */
                this.trigger('update', data);
            }
        };

        return component(rendererApi, defaults)
            .setTemplate(positionTpl)
            .on('render', function() {
                // get access to the controls
                this.controls = {
                    $label: this.getElement().find('[data-control="progress-label"]'),
                    $bar: this.getElement().find('[data-control="progress-bar"] .progressbar-points')
                };

                // apply option
                if (!this.config.showLabel) {
                    this.controls.$label.hide();
                }

                // set the right progression according to init data
                if (progressData) {
                    this.update(progressData);
                }

                // forward the hidden state if it has been set before render
                if (this.is('hidden')) {
                    this.hide();
                }
            })
            .on('destroy', function() {
                this.controls = null;
            })
            .init(config);
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016-2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Control Plugin : Progress Bar
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/progressbar/progressbar',[
    'lodash',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/helpers/map',
    'taoQtiTest/runner/plugins/controls/progressbar/progress',
    'taoQtiTest/runner/plugins/controls/progressbar/renderer/percentage',
    'taoQtiTest/runner/plugins/controls/progressbar/renderer/position'
], function (_, pluginFactory, mapHelper, progressHelper, percentageRendererFactory, positionRendererFactory){
    'use strict';

    /**
     * List of available progress indicator renderers
     * @type {Object}
     */
    var renderers = {
        percentage: percentageRendererFactory,
        position: positionRendererFactory
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name : 'progressBar',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var testRunner = this.getTestRunner();
            var testData   = testRunner.getTestData();
            var config     = _.defaults(this.getConfig(), testData.config.progressIndicator || {});
            var self       = this;

            var rendererFactory = renderers[config.renderer] || renderers.percentage;
            var progressConfig = {
                indicator: config.type || 'percentage',
                scope: config.scope || 'test',
                showLabel: config.showLabel,
                showTotal: config.showTotal,
                categories: config.categories
            };

            var hiddenByQuestions = function hiddenByQuestions(item) {
                return item && item.informational && progressConfig.indicator === 'questions';
            };

            var hiddenByCategories = function (item) {
                return item
                    && progressConfig.indicator === 'categories'
                    && !progressHelper.isMatchedCategories(item.categories, progressConfig.categories);
            };

            /**
             * Check if progress bar should be hidden
             */
            var isProgressbarHidden = function isProgressbarHidden(item) {
                return hiddenByQuestions(item) || hiddenByCategories(item);
            };

            /**
             * Update the progress bar
             */
            var update = function update (){
                var testContext = testRunner.getTestContext();
                var testMap = testRunner.getTestMap();
                var item = mapHelper.getItemAt(testMap, testContext.itemPosition);

                if (isProgressbarHidden(item)) {
                    self.renderer.hide();
                } else {
                    self.renderer.show();
                    self.renderer.update(progressHelper.computeProgress(testMap, testContext, progressConfig));
                }
            };

            //create the progressbar
            this.renderer = rendererFactory(progressConfig);

            //let update the progression
            update();

            testRunner.on('ready loaditem', update);
        },

        /**
         * Called during the runner's render phase
         */
        render : function render() {
            var $container = this.getAreaBroker().getControlArea();
            this.renderer.render($container);
        },

        /**
         * Called during the runner's render phase
         */
        destroy : function destroy() {
            if (this.renderer) {
                this.renderer.destroy();
            }
            this.renderer = null;
        },

        /**
         * Show the progress bar
         */
        show: function show() {
            if (this.renderer) {
                this.renderer.show();
            }
        },

        /**
         * Hide the progress bar
         */
        hide: function hide() {
            if (this.renderer) {
                this.renderer.hide();
            }
        }
    });
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/controls/testState/testState',[
    'lodash',
    'taoTests/runner/plugin'
], function (_, pluginFactory) {
    'use strict';

    /**
     * Creates the testState plugin.
     * Handle particular states of the assessment test
     */
    return pluginFactory({

        name: 'testState',

        /**
         * Installs the plugin (called when the runner bind the plugin)
         */
        install: function install() {
            var testRunner = this.getTestRunner();

            // middleware invoked on every requests
            testRunner.getProxy()
                .use(function qtiFilter(req, res, next) {
                    var data = res && res.data;

                    // test has been closed/suspended => redirect to the index page after message acknowledge
                    if (data && data.type && data.type === 'TestState' && !testRunner.getState('closedOrSuspended')) {

                        // spread the world about the reason of the leave
                        testRunner.setState('closedOrSuspended', true);

                        if (!testRunner.getState('ready')) {
                            // if we open an inconsistent test just leave
                            // should happen if we refresh an auto paused test
                            testRunner.trigger('destroy');
                        } else if (_.isEmpty(data.messages) || !_.find(data.messages, {channel: 'teststate'})) {
                            testRunner.trigger('leave', data);
                        }
                        // break the chain to avoid uncaught exception in promise...
                        // this will lead to unresolved promise, but the browser will be redirected soon!
                        return;
                    }
                    next();
                });
        },

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var testRunner = this.getTestRunner();
            var isLeaving = false;

            // immediate handling of proctor's actions
            testRunner.getProxy()
                .channel('teststate', function (data) {
                    if (!isLeaving && data && ('close' === data.type || 'pause' === data.type) && !testRunner.getState('closedOrSuspended')) {
                        isLeaving = true;

                        testRunner.setState('closedOrSuspended', true);

                        testRunner.trigger('leave', data);
                    }
                });
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/controls/timer/component/tpl/countdown', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"countdown\" data-control=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-type=\"";
  if (helper = helpers.type) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.type); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-scope=\"";
  if (helper = helpers.scope) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.scope); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" disabled>\n    <span class=\"label truncate\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    <span class=\"time\"></span>\n</div>\n";
  return buffer;
  });
});


define('css!taoQtiTest/runner/plugins/controls/timer/component/css/countdown',[],function(){});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Component that controls the display of a countdown.
 *
 * You can either control the countdown externally  or internally
 *
 * @example
 * countdown(document.querySelector('.stopwatch'), {
 *      id : 'timer1',
 *      label : 'Stop watch',
 *      remaingTime : 60000
 * })
 * .on('complete', () => console.log('done'))
 * .start();
 *
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/component/countdown',[
    'jquery',
    'lodash',
    'core/encoder/time',
    'core/polling',
    'core/timer',
    'ui/component',
    'tpl!taoQtiTest/runner/plugins/controls/timer/component/tpl/countdown',
    'ui/tooltip',
    'css!taoQtiTest/runner/plugins/controls/timer/component/css/countdown.css'
], function ($, _, timeEncoder, pollingFactory, timerFactory, component, countdownTpl) {
    'use strict';

    //Precision is milliseconds
    var precision = 1000;

    /**
     * Default config values, see below.
     */
    var defaults = {
        showBeforeStart : true,
        displayWarning : true,
        polling   : true,
        frequency : 500
    };

    /**
     * time to display warnings
     */
    var warningTimeout =  {
        info:    2000,
        success: 2000,
        warning: 4000,
        danger:  4000,
        error:   8000
    };

    /**
     * Creates, initialize and render a countdown component.
     *
     * @param {jQueryElement|HTMLElement} $container - where to append the countdown
     * @param {Object} config
     * @param {String} config.id - the timer unique identifier
     * @param {String} config.label - the text to display above the timer
     * @param {String} config.type - the type of countdown (to categorize them)
     * @param {Number} [config.remainingTime] - the current value of the countdown, in milliseconds
     * @param {Boolean} [config.polling = true] - does the countdown handles the polling itself ?
     * @param {Number} [config.frequency = 500] - polling frequency in ms (if active)
     * @param {Boolean} [config.showBeforeStart = true] - do we show the time before starting
     * @param {Boolean} [config.displayWarning = true] - do we display the warnings or trigger only the event
     * @param {Object[]} [config.warnings] - define warnings thresholds
     * @param {Number} [config.warnings.threshold] - when the warning is shown, in milliseconds
     * @param {String} [config.warnings.message] - the warning message
     * @param {String} [config.warnings.level = warn] - the feedback level in (success, info, warn, danger and error)
     * @returns {countdown} the component, initialized and rendered
     */
    return function countdownFactory($container, config){
        var $time;

        /**
         * @typedef {Object} countdown
         */
        var countdown = component({

            /**
             * Update the countdown
             * @param {Number} remainingTime - the time remaining (milliseconds)
             * @returns {countdown} chains
             * @fires countdown#change - when the value has changed
             * @fires countdown#warn - when a threshold is reached
             */
            update: function udpate(remainingTime){
                var self = this;
                var encodedTime;
                var warningId;
                var warningMessage;

                if(!this.is('completed')){
                    if(remainingTime <= 0){
                        this.remainingTime = 0;
                    } else {
                        this.remainingTime = parseInt(remainingTime, 10);
                    }
                    if (this.is('rendered') && this.is('running')){

                        encodedTime = timeEncoder.encode(this.remainingTime / precision );
                        if(encodedTime !== this.encodedTime){
                            this.encodedTime = encodedTime;

                            $time.text(this.encodedTime);
                        }

                        if(this.warnings) {
                            //the warnings have already be sorted
                            warningId =  _.findLastKey(this.warnings, function(warning){
                                return warning && !warning.shown &&
                                       warning.threshold > 0 &&
                                       warning.threshold >= self.remainingTime;

                            });
                            if(warningId){

                                this.warnings[warningId].shown = true;

                                if(_.isFunction(this.warnings[warningId].message)){
                                    warningMessage = this.warnings[warningId].message(this.remainingTime);
                                } else {
                                    warningMessage = this.warnings[warningId].message;
                                }

                                /**
                                 * Warn user the timer reach a threshold
                                 * @event countdown#warn
                                 * @param {String} message
                                 * @param {String} level
                                 */
                                this.trigger('warn', warningMessage, this.warnings[warningId].level);
                            }
                        }

                        /**
                         * The current value has changed
                         * @event countdown#change
                         * @param {Number} remainingTime - the updated time
                         * @param {String} displayed - the displayed value
                         */
                        this.trigger('change', this.remainingTime, encodedTime);
                    }
                    if(this.remainingTime === 0){
                        this.complete();
                    }
                }
                return this;
            },

            /**
             * Starts the countdown
             * @returns {countdown} chains
             * @fires countdown#start
             */
            start : function start(){
                if(this.is('rendered') && !this.is('running') && !this.is('completed')){

                    this.enable();
                    this.setState('running', true);

                    if(this.polling){
                        this.polling.start();

                        if(!this.is('started')){
                            this.setState('started', true);
                            this.timer.start();
                        } else {
                            this.timer.resume();
                        }
                    }

                    /**
                     * The count has started
                     * @event countdown#start
                     */
                    this.trigger('start');
                }
                return this;
            },


            /**
             * Stops the countdown (can be restarted then)
             * @returns {countdown} chains
             * @fires countdown#stop
             */
            stop : function stop(){
                if(this.is('rendered') && this.is('running')){

                    this.setState('running', false);

                    if(this.polling){
                        this.timer.pause();
                        this.polling.stop();
                    }

                    /**
                     * The count is stopped
                     * @event countdown#stop
                     */
                    this.trigger('stop');
                }
                return this;
            },

            /**
             * Calls to complete the countdown,
             * it can't be resumed after.
             *
             * @returns {countdown} chains
             *
             * @fires countdown#complete
             * @fires countdown#end
             */
            complete : function complete(){
                if(this.is('rendered') && this.is('running') && !this.is('completed')){

                    this.stop();
                    this.setState('completed', true);

                    /**
                     * The countdown has ended, is completed
                     * @event countdown#complete
                     * @event countdown#end (alias)
                     */
                    this.trigger('complete end');
                }
                return this;
            }


        }, defaults)
        .on('init', function(){
            var self = this;

            this.remainingTime = this.config.remainingTime;

            if(this.config.warnings){
                this.warnings = _.sortBy(this.config.warnings, 'threshold');
            }

            //if configured, create a polling for the countdown
            if(this.config.polling === true && this.config.frequency > 0){
                this.timer   = timerFactory({
                    autoStart: false
                });
                this.polling = pollingFactory({
                    action: function pollingAction(){
                        var elapsed = self.timer.tick();
                        self.update(self.remainingTime - elapsed);
                    },
                    interval: this.config.frequency,
                    autoStart: false
                });
            }

            //auto renders
            this.render($container);
        })
        .on('render', function(){
            $time = $('.time', this.getElement());

            if(this.config.showBeforeStart === true){
                $time.text(timeEncoder.encode(this.remainingTime / precision ));
            }
        })
        .on('warn', function(message, level){
            level = level || 'warning';

            if (this.is('rendered') && this.is('running') &&
                _.isString(message) && !_.isEmpty(message)) {

                $time
                    .removeClass('txt-success txt-info txt-warning txt-danger txt-error')
                    .addClass('txt-' + level);

                if(this.config.displayWarning === true){

                    this.getElement().qtip({
                        show: { ready: true },
                        hide: {
                            event : false,
                            inactive: warningTimeout[level] || 2000
                        },
                        suppress: false,
                        theme : level,
                        content: {
                            text : message
                        },
                        position: {
                            my: 'top center',
                            at: 'bottom center'
                        }
                    });
                }
            }
        });

        countdown.setTemplate(countdownTpl);

        _.defer(function(){
            countdown.init(config);
        });

        return countdown;
    };
});


define('tpl!taoQtiTest/runner/plugins/controls/timer/component/tpl/timerbox', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <a href=\"#\" class=\"timer-toggler hidden\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Hide timers", options) : helperMissing.call(depth0, "__", "Hide timers", options)))
    + "\"><span class=\"icon-clock\"></span></a>\n    ";
  return buffer;
  }

  buffer += "<div class=\"timer-box\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.zenMode)),stack1 == null || stack1 === false ? stack1 : stack1.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"timer-wrapper\">\n\n    </div>\n</div>\n";
  return buffer;
  });
});


define('css!taoQtiTest/runner/plugins/controls/timer/component/css/timerbox',[],function(){});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * The timerbox manages timers and display multiple countdowns.
 *
 * @example
 * timerbox({
 *     timers : [{
 *         id : 'timer1',
 *         label : 'Max test time',
 *         type : 'max',
 *         scope: 'test',
 *         remainingTime: 60000
 *      }, {
 *         id : 'timer2',
 *         label : 'Stay at least',
 *         type : 'min',
 *         scope: 'item',
 *         remainingTime: 15000
 *      }]
 *  })
 *  .on('render', function(){
 *     this.start();
 *  })
 *  .render(document.querySelector('nav'));
 *
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/component/timerbox',[
    'jquery',
    'lodash',
    'i18n',
    'core/promise',
    'ui/component',
    'ui/hider',
    'taoQtiTest/runner/plugins/controls/timer/component/countdown',
    'tpl!taoQtiTest/runner/plugins/controls/timer/component/tpl/timerbox',
    'css!taoQtiTest/runner/plugins/controls/timer/component/css/timerbox.css'
], function ($, _, __, Promise, component, hider, countdownFactory, timerboxTpl) {
    'use strict';

    /**
     * Default config values, see below.
     */
    var defaults = {
        zenMode : {
            enabled : true,
            startHidden : false
        }
    };

    /**
     * Creates and initialize the timerbox component.
     * Please not the component IS NOT rendered.
     * You'll have to render it by yourself.
     *
     * @param {Object} config
     * @param {Boolean} [config.zenMode = true] - zen mode adds a button to hide the countdowns to stay zen
     * @param {Object[]} [config.timers] - the timers to start with
     * @param {Boolean} [config.displayWarning = true] - let the countdown display their warning (contextual)
     * @returns {timerbox} the component, initialized and rendered
     */
    return function timerboxFactory(config){
        var $zenModeToggler;
        var $countdownContainer;

        /**
         * @typedef {Object} timerbox
         */
        var timerbox = component({

            /***
             * Update the displayed timers.
             * Compare the current and the given, it will add,remove and update timers.
             *
             * @param {Object[]} timers - the new timers
             * @returns {Promise<Array>} resolves when all timers are up to date (with the result of all the update operations)
             *
             * @fires timerbox#update the update is done
             */
            update : function update(timers){
                var self = this;

                var updating = [];

                //remove timers
                var timerIdsToRemove =_.difference(_.keys(this.timers), _.keys(timers));
                if(timerIdsToRemove.length){
                    _.forEach(timerIdsToRemove, function(timerId) {
                        updating.push(self.removeTimer(timerId));
                    });
                }

                //add/update
                _.forEach(timers, function(timer, id){
                    if(typeof self.timers[id] === 'undefined'){
                        updating.push(self.addTimer(id, timer));
                    } else {
                        updating.push(self.updateTimer(id, timer));
                    }
                });

                return Promise.all(updating)
                    .then(function(results){

                        //show the toggler only if there's timers
                        if(_.size(self.timers) > 0){
                            hider.show($zenModeToggler);
                        } else {
                            hider.hide($zenModeToggler);
                        }

                        /**
                         * The timer box update is done
                         * @event timerbox#update
                         * @param {Object[]} timers - ALL update results (includes removals)
                         */
                        self.trigger('update', results);

                        return results;
                    });
            },

            /**
             * Get the current timers
             * @return {Object[]} the timers
             */
            getTimers : function getTimers(){
                return this.timers;
            },

            /**
             * Adds a new timer to the box
             * @param {String} id - the timer unique identifier
             * @param {Object} timer - the new timer
             * @return {Promise<Object|Boolean>} resolves with the timer once added or false
             *
             * @fires timerbox#timerchange something changes in a timer
             * @fires timerbox#timeradd a new timer is in the box
             * @fires timerbox#timerstart a timer get started
             * @fires timerbox#timerstop a timer get stopped
             * @fires timerbox#timerend a timer get completed
             * @fires timerbox#change spread from the countdown
             */
            addTimer: function addTimer(id, timer){
                var self = this;

                if (this.is('rendered') && typeof this.timers[id] === 'undefined') {
                    return new Promise(function(resolve){
                        var countdown = countdownFactory($countdownContainer, _.defaults(timer, {
                            displayWarning : self.config.displayWarning
                        }))
                        .on('render', function(){

                            //keep track of the new timer
                            //and the countdown component
                            self.timers[id] = _.clone(timer);
                            self.timers[id].countdown = this;

                            /**
                             * The timers have changed (add, update, remove)
                             * @event timerbox#timerchange
                             * @param {String} action - add, update, remove
                             * @param {Object} timer
                             */
                            self.trigger('timerchange', 'add', self.timers[id]);

                            /**
                             * A new timer is added
                             * @event timerbox#timeradd
                             * @param {Object} timer
                             */
                            self.trigger('timeradd', self.timers[id]);

                            resolve(self.timers[id]);
                        })
                        .on('start', function(){

                            /**
                              * A timer starts
                              * @event timerbox#timerstart
                              * @param {Object} timer
                              */
                            self.trigger('timerstart', self.timers[id]);
                        })
                        .on('stop', function(){

                            /**
                                * A timer stops
                                * @event timerbox#timerstop
                                * @param {Object} timer
                                */
                            self.trigger('timerstop', self.timers[id]);

                        })
                        .on('end', function(){

                            /**
                                * A timer ends
                                * @event timerbox#timerend
                                * @param {Object} timer
                                */
                            self.trigger('timerend', self.timers[id]);

                        })
                        .on('change', function(value){
                            if(self.timers[id]){
                                //keep the current timer data in sync
                                self.timers[id].remainingTime = value;
                            }
                        });
                        countdown.spread(self, ['error', 'change', 'warn']);
                    });
                }
                return Promise.resolve(false);
            },

            /**
             * Updates an existing timer
             * @param {String} id - the timer unique identifier
             * @param {Object} timer - the new timer
             * @return {Promise<Object|Boolean>} resolves with the timer once updated or false
             *
             * @fires timerbox#timerchange something changes in a timer
             * @fires timerbox#timerupdate an existing timer is updated
             */
            updateTimer: function updateTimer(id, timer){

                if (this.is('rendered') && typeof this.timers[id] !== 'undefined') {

                    this.timers[id].remainingTime = timer.remainingTime;
                    this.timers[id].extraTime     = timer.extraTime;

                    if(_.isNumber(timer.remainingWithoutExtraTime)){
                        this.timers[id].remainingWithoutExtraTime = timer.remainingWithoutExtraTime;
                    }

                    if (this.timers[id].countdown){
                        this.timers[id].countdown.update(timer.remainingTime);
                    }

                    this.trigger('timerchange', 'update', this.timers[id]);

                    /**
                     * A timer has been updated with external values
                     * @event timerbox#timerupdate
                     * @param {Object} timer
                     */
                    this.trigger('timerupdate', this.timers[id]);

                    return Promise.resolve(this.timers[id]);
                }
                return Promise.resolve(false);
            },

            /**
             * Remove a timer
             * @param {String} id - the timer unique identifier
             * @return {Promise<Object|Boolean>} resolves with the timer once removed or false
             *
             * @fires timerbox#timerchange something changes in a timer
             * @fires timerbox#timerremove a timer is removed
             */
            removeTimer: function removeTimer(id){

                var self = this;

                if (this.is('rendered') && typeof this.timers[id] !== 'undefined') {
                    return new Promise(function(resolve){

                        /**
                         * Artifact function, remove the timer from the component index
                         */
                        var deindex = function deindex(){
                            //keep a clone, without the component, for the event
                            var removed = _.omit(self.timers[id], 'countdown');

                            //remove the timer from the list
                            self.timers = _.omit(self.timers, id);

                            self.trigger('timerchange', 'remove', removed);

                            /**
                             * A timer has been updated with external values
                             * @event timerbox#timerupdate
                             * @param {Object} timer
                             */
                            self.trigger('timerremove', removed);

                            resolve(removed);
                        };
                        if(self.timers[id].countdown){
                            self.timers[id].countdown
                                .on('destroy', deindex)
                                .destroy();
                        } else {
                            deindex();
                        }
                    });
                }
                return Promise.resolve();
            },

            /**
             * Starts all the timers contained in the box
             * @returns {timerbox} chains
             */
            start : function start(){
                _.forEach(this.timers, function(timer){
                    if(timer.countdown){
                        timer.countdown.start();
                    }
                });
                return this;
            },

            /**
             * Stops all the timers contained in the box
             * @returns {timerbox} chains
             */
            stop : function stop(){
                _.forEach(this.timers, function(timer){
                    if(timer.countdown){
                        timer.countdown.stop();
                    }
                });
                return this;
            },

            /**
             * Show/hide the timers aka "zen mode"
             * @returns {timerbox} chains
             * @fires timerbox#zenchange
             */
            toggleZenMode : function toggleZenMode() {
                if(this.is('rendered') && this.config.zenMode.enabled ){
                    if(this.is('zen')){
                        this.setState('zen', false);
                        $zenModeToggler.attr('title', __('Hide timers'));
                    } else {
                        this.setState('zen', true);
                        $zenModeToggler.attr('title', __('Show timers'));
                    }

                    /**
                     * @event timerbox#zenchange
                     * @param {Boolean} isZen
                     */
                    this.trigger('zenchange', this.is('zen'));
                }
                return this;
            }

        }, defaults)
        .on('init', function(){

            //index the current timers
            this.timers = {};
        })
        .on('render', function(){
            var self = this;
            var $element = this.getElement();

            //where we append the countdowns components
            $countdownContainer = $('.timer-wrapper', $element);

            //set up the zen mode toggler
            if(this.config.zenMode.enabled){
                $zenModeToggler = $('.timer-toggler', $element);
                self.setState('zen', !!self.config.zenMode.startHidden);
                $zenModeToggler.on('click', function(e){
                    e.preventDefault();
                    self.toggleZenMode();
                });
            }

            //if timers are provided with the config, we perform the 1st update
            if(this.config.timers){
                this.update(this.config.timers);
            }
        });

        timerbox.setTemplate(timerboxTpl);

        _.defer(function(){
            timerbox.init(config);
        });

        return timerbox;
    };
});


/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Timer strategy that enforce the test taker to stay in
 * front of the item until the timer completes,
 * by disabling the navigation elements.
 *
 * Applies on item scope, min timers if the testPart is linear
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/strategy/enforcedStay',[], function(){
    'use strict';

    /**
     * Creates the strategy if it applies to the given timer
     * @param {runner} testRunner
     * @param {Object} timer
     * @returns {strategy|Boolean} the strategy if applies or false
     */
    return function enforcedStayStrategy(testRunner, timer){
        var testContext = testRunner.getTestContext();

        if( timer && timer.type === 'min' && timer.scope === 'item' &&
            testContext.isLinear){
            return {
                name : 'enforcedStay',

                /**
                 * setUp entry point : disable the navigation
                 */
                setUp : function setUp(){
                    testRunner.on('enablenav.enforcestay', function(){
                        testRunner.trigger('disablenav');
                    });
                    testRunner.trigger('disablenav');
                },

                /**
                 * complete entry point : enables back the navigation
                 */
                complete : function complete(){
                    this.tearDown();
                    testRunner.trigger('enablenav');
                },

                /**
                 * tearDown entry point : remove the listeners
                 */
                tearDown : function tearDown(){
                    testRunner.off('enablenav.enforcestay');
                }
            };
        }
        return false;
    };
});


/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Track consumed extra time and add it to the next move request
 *
 * Applies when the timer contains an extraTime
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/strategy/extraTime',[
    'lodash'
], function(_){
    'use strict';

    var precision = 1000;
    var lastConsumedExtraTime = 0;

    /**
     * Creates the strategy if it applies to the given timer
     * @param {runner} testRunner
     * @param {Object} timer
     * @returns {strategy|Boolean} the strategy if applies or false
     */
    return function extraTimeStrategy(testRunner, timer){

        /**
         * Apply the extra time to the timer 'once' and
         * listen for test movment to add the consumed extrat time as parameter
         * Since the extra time is global, if multiple timers use the extra time part,
         * we take the biggest consumed extra time.
         */
        var applyExtraTime = function applyExtraTime(){
            if(_.isNumber(timer.extraTime) && timer.extraTime > 0 && !timer.extraTimeSetup){
                timer.extraTimeSetup = true;

                testRunner.before('move.extra skip.extra exit.extra timeout.extra', function() {
                    var consumedExtraTime = 0;
                    var testContext = testRunner.getTestContext();
                    if(timer.remainingTime < timer.extraTime){
                        consumedExtraTime = Math.max(timer.extraTime - timer.remainingTime, 0) / precision;
                        lastConsumedExtraTime = Math.max(
                                consumedExtraTime,
                                lastConsumedExtraTime,
                                testContext.extraTime.consumed
                            );

                        testRunner.getProxy().addCallActionParams({
                            consumedExtraTime: lastConsumedExtraTime
                        });
                    }
                })
                .after('move.extra skip.extra exit.extra timeout.extra', function(){
                    lastConsumedExtraTime = 0;
                });

            }
        };

        if( timer && timer.type === 'max'){
            return {
                name : 'extraTime',

                /**
                 * setUp entry point : adds the extratime to the timer
                 */
                setUp : function setUp(){
                    applyExtraTime();
                },

                /**
                 * setUp entry point : adds the extratime to the timer
                 */
                start : function start(){
                    //apply at start also in case the extra time is added in between
                    applyExtraTime();
                },

                /**
                 * tearDown entry point : remove the listeners
                 */
                tearDown : function tearDown(){
                    testRunner.off('move.extra skip.extra exit.extra timeout.extra');
                }
            };
        }
        return false;
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Timer strategy that enforce the test taker to stay in
 * front of the item until the timer completes,
 * by hidding the navigation elements.
 * Once the timer completes, the test moves to the next item.
 *
 * Applies on item scope, locked timers only, linear test part and
 * the test configuration "guidedNavigation"
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/strategy/guidedNavigation',[], function(){
    'use strict';

    /**
     * Creates the strategy if it applies to the given timer
     * @param {runner} testRunner
     * @param {Object} timer
     * @returns {strategy|Boolean} the strategy if applies or false
     */
    return function guidedNavigationStrategy(testRunner, timer){
        var testData = testRunner.getTestData();
        var testContext = testRunner.getTestContext();
        var config = testData && testData.config ;

        if( timer && timer.type === 'locked' && timer.scope === 'item' &&
            config.guidedNavigation === true && testContext.isLinear === true){

            return {
                name : 'guidedNavigation',

                /**
                 * setUp entry point : hides the navigation
                 */
                setUp : function setUp(){
                    testRunner.trigger('hidenav');
                },

                /**
                 * complete entry point : enables back the navigation
                 */
                complete : function complete(){
                    testRunner.trigger('disableitem disablenav shownav');

                    setTimeout(function(){
                        testRunner.trigger('move', 'next', 'item');
                    }, 500);
                }
            };
        }
        return false;
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Timeout strategy, the given scope is timedout when the timer completes.
 *
 * Applies on all max timers
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/strategy/timeout',[], function(){
    'use strict';

    /**
     * Creates the strategy if it applies to the given timer
     * @param {runner} testRunner
     * @param {Object} timer
     * @returns {strategy|Boolean} the strategy if applies or false
     */
    return function timeoutStrategy(testRunner, timer){

        if(timer && timer.type === 'max'){
            return {
                name : 'timeout',

                /**
                 * complete entry point : timeout
                 */
                complete : function complete(){
                    if(timer.qtiClassName && timer.source){
                        return testRunner.timeout(timer.qtiClassName, timer.source);
                    }
                }
            };
        }
        return false;
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * This helper provides information about the current item
 *
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/helpers/currentItem',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * List of QTI model cardinalities
     * @type {Object}
     */
    var responseCardinalities = {
        single: 'base',
        multiple: 'list',
        ordered: 'list',
        record: 'record'
    };

    /**
     * @typedef {currentItemHelper}
     */
    var currentItemHelper = {
        /**
         * Gets the responses declarations of the current item.
         * @param {Object} runner - testRunner instance
         * @returns {Object}
         */
        getDeclarations: function getDeclarations(runner) {
            var itemRunner = runner.itemRunner;
            return itemRunner._item && itemRunner._item.responses;
        },

        /**
         * Gets a response declaration by the identifier of the response
         * @param {Object} runner - testRunner instance
         * @param {String} identifier - The identifier of the response
         * @returns {Object|null}
         */
        getResponseDeclaration: function getResponseDeclaration(runner, identifier) {
            var found = null;
            _.forEach(currentItemHelper.getDeclarations(runner), function (declaration) {
                var attributes = declaration.attributes || {};
                if (attributes.identifier === identifier) {
                    found = declaration;
                    return false;
                }
            });
            return found;
        },

        /**
         * Convert a value to a response object
         * @param {Array|String} value
         * @param {String} baseType
         * @param {String} cardinality
         * @returns {Object}
         */
        toResponse: function toResponse(value, baseType, cardinality) {
            var mappedCardinality = responseCardinalities[cardinality];
            var response = {};

            if (_.isString(value)) {
                value = [value];
            }

            value = _.map(value || [], function (v) {
                return (baseType === 'boolean') ? (v === true || v === 'true') : v;
            });

            if (mappedCardinality) {
                if (mappedCardinality === 'base') {
                    if (value.length === 0) {
                        //return empty response:
                        response.base = null;
                    } else {
                        response.base = {};
                        response.base[baseType] = value[0];
                    }
                } else {
                    response[mappedCardinality] = {};
                    response[mappedCardinality][baseType] = value;
                }
            }

            return response;
        },

        /**
         * Checks if the provided value can be considered as null
         * @param {Object} value
         * @param {String} baseType
         * @param {String} cardinality
         * @returns {boolean}
         */
        isQtiValueNull: function isQtiValueNull(value, baseType, cardinality) {
            var mappedCardinality = responseCardinalities[cardinality];

            if (_.isObject(value) && value[mappedCardinality] === null) {
                value = null;
            }

            if (_.isObject(value) && value[mappedCardinality] && 'undefined' !== typeof value[mappedCardinality][baseType]) {
                value = value[mappedCardinality][baseType];
            }

            return null === value || ('string' === baseType && _.isEmpty(value)) || (cardinality !== 'single' && _.isEmpty(value));
        },

        /**
         * Tells if an item question has been answered or not
         * @param response
         * @param baseType
         * @param cardinality
         * @param [defaultValue]
         * @returns {*}
         */
        isQuestionAnswered: function isQuestionAnswered(response, baseType, cardinality, defaultValue) {
            var answered;
            defaultValue = defaultValue || null;
            if (currentItemHelper.isQtiValueNull(response, baseType, cardinality)) {
                answered = false;
            } else {
                answered = !_.isEqual(response, currentItemHelper.toResponse(defaultValue, baseType, cardinality));
            }
            return answered;
        },

        /**
         * Tells is the current item has been answered or not
         * The item is considered answered when at least one response has been set to not empty {base : null}
         * @param {Object} runner - testRunner instance
         * @param {Boolean} [partially = true] - if false all questions must have been answered
         * @returns {Boolean}
         */
        isAnswered: function isAnswered(runner, partially) {
            var itemRunner = runner.itemRunner;
            var responses = itemRunner && itemRunner.getResponses();
            var count = 0;
            var empty = 0;

            if (itemRunner) {
                _.forEach(currentItemHelper.getDeclarations(runner), function (declaration) {
                    var attributes = declaration.attributes || {};
                    var response = responses[attributes.identifier];
                    var baseType = attributes.baseType;
                    var cardinality = attributes.cardinality;

                    count++;
                    if (!currentItemHelper.isQuestionAnswered(response, baseType, cardinality, declaration.defaultValue)) {
                        empty++;
                    }
                });
            }
            if( partially === false ){
                return count > 0 && empty === 0;
            }
            return count > 0 && empty < count;
        }
    };

    return currentItemHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * This helper provides more statistics about the test
 *
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/helpers/stats',[
    'lodash',
    'taoQtiTest/runner/helpers/map',
    'taoQtiTest/runner/helpers/currentItem'
], function (_, mapHelper, currentItemHelper) {
    'use strict';

    /**
     * Return scope stats that takes into account any test taker interaction made since the item has been loaded
     * @param {String} scope - scope to consider for calculating the stats
     * @param {Object} runner - testRunner instance
     * @param {Boolean} sync - flag for sync the unanswered stats in exit message and the unanswered stats in the toolbox. Default false
     * @returns {Object}
     */
    function getInstantStats(scope, runner, sync) {
        var map = runner.getTestMap(),
            context = runner.getTestContext(),
            stats = _.clone(mapHelper.getScopeStats(map, context.itemPosition, scope)),
            item = mapHelper.getItemAt(map, context.itemPosition),
            isItemCurrentlyAnswered;

        if (!item.informational) {
            isItemCurrentlyAnswered = currentItemHelper.isAnswered(runner);
            if (!isItemCurrentlyAnswered && context.itemAnswered) {
                stats.answered--;
            } else if ((isItemCurrentlyAnswered || sync) && !context.itemAnswered) {
                stats.answered++;
            } else if (sync && !isItemCurrentlyAnswered && context.itemAnswered && context.isLinear) {
                stats.answered++;
            }
        }

        return stats;
    }

    return {
        getInstantStats: getInstantStats
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/helpers/messages',[
    'lodash',
    'i18n',
    'taoQtiTest/runner/helpers/map',
    'taoQtiTest/runner/helpers/stats'
], function (_, __, mapHelper, statsHelper) {
    'use strict';

    /**
     * Completes an exit message
     * @param {String} message - custom message that will be appended to the unanswered stats count
     * @param {String} scope - scope to consider for calculating the stats
     * @param {Object} runner - testRunner instance
     * @param {Boolean} sync - flag for sync the unanswered stats in exit message and the unanswered stats in the toolbox
     * @returns {String} Returns the message text
     */
    function getExitMessage(message, scope, runner, sync) {
        var itemsCountMessage = '';

        var testData = runner.getTestData(),
            testConfig = testData && testData.config,
            messageEnabled = testConfig ? testConfig.enableUnansweredItemsWarning : true;
        
        if (messageEnabled) {
            itemsCountMessage = getUnansweredItemsWarning(scope, runner, sync);
        }

        return (itemsCountMessage + " " + message).trim();
    }

    /**
     * Build message if not all items have answers
     * @param {String} scope - scope to consider for calculating the stats
     * @param {Object} runner - testRunner instance
     * @param {Boolean} sync - flag for sync the unanswered stats in exit message and the unanswered stats in the toolbox. Default false
     * @returns {String} Returns the message text
     */
    function getUnansweredItemsWarning(scope, runner, sync) {
        var stats = statsHelper.getInstantStats(scope, runner, sync);
        var unansweredCount = stats && (stats.questions - stats.answered);
        var flaggedCount = stats && stats.flagged;
        var itemsCountMessage = '';

        if (scope === 'section' || scope === 'testSection'){
            if (unansweredCount === 0) {
                itemsCountMessage = __('You answered all %s question(s) in this section', stats.questions.toString());
            } else {
                itemsCountMessage = __('You answered only %s of the %s question(s) in this section',
                    stats.answered.toString(),
                    stats.questions.toString()
                );
            }
            if (flaggedCount) {
                itemsCountMessage += ', ' + __('and flagged %s of them', flaggedCount.toString());
            }
        } else if(scope === 'test') {
            if (unansweredCount === 0) {
                itemsCountMessage = __('You answered all %s question(s) in this test', stats.questions.toString());
            } else {
                itemsCountMessage = __('You have %s unanswered question(s)', unansweredCount.toString());
            }
            if (flaggedCount) {
                itemsCountMessage += ' ' + __('and you flagged %s item(s) that you can review now', flaggedCount.toString());
            }
        } else if(scope === 'part') {
            if (unansweredCount === 0) {
                itemsCountMessage = __('You answered all %s question(s)', stats.questions.toString());
            } else {
                itemsCountMessage = __('You have %s unanswered question(s)', unansweredCount.toString());
            }
            if (flaggedCount) {
                itemsCountMessage += ' ' + __('and you flagged %s item(s) that you can review now', flaggedCount.toString());
            }
        }

        if (itemsCountMessage) {
            itemsCountMessage += '.';
        }
        return itemsCountMessage;
    }

    return {
        getExitMessage: getExitMessage
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * This helper provides information about the test navigation
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/helpers/navigation',[
    'lodash',
    'taoQtiTest/runner/helpers/map'
], function (_, mapHelper) {
    'use strict';

    /**
     * @typedef {Object} navigationHelper
     */
    var navigationHelper = {

        /**
         * Check whether the test taker is leaving a section
         *
         * @param {Object} testContext - the actual test context
         * @param {String} testContext.itemIdentifier - the id of the current item
         * @param {String} testContext.sectionId - the id of the current section
         * @param {Object} testMap - the actual test map
         * @param {String} direction - the move direction (next, previous or jump)
         * @param {String} scope - the move scope (item, section, testPart)
         * @param {Number} [position] - the position in case of jump
         * @returns {Boolean} true if the action leads to a section leave
         * @throws {TypeError} if the context or the map are incorrect
         */
        isLeavingSection : function isLeavingSection(testContext, testMap, direction, scope, position){
            var section;
            var sectionStats;
            var nbItems;
            var item;
            if( _.isPlainObject(testContext) && _.isPlainObject(testMap) &&
                !_.isEmpty(testContext.sectionId) && !_.isEmpty(testContext.itemIdentifier) ){

                section = mapHelper.getSection(testMap, testContext.sectionId);
                sectionStats = mapHelper.getSectionStats(testMap, testContext.sectionId);
                nbItems = sectionStats && sectionStats.total;
                item = mapHelper.getItem(testMap, testContext.itemIdentifier);

                return  scope === 'section' ||
                        scope === 'testPart'||
                        (direction === 'next' && item.positionInSection + 1 === nbItems) ||
                    (direction === 'previous' && item.positionInSection === 0) ||
                    (direction === 'jump' && position > 0 && (position < section.position || position >= section.position + nbItems));
            }
            throw new TypeError('Invalid test context and test map');
        },

        /**
         * Check whether the test taker is leaving a test part
         *
         * @param {Object} testContext - the actual test context
         * @param {String} testContext.itemIdentifier - the id of the current item
         * @param {String} testContext.sectionId - the id of the current section
         * @param {String} testContext.testPartId - the id of the current testPart
         * @param {Object} testMap - the actual test map
         * @param {String} direction - the move direction (next, previous or jump)
         * @param {String} scope - the move scope (item, section, testPart)
         * @param {Number} [position] - the position in case of jump
         * @returns {Boolean} true if the action leads to a section leave
         * @throws {TypeError} if the context or the map are incorrect
         */
        isLeavingTestPart : function isLeavingTestPart(testContext, testMap, direction, scope, position){
            var testPart;
            var testPartStats;
            var nbItems;
            var item;
            var section;
            var sectionStats;
            if( _.isPlainObject(testContext) && _.isPlainObject(testMap) &&
               !_.isEmpty(testContext.testPartId) && !_.isEmpty(testContext.sectionId) && !_.isEmpty(testContext.itemIdentifier) ){

                testPart      = mapHelper.getPart(testMap, testContext.testPartId);
                testPartStats = mapHelper.getPartStats(testMap, testContext.testPartId);
                nbItems       = testPartStats && testPartStats.total;
                item          = mapHelper.getItem(testMap, testContext.itemIdentifier);

                if(scope === 'section'){
                    section = mapHelper.getSection(testMap, testContext.sectionId);
                    sectionStats = mapHelper.getSectionStats(testMap, testContext.sectionId);
                }

                return  scope === 'testPart'||
                        (direction === 'next' && scope === 'item' && item.positionInPart + 1 === nbItems) ||
                        (direction === 'next' && scope === 'section' && section.position + sectionStats.total >= nbItems) ||
                        (direction === 'previous' && scope === 'item' && item.positionInPart === 0) ||
                        (direction === 'previous' && scope === 'section' && section.position === testPart.position) ||
                        (direction === 'jump' && position > 0 && (position < testPart.position || position >=  testPart.position + nbItems));
            }
            throw new TypeError('Invalid test context and test map');
        },

        /**
         * Check if the given  item is the last of the test
         * @param {Object} testMap - the test map
         * @param {String} itemIdentifier - the identifier of the item
         * @returns {Boolean} true if the item is the last one
         */
        isLast : function isLast(testMap, itemIdentifier){
            return this.isLastOf(testMap, itemIdentifier, 'test');
        },

        /**
         * Check if the given  item is the first of a test
         * @param {Object} testMap - the test map
         * @param {String} itemIdentifier - the identifier of the item
         * @returns {Boolean} true if the item is the first one
         */
        isFirst : function isFirst(testMap, itemIdentifier){
            return this.isFirstOf(testMap, itemIdentifier, 'test');
        },

        /**
         * Check if the given  item is the last of a the given scope
         * @param {Object} testMap - the test map
         * @param {String} itemIdentifier - the identifier of the item
         * @param {String} [scope = 'test'] - the target scope
         * @returns {Boolean} true if the item is the last one
         */
        isLastOf : function isLastOf(testMap, itemIdentifier, scope){
            var item;
            var stats;
            if ( ! _.isPlainObject(testMap) ) {
                throw new TypeError('Invalid test map');
            }
            if (_.isEmpty(itemIdentifier)) {
                throw new TypeError('Invalid item identifier');
            }
            scope = scope || 'test';
            item  = mapHelper.getItem(testMap, itemIdentifier);
            stats = mapHelper.getScopeStats(testMap, item.position, scope);
            if (stats && _.isNumber(stats.total)) {
                if (scope === 'test') {
                    return item.position + 1  === stats.total;
                }
                if (scope === 'section' || scope === 'assessmentSection' || scope === 'testSection') {
                    return item.positionInSection + 1 === stats.total;
                }
                if (scope === 'part' || scope === 'testPart') {
                    return item.positionInPart + 1 === stats.total;
                }
            }

            return false;
        },

        /**
         * Check if the given  item is the first of a the given scope
         * @param {Object} testMap - the test map
         * @param {String} itemIdentifier - the identifier of the item
         * @param {String} [scope = 'test'] - the target scope
         * @returns {Boolean} true if the item is the first one
         */
        isFirstOf : function isFirstOf(testMap, itemIdentifier, scope){
            var item;
            if (! _.isPlainObject(testMap)) {
                throw new TypeError('Invalid test map');
            }
            if (_.isEmpty(itemIdentifier)) {
                throw new TypeError('Invalid item identifier');
            }
            scope = scope || 'test';
            item  = mapHelper.getItem(testMap, itemIdentifier);

            if (scope === 'test') {
                return item.position  === 0;
            }
            if (scope === 'section' || scope === 'assessmentSection' || scope === 'testSection') {
                return item.positionInSection === 0;
            }
            if (scope === 'part' || scope === 'testPart') {
                return item.positionInPart === 0;
            }

            return false;
        },

        /**
         * Gets the map descriptors of the sibling items
         * @param {Object} testMap
         * @param {Number|String} itemPosition - (could be also the item id)
         * @param {String} [direction='both'] - previous/next/both
         * @param {Number} [size=3] - will be 2xsize if direction is both
         * @returns {Object[]} the collections of items
         */
        getSiblingItems: function getSiblingItems(testMap, itemPosition, direction, size) {
            var itemId = mapHelper.getItemIdentifier(testMap,  itemPosition);
            var previous = null;
            var siblings = [];
            var directions;

            var itemChain = _.reduce(testMap && testMap.jumps, function (map, jump) {
                var ref = jump.identifier;
                if (previous) {
                    map[previous].next = ref;
                }
                map[ref] = {
                    identifier: ref,
                    previous: previous,
                    next: null
                };
                previous = ref;
                return map;
            }, {});

            size = _.isFinite(size) ? parseInt(size, 10) : 3;
            if (!direction || direction === 'both') {
                directions = ['previous', 'next'];
            } else {
                directions = [direction];
            }

            _.forEach(directions, function walkDirection(link) {
                var id = itemId;
                _.times(size, function getNeighbor() {
                    id = itemChain[id] && itemChain[id][link];
                    if (id) {
                        siblings.push(mapHelper.getItem(testMap, id));
                    } else {
                        return false;
                    }
                });
            });

            return siblings;
        },


        /**
         * Gets the map descriptor of the next item
         * @param {Object} testMap
         * @param {Number|String} itemPosition - (could be also the item id)
         * @returns {Object}
         */
        getNextItem : function getNextItem(testMap, itemPosition) {
            var siblings = navigationHelper.getSiblingItems(testMap, itemPosition, 'next', 1);
            if (siblings.length) {
                return siblings[0];
            }
            return null;
        },

        /**
         * Gets the map descriptor of the previous item
         * @param {Object} testMap
         * @param {Number|String} itemPosition - (could be also the item id)
         * @returns {Object}
         */
        getPreviousItem : function getPreviousItem(testMap, itemPosition) {
            var siblings = navigationHelper.getSiblingItems(testMap, itemPosition, 'previous', 1);
            if (siblings.length) {
                return siblings[0];
            }
            return null;
        },

        /**
         * Checks if an action will move forward.
         * @param {String} action - the name of the action that will be performed
         * @param {Object} [params] - some optional parameters that apply to the action
         * @returns {Boolean}
         */
        isMovingToNextItem : function isMovingToNextItem(action, params) {
            params = params || {};
            return (
                action === 'timeout' ||
                action === 'skip' ||
                (action === 'move' && params.direction === 'next' && params.scope === 'item')
            );
        },

        /**
         * Checks if an action will move backward.
         * @param {String} action - the name of the action that will be performed
         * @param {Object} [params] - some optional parameters that apply to the action
         * @returns {Boolean}
         */
        isMovingToPreviousItem : function isMovingToPreviousItem(action, params) {
            params = params || {};
            return (
                action === 'move' && params.direction === 'previous' && params.scope === 'item'
            );
        },

        /**
         * Checks if an action will jump on another item.
         * @param {String} action - the name of the action that will be performed
         * @param {Object} [params] - some optional parameters that apply to the action
         * @returns {Boolean}
         */
        isJumpingToItem : function isJumpingToItem(action, params) {
            params = params || {};
            return (
                action === 'move' && params.direction === 'jump' && params.scope === 'item'
            );
        }

    };

    return navigationHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Timer strategy that warns the user when he leaves a timed section
 *
 * Applies on section scope, max timers.
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/strategy/warnSectionLeaving',[
    'lodash',
    'i18n',
    'core/promise',
    'taoQtiTest/runner/helpers/messages',
    'taoQtiTest/runner/helpers/navigation'
], function(_, __, Promise, messages, navigationHelper){
    'use strict';

    /**
     * The message to display when exiting
     */
    var exitMessage = __('Once you close this section, you cannot return to it or change your answers.');

    /**
     * Creates the strategy if it applies to the given timer
     * @param {runner} testRunner
     * @param {Object} timer
     * @returns {strategy|Boolean} the strategy if applies or false
     */
    return function warnSectionLeavingStrategy(testRunner, timer){

        /**
        * Check if the movment leads to leaving an active timed section
        * @param {String} direction - the move direction (next, previous or jump)
        * @param {String} scope - the move scope (item, section, testPart)
        * @param {Number} [position] - the position in case of jump
        * @returns {Boolean}
        */
        var leaveTimedSection = function leaveTimedSection(direction, scope, position) {
            var context = testRunner.getTestContext();
            var map = testRunner.getTestMap();
            var testData = testRunner.getTestData();
            if (!context.isTimeout && context.itemSessionState !== testData.itemStates.closed && context.sectionId === timer.source) {
                return navigationHelper.isLeavingSection(context, map, direction, scope, position);
            }
            return false;
        };

        if(timer && timer.scope === 'section' && timer.type === 'max'){
            return {
                name : 'warnSectionLeaving',

                /**
                 * setUp entry point : blocks the move to display a message if needed
                 */
                setUp : function setUp(){
                    testRunner
                        .off('move.warntimedsection skip.warntimedsection')
                        .before('move.warntimedsection skip.warntimedsection', function(e, type, scope, position){

                            var context = testRunner.getTestContext();
                            var testDataBeforeMove = testRunner.getTestData();
                            var config = testDataBeforeMove && testDataBeforeMove.config;
                            var timerConfig = config && config.timer || {};
                            var options = context && context.options || {};
                            var movePromise = new Promise(function(resolve, reject) {
                                // endTestWarning has already been displayed, so we don't repeat the warning
                                if (context.isLast && options.endTestWarning) {
                                    resolve();
                                    // display a message if we exit a timed section
                                } else if (leaveTimedSection(type || 'next', scope, position) && !options.noExitTimedSectionWarning && !timerConfig.keepUpToTimeout) {
                                    testRunner.trigger(
                                        'confirm.exittimed',
                                        messages.getExitMessage(exitMessage, 'section', testRunner),
                                        resolve,
                                        reject,
                                        {
                                            buttons: {
                                                labels: {
                                                    ok : __('Close this Section'),
                                                    cancel : __('Review my Answers')
                                                }
                                            }
                                        });
                                } else {
                                    resolve();
                                }
                            });

                            movePromise
                                .catch(function cancelMove() {
                                    // Use `defer` to be sure the timer resume will occur after the move event is
                                    // finished to be handled. Otherwise, the duration plugin will be frozen and
                                    // the additional time will not be taken into account!
                                    _.defer(function() {
                                        testRunner.trigger('enableitem enablenav');
                                    });
                                });

                            return movePromise;
                        });
                },

                /**
                 * complete entry point : removes the listeners
                 */
                complete : function complete(){
                    return this.tearDown();
                },

                /**
                 * tearDown entry point : removes the listeners
                 */
                tearDown : function tearDown(){
                    testRunner.off('move.warntimedsection skip.warntimedsection');
                }
            };
        }
        return false;
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * This module loads all timers' strategies,
 * activate them by timer when relevant,
 * then apply the behavior based on the lifecycle.
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/strategy/strategyHandler',[
    'lodash',
    'core/promise',
    'taoQtiTest/runner/plugins/controls/timer/strategy/enforcedStay',
    'taoQtiTest/runner/plugins/controls/timer/strategy/extraTime',
    'taoQtiTest/runner/plugins/controls/timer/strategy/guidedNavigation',
    'taoQtiTest/runner/plugins/controls/timer/strategy/timeout',
    'taoQtiTest/runner/plugins/controls/timer/strategy/warnSectionLeaving',
], function(_, Promise, extraTimeStrategy, enforcedStayStrategy, guidedNavigationStrategy, timeoutStrategy, warnSectionLeavingStrategy){
    'use strict';


    /**
     * The list of available strategies
     * TODO this list could come from the configuration
     */
    var defaultAvailableStrategies = [
        extraTimeStrategy,
        enforcedStayStrategy,
        guidedNavigationStrategy,
        timeoutStrategy,
        warnSectionLeavingStrategy
    ];

    /**
     * Get a strategyHandler object for a testRunner instance
     * @param {runner} testRunner - the test runner instance
     * @param {strategy[]} strategies - the list of available strategies, to override the defaults
     * @returns {strategyHandler} the handler
     */
    return function getStrategyHandler(testRunner, strategies){
        var strategyHandler;

        /**
         * To keep track of the active strategies, per timer
         */
        var actives = {};

        /**
         * Artifact function to apply an action to a list of strategy
         * @param {String} timerId - the id of the timer to run the actions against
         * @param {String} action -
         */
        var applyToStrategies = function applyToStrategies(timerId, action){
            var api = _.keys(strategyHandler);
            if(_.isEmpty(timerId) || _.isEmpty(action) || !_.contains(api, action)){
                throw new TypeError('Invalid timer id or unauthorized action');
            }

            if(!_.isArray(actives[timerId])){
                return Promise.resolve();
            }
            return  Promise.all( _.map( actives[timerId], function(strategy){
                if (_.isFunction(strategy[action])) {
                    return strategy[action]();
                }
            }));
        };

        var availableStrategies = strategies || defaultAvailableStrategies;

        //quick validation of the test runner
        if(!testRunner || !_.isFunction(testRunner.on) || !_.isFunction(testRunner.getTestContext)){
            throw new TypeError('The strategy handler needs a valid test runner.');
        }

        /**
         * @typedef {Object} strategyHandler
         */
        strategyHandler = {

            /**
             * Try to set up strategies for the given timer
             * @param {Object} timer
             * @returns {Promise} resolves once the set up is done
             */
            setUp : function setUp (timer) {
                _.forEach(availableStrategies, function(availableStrategy){
                    var strategy = availableStrategy(testRunner, timer);
                    if(strategy !== false){
                        actives[timer.id] = actives[timer.id] || [];

                        actives[timer.id].push(strategy);
                    }
                });
                return applyToStrategies(timer.id, 'setUp');
            },

            /**
             * Get the actives strategies for the given timer
             * @returns {strategy[]} the actives strategies
             */
            getActives : function getActives(timer){
                if(timer && timer.id && _.isArray(actives[timer.id])){
                    return actives[timer.id];
                }
                return [];
            },

            /**
             * Call the timer's strategies "start"
             * @param {Object} timer
             * @returns {Promise}
             */
            start: function start(timer){
                return applyToStrategies(timer.id, 'start');
            },

            /**
             * Call the timer's strategies "stop"
             * @param {Object} timer
             * @returns {Promise}
             */
            stop : function stop(timer){
                return applyToStrategies(timer.id, 'stop');
            },

            /**
             * Call the timer's strategies "complete"
             * @param {Object} timer
             * @returns {Promise}
             */
            complete : function complete(timer){
                return applyToStrategies(timer.id, 'complete');
            },

            /**
             * Call the timer's strategies "tearDown"
             * will also un-reference the strategies
             * @param {Object} timer
             * @returns {Promise}
             */
            tearDown : function tearDown(timer){
                return applyToStrategies(timer.id, 'tearDown').then(function(){
                    actives = _.omit(actives, timer.id);
                });
            }
        };

        return strategyHandler;
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Get timers from timeConstraints and test configuration.
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/timers',[
    'lodash',
    'i18n',
    'moment',
    'core/format',
    'core/logger'
], function(_, __, moment, format, loggerFactory){
    'use strict';

    var logger = loggerFactory('taoQtiTest/runner/plugins/controls/timer/timers');

    /**
     * We receive values in seconds, so we convert them to milliseconds
     */
    var precision = 1000;

    /**
     * The timer's scope
     */
    var scopes = ['item', 'section', 'testPart', 'test'];

    /**
     * Map qti class names to scopes
     */
    var scopeMapping = {
        assessmentTest    : 'test',
        assessmentSection : 'section',
        assessmentItemRef : 'item'
    };

    /**
     * helps you get the scope from a scope or qti class name
     * @param {String} value - scope or qti class name
     * @returns {String?} the scope
     */
    var getScope = function getScope(value){
        if(scopeMapping[value]){
            return scopeMapping[value];
        }
        if(_.contains(scopes, value)){
            return value;
        }
        return null;
    };

    /**
     * The text of warning messages
     * TODO add warning messages for other timers types
     */
    var warningMessages = {
        item    : __("Warning – You have %s remaining to complete this item."),
        section : __("Warning – You have %s remaining to complete this section."),
        testPart: __("Warning – You have %s remaining to complete this test part."),
        test    : __("Warning – You have %s remaining to complete this test.")
    };


    /**
     * Get the timers objects from the time constraints andt the given config
     * @param {Object[]} timeConstraints - as defined in the testContext
     * @param {Boolean} isLinear - is the current navigation mode linear
     * @param {Object} [config] - timers config
     * @param {Object[]} [config.warnings] - the warnings to apply to the timers (max only for now)
     * @param {Object[]} [config.warnings] - the warnings to apply to the timers (max only for now)
     * @returns {timer[]} the timers
     */
    return function getTimers(timeConstraints, isLinear, config){
        var timers = {};

        /**
         * The warnings comes in a weird format (ie. {scope:{threshold:level}}) , so we reformat them
         */
        var constraintsWarnings = _.reduce(config.warnings, function(acc, warnings, qtiScope){
            var scope = getScope(qtiScope);
            acc[scope] = _.map(warnings, function(value, key){
                return {
                    threshold : (parseInt(key, 10) * precision),
                    message : function applyMessage(remainingTime){
                        var displayRemaining = moment.duration(remainingTime / precision, "seconds").humanize();
                        return format(warningMessages[scope], displayRemaining);
                    },
                    level : value,
                    shown : false
                };
            });
            return acc;
        }, {});

        /**
         * Build a timer of a given type from a time constraints
         * @param {String} type - min, max, locked
         * @param {Object} constraintData
         * @returns {timer} timer
         */
        var buildTimer = function buildTimer(type, constraintData){

            /**
             * @typedef {Object} timer
             * @property {String} id - identify the timer (for max, it's the source for backward compat)
             * @property {String} type - min, max or locked
             * @property {String} label - the title to display
             * @property {String} scope - the timer's scope (item, section, etc.)
             * @property {String} qtiClassName - the QTI class of the timers applies to
             * @property {String} source - the ID of the element the timers belongs to
             * @property {Number} extraTime - additional time, in ms
             * @property {Number} originalTime - the starting value of the timer, never changes, in ms.
             * @property {Number} remainingTime - current value, in ms.
             */
            var timer  = _.pick(constraintData, ['label', 'scope', 'source', 'extraTime', 'qtiClassName']);

            timer.type = type;

            //to stay backward comaptible, the "max" timers ids are just the source
            if(type === 'max'){
                timer.id  = constraintData.source;
            } else {
                timer.id  = type + '-' + constraintData.scope + '-' + constraintData.source;
            }
            if(type === 'min'){
                timer.originalTime  = constraintData.minTime * precision;
                timer.remainingTime = constraintData.minTimeRemaining * precision;
            } else {
                timer.originalTime  = constraintData.maxTime * precision;
                timer.remainingTime = constraintData.maxTimeRemaining * precision;
            }
            if(timer.extraTime > 0){
                timer.extraTime = timer.extraTime * precision;
            }

            //TODO supports warnings for other types
            if (type === 'max' && _.isArray(constraintsWarnings[timer.scope])) {
                timer.warnings = constraintsWarnings[timer.scope];
            }
            return timer;
        };


        _.forEach(timeConstraints, function(timeConstraint){
            var constraintData = _.clone(timeConstraint);
            var newTimer;

            constraintData.scope = getScope(timeConstraint.scope || timeConstraint.qtiClassName);

            if(!constraintData.scope){

                logger.warning('Wrong data, a time constraint should apply to a valid scope, skipping');

            } else if(constraintData.minTime === false && constraintData.maxTime === false){

                logger.warning('Time constraint defined with no time, skipping');

            // minTime = maxTime -> one locked timer
            } else if ( config.guidedNavigation && isLinear &&
                    constraintData.maxTime && constraintData.minTime &&
                    constraintData.minTime === constraintData.maxTime &&
                    constraintData.maxTime > 0){

                newTimer =  buildTimer('locked', constraintData);
                timers[newTimer.id] = newTimer;

            } else {

                //minTime -> min timer
                if(isLinear && constraintData.minTime  && constraintData.minTime > 0){

                    newTimer = buildTimer('min', constraintData);
                    timers[newTimer.id] = newTimer;
                }

                //maxTime -> max timer
                if(constraintData.maxTime  && constraintData.maxTime > 0){

                    newTimer = buildTimer('max', constraintData);
                    timers[newTimer.id] = newTimer;
                }
            }
        });

        logger.debug('Timers built from timeConstraints', timers);

        return timers;
    };

});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2018 (original work) Open Assessment Technologies SA ;
 */

/**
 * Main timer plugin.
 * Since the test can have multiples timers (per context)
 * with different behaviors, this plugin takes care of :
 *  - loading the timeConstraints data from the testContext and create timers objects
 *  - save/load data from the browser store
 *  - delegates the rendering to the timerbox component. The timerbox handles the display of multiple countdowns.
 *  - apply strategies to the timers. Each strategy can install it's own behavior on a timer.
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/timer/plugin',[
    'jquery',
    'lodash',
    'core/promise',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/plugins/controls/timer/strategy/strategyHandler',
    'taoQtiTest/runner/plugins/controls/timer/component/timerbox',
    'taoQtiTest/runner/plugins/controls/timer/timers'
], function($, _, Promise, pluginFactory, getStrategyHandler, timerboxFactory, timersFactory){
    'use strict';

    /**
     * Creates the plugin
     */
    return pluginFactory({

        name: 'timer',

        /**
         * Install step, add behavior before the lifecycle
         */
        install: function install() {

            /**
             * Load the timers, from the given timeConstraints and reading the current value in the store
             * @param {store} timeStore - where the values are read
             * @param {Object[]} timeConstraints - the timeConstraints as given by the testContext
             * @param {Boolean} isLinear - the timeConstraints as given by the testContext
             * @param {Object} config - the current config, especially for the warnings
             * @return {Promise<Object[]>} the list of timers for the current context
             */
            this.loadTimers = function loadTimers(timeStore, timeConstraints, isLinear,  config){
                var timers = timersFactory(timeConstraints, isLinear, config);
                return Promise.all(
                    _.map(timers, function(timer){
                        return timeStore.getItem(timer.id).then(function(savedTime){

                            //apply the remainingTime from the store
                            if (_.isNumber(savedTime) && savedTime >= 0) {
                                timer.remainingTime = savedTime;
                            }
                            //apply the extraTime
                            if(_.isNumber(timer.extraTime) && timer.extraTime > 0){
                                timer.remainingWithoutExtraTime = timer.remainingTime;
                                timer.remainingTime = timer.remainingTime + timer.extraTime;
                            }
                        });
                    })
                )
                .then(function(){
                    return timers;
                });
            };

            /**
             * Save timer values into the store
             * @param {store} timeStore - where the values are saved
             * @param {Object[]} timers - the timers to save
             * @return {Promise} resolves once saved
             */
            this.saveTimers = function saveTimers(timeStore, timers){
                return Promise.all(
                    _.map(timers, function(timer){

                        //if extra time, we always save the original value
                        if(_.isNumber(timer.extraTime) && timer.extraTime > 0 && timer.remainingWithoutExtraTime){
                            timer.remainingWithoutExtraTime = Math.max(0, timer.remainingTime - timer.extraTime);
                            return timeStore.setItem(timer.id, timer.remainingWithoutExtraTime);
                        }

                        return timeStore.setItem(timer.id, timer.remainingTime);
                    })
                );
            };

            //define the "timer" store as "volatile" (removed on browser change).
            this.getTestRunner().getTestStore().setVolatile(this.getName());
        },

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var self         = this;
            var testRunner   = this.getTestRunner();
            var testData     = testRunner.getTestData();

            /**
             * Plugin config,
             */
            var config       = _.merge({}, this.getConfig(), {

                /**
                 * An option to control is the warnings are contextual or global
                 */
                contextualWarnings : false,

                /**
                 * The list of configured warnings
                 */
                warnings : testData && testData.config && testData.config.timerWarning || {},

                /**
                 * The guided navigation option
                 */
                guidedNavigation : testData && testData.config && testData.config.guidedNavigation
            });

            /**
             * Set up the strategy handler
             */
            var strategyHandler = getStrategyHandler(testRunner);

            /**
             * dispatch errors to the test runner
             * @param {Error} err - to dispatch
             */
            var handleError = function handleError(err){
                testRunner.trigger('error', err);
            };

            return new Promise(function(resolve){
                //load the plugin store
                return testRunner.getPluginStore(self.getName()).then(function(timeStore){

                    testRunner
                        .before('renderitem resumeitem', function() {
                            var testContext = testRunner.getTestContext();
                            //update the timers before each item
                            if(self.timerbox && testContext.timeConstraints){
                                return self.loadTimers(timeStore, testContext.timeConstraints, !!testContext.isLinear, config)
                                    .then(function(timers){
                                        return self.timerbox.update(timers);
                                    })
                                    .catch(handleError);
                            }
                        })
                        .on('enableitem renderitem', function(){
                            if(self.timerbox){
                                self.timerbox.start();
                            }
                        })
                        .on('disableitem move skip', function(){
                            if(self.timerbox){
                                //this will "pause" the countdowns
                                self.timerbox.stop();
                            }
                        });

                    timeStore.getItem('zen-mode').then(function(startZen){

                        //set up the timerbox
                        self.timerbox = timerboxFactory({
                            zenMode: {
                                enabled : true,
                                startHidden : !!startZen
                            },
                            displayWarning : config.contextualWarnings
                        })
                        .on('change', _.throttle(function(){
                            //update the store with the current timer values
                            self.saveTimers(timeStore, this.getTimers());
                        }, 1000))
                        .on('timeradd', function(timer){
                            strategyHandler.setUp(timer).catch(handleError);
                        })
                        .on('timerremove', function(timer){
                            strategyHandler.tearDown(timer).catch(handleError);
                        })
                        .on('timerstart', function(timer){
                            strategyHandler.start(timer).catch(handleError);
                        })
                        .on('timerstop', function(timer){
                            strategyHandler.stop(timer).catch(handleError);
                        })
                        .on('timerend', function(timer){
                            strategyHandler.complete(timer).catch(handleError);
                        })
                        .on('timerchange', function(action, timer){
                            //backward compatible events
                            self.trigger(action + 'timer', timer.qtiClassName, timer);
                        })
                        .on('zenchange', function(isZen){
                            timeStore.setItem('zen-mode', !!isZen);
                        })
                        .on('init', resolve)
                        .on('error', handleError);

                        if(!config.contextualWarnings){
                            self.timerbox.on('warn', function(message, level){
                                if(level && message){
                                    testRunner.trigger(level, message);
                                }
                            });
                        }
                    })
                    .catch(handleError);
                });
            });
        },

        /**
         * Called during the runner's render phase
         */
        render: function render() {
            this.timerbox.render(
                this.getAreaBroker().getControlArea()
            );
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            if(this.timerbox){
                this.timerbox
                    .stop()
                    .destroy();
            }
        },

        /**
         * Shows the timers
         */
        show: function show() {
            if(this.timerbox){
                this.timerbox.show();
            }
        },

        /**
         * Hides the timers
         */
        hide: function hide() {
            if(this.timerbox){
                this.timerbox.hide();
            }
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/controls/title/title', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <span data-control=\"";
  if (helper = helpers.control) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.control); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"qti-controls\" title=\"";
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  stack1 = helpers.unless.call(depth0, (data == null || data === false ? data : data.first), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return " - ";
  }

  buffer += "<div class=\"title-box truncate\">\n    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.titles), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Control Plugin : Title
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/title/title',[
    'jquery',
    'i18n',
    'taoTests/runner/plugin',
    'tpl!taoQtiTest/runner/plugins/controls/title/title'
], function ($, __, pluginFactory, titleTpl){
    'use strict';

    return pluginFactory({
        name : 'title',
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();
            var testData   = testRunner.getTestData();

            var createElement = function(){

                var context  = testRunner.getTestContext();
                var titles =  [{
                    control : 'qti-test-title',
                    text    : testData.title
                }];
               if(context.isDeepestSectionVisible){
                    titles.push({
                        control : 'qti-test-position',  //WTF !? isn't it the section title... ?
                        text    : context.sectionTitle
                    });
                }

                return $(titleTpl({ titles : titles }));
            };

            this.$element = createElement();


            testRunner
                .after('renderitem', function(){
                    var $element = createElement();
                    self.$element.replaceWith($element);
                    self.$element = $element;
                });

        },
        render : function render(){
            var $container = this.getAreaBroker().getControlArea();
            $container.append(this.$element);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * Test Runner Control Plugin : Item Trace Variables
 *
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/runner/plugins/controls/trace/itemTraceVariables',[
    'lodash',
    'moment',
    'taoTests/runner/plugin'
], function (_, moment, pluginFactory) {
    'use strict';

    /**
     * Duration of a second in the timer's base unit
     * @type {Number}
     */
    var precision = 1000;

    /**
     * Gets the current timestamp
     * @returns {Number}
     */
    function timestamp() {
        return Date.now() / precision;
    }

    /**
     * Creates the timer plugin
     */
    return pluginFactory({

        name: 'itemTraceVariables',

        /**
         * Install step, add behavior before the lifecycle.
         */
        install: function install() {
            //define the "trace" store as "volatile" (removed on browser change).
            // the store name is "trace" for backward compatibility,
            // best practice is to use the plugin name
            this.getTestRunner().getTestStore().setVolatile('trace');
        },

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var testRunner = this.getTestRunner();
            var variables = {};

            function onError(err) {
                testRunner.trigger('error', err);
            }

            return testRunner.getPluginStore('trace')
                .then(function (tracesStore) {
                    testRunner
                        .after('renderitem enableitem', function () {
                            var context = testRunner.getTestContext();

                            variables = {
                                ITEM_START_TIME_CLIENT: timestamp()
                            };

                            tracesStore.getItem(context.itemIdentifier)
                                .then(function (data) {
                                    if (data) {
                                        _.merge(variables, data);
                                    }

                                    return tracesStore.setItem(context.itemIdentifier, variables);
                                })
                                .catch(onError);
                        })

                        .before('move skip exit timeout', function () {
                            var context = testRunner.getTestContext();

                            variables.ITEM_END_TIME_CLIENT = timestamp();
                            variables.ITEM_TIMEZONE = moment().utcOffset(moment().utcOffset()).format('Z');

                            return tracesStore.setItem(context.itemIdentifier, variables).catch(onError);
                        })

                        .before('unloaditem', function () {
                            var context = testRunner.getTestContext();
                            return testRunner.getProxy().callItemAction(context.itemIdentifier, 'storeTraceData', {
                                traceData: JSON.stringify(variables)
                            }, true);
                        });
                });
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */

/**
 * http://www.imsglobal.org/question/qtiv2p2p1/QTIv2p2p1-ASI-InformationModelv1p0/imsqtiv2p2p1_asi_v1p0_InfoModelv1p0.html#DerivedCharacteristic_ItemSessionControl.Attr_allowSkipping
 *
 * An item is defined to be skipped if the candidate has not provided any
 * response. In other words, all response variables are submitted with their
 * default value or are NULL. This definition is consistent with the
 * numberResponded operator available in outcomeProcessing. If 'false',
 * candidates are not allowed to skip the item, or in other words, they are not
 * allowed to submit the item until they have provided a non-default value for
 * at least one of the response variables. By definition, an item with no
 * response variables cannot be skipped. The value of this attribute is only
 * applicable when the item is in a testPart with individual submission mode.
 * Note that if allowSkipping is 'true' delivery engines must ensure that the
 * candidate can choose to submit no response, for example, through the
 * provision of a "skip" button.
 */

define('taoQtiTest/runner/plugins/navigation/allowSkipping',[
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/helpers/currentItem'
], function(_, __, pluginFactory, currentItemHelper) {
    'use strict';

    /**
     * Default plugin options
     * @type {Object}
     */
    var defaults = {
        allowPartial: true // whether all interactions must be answered to count an item as answered
    };

    /**
     * Plugin factory
     * @returns {Object}
     */
    return pluginFactory({

        /**
         * Plugin name
         * @type {String}
         */
        name: 'allowSkipping',

        /**
         * Initialize plugin (called during runner's initialization)
         * @returns {this}
         */
        init: function init() {
            this.getTestRunner().before('move', function () {
                var self          = this;
                var testContext   = this.getTestContext();
                var isInteracting = !this.getItemState(testContext.itemIdentifier, 'disabled');
                var testData      = this.getTestData() || {};
                var testConfig    = testData.config || {};
                var pluginsConfig = testConfig.plugins || {};
                var config        = _.defaults(pluginsConfig.allowSkipping || {}, defaults);
                var warning       = config.allowPartial
                    ? __('A response to every question in this item is required.')
                    : __('A response to this item is required.');

                if ( isInteracting && testContext.enableAllowSkipping && !testContext.allowSkipping ) {

                    return new Promise(function (resolve, reject) {
                        if(_.size(currentItemHelper.getDeclarations(self)) === 0){
                            return resolve();
                        }
                        if (currentItemHelper.isAnswered(self, config.allowPartial)) {
                            return resolve();
                        }

                        if (!self.getState('alerted.notallowed')) { // Only show one alert for itemSessionControl

                            self.setState('alerted.notallowed', true);
                            self.trigger(
                                'alert.notallowed',
                                warning,
                                function () {
                                    self.trigger('resumeitem');
                                    reject();
                                    self.setState('alerted.notallowed', false);
                                }
                            );
                        }
                    });
                }
            });
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * This is a helper for navigation plugins. It decides if a warning should be displayed
 * before actually moving to the next item
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/navigation/next/nextWarningHelper',[], function () {
    'use strict';

    /**
     * Convert a value to a boolean
     * @param {*} value
     * @param {Boolean} defaultValue
     * @returns {Boolean}
     */
    var toBoolean = function toBoolean(value, defaultValue) {
        if (typeof(value) === "undefined") {
            return defaultValue;
        } else {
            return (value === true || value === "true");
        }
    };

    /**
     * @param {Object} options
     * @param {Boolean} options.endTestWarning - enables the end test warning, when applicable
     * @param {Boolean} options.isLast - if the item is the last of the test
     * @param {Boolean} options.isLinear - if the current part is linear
     * @param {Boolean} options.nextItemWarning - enables the next item warning, when applicable
     * @param {Boolean} options.nextPartWarning - enables the next item warning on part change
     * @param {Boolean} options.stats - current state of the test
     * @param {Object} options.nextPart - description of the next part of the test
     * @param {Number} options.remainingAttempts - remaining attempts for the current item
     * @param {String} options.testPartId - current test part identifier
     * @param {Boolean} options.unansweredOnly - warn only if there are unanswered/flagged items
     * @returns {Object}
     */
    var nextWarningHelper = function nextWarningHelper(options) {
        var endTestWarning      = toBoolean(options.endTestWarning, false),
            isLast              = toBoolean(options.isLast, false),
            isLinear            = toBoolean(options.isLinear, false),
            nextItemWarning     = toBoolean(options.nextItemWarning, false),
            nextPartWarning     = toBoolean(options.nextPartWarning, false),
            stats               = options.stats,
            nextPart            = options.nextPart || {},
            remainingAttempts   = typeof(options.remainingAttempts) === 'undefined' ? -1 : options.remainingAttempts,
            testPartId          = options.testPartId || '',
            unansweredOnly      = toBoolean(options.unansweredOnly, false),

            warnBeforeNext = shouldWarnBeforeNext(),
            warnBeforeEnd = shouldWarnBeforeEnd();

        /**
         * Decide if we should display a warning before moving to the next item.
         * This is useful to prevent accidental navigation (for example by pressing a shortcut) that would occur
         * before the test taker actually gets a chance to answer an item
         */
        function shouldWarnBeforeNext() {
            return nextItemWarning
                && !itemCanBeTriedAtWill();
                //&& !exitTimedSectionWarning(); //todo: this should be implemented to prevent a double warning!
        }

        /**
         * We try to decide if the test taker has the freedom to come back to this item as many times as he wants
         */
        function itemCanBeTriedAtWill() {
            return (
                isLast === false                // the test is not over
                && isLinear === false           // the context is not linear
                && remainingAttempts === -1     // the item doesn't have a configured max attempts number
                && !isNextItemInLinearPart()    // the next item is not in a linear part
            );
        }

        /**
         * Check if the next item is in a linear part, as this would prevent the test taker to come back to the current item
         */
        function isNextItemInLinearPart() {
            return nextPart && typeof nextPart.isLinear !== 'undefined'
                && isLastOfPart()
                && nextPart.isLinear === true;
        }

        /**
         * Decide if we should display a warning before ending the test
         */
        function shouldWarnBeforeEnd() {
            return shouldWarnOnTestEnd()
                || shouldWarnOnPartChange();
        }

        /**
         * Are we on the last test item?
         * @returns {Boolean}
         */
        function shouldWarnOnTestEnd() {
            return isLast
                && (
                    endTestWarning                      // warning is explicitly required by endTestWarning category
                    || warnBeforeNext                   // warning is implicitly triggered by the next item warning being true (prevent double warning)
                )
                && shouldWarnForUnansweredItems();
        }

        /**
         * Provide the opportunity to cancel the display of the warning if there are no unanswered/flagged item
         * for this to work, the unansweredOnly option has to be set
         * @returns {Boolean}
         */
        function shouldWarnForUnansweredItems() {
            var hasUnanswered = stats && ((stats.questions - stats.answered) !== 0),
                hasFlagged = stats && stats.flagged !== 0;

            if (unansweredOnly) {
                return (hasUnanswered || hasFlagged);
            } else {
                return true;
            }
        }

        /**
         * Are we on the last part item?
         * @returns {Boolean}
         */
        function shouldWarnOnPartChange() {
            return nextPartWarning
                && isLastOfPart()
                && shouldWarnForUnansweredItems();
        }

        /**
         * Check if the next item belong to a different part
         * @returns {Boolean}
         */
        function isLastOfPart() {
            return nextPart && nextPart.id
                && testPartId !== nextPart.id;
        }

        /**
         * The helper object
         */
        return {
            shouldWarnBeforeEnd: function () {
                return warnBeforeEnd;
            },
            shouldWarnBeforeNext: function () {
                return warnBeforeNext;
            }
        };
    };

    return nextWarningHelper;

});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Navigation Plugin : Next
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/navigation/next',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/plugins/navigation/next/nextWarningHelper',
    'taoQtiTest/runner/helpers/messages',
    'taoQtiTest/runner/helpers/map',
    'taoQtiTest/runner/helpers/stats',
    'util/shortcut',
    'util/namespace',
    'tpl!taoQtiTest/runner/plugins/templates/button'
], function ($, _, __, hider, pluginFactory, nextWarningHelper, messages, mapHelper, statsHelper, shortcut, namespaceHelper, buttonTpl){
    'use strict';

    /**
     * The display of the next button
     */
    var buttonData = {
        next : {
            control : 'move-forward',
            title   : __('Submit and go to the next item'),
            icon    : 'forward',
            text    : __('Next')
        },
        end : {
            control : 'move-end',
            title   : __('Submit and go to the end of the test'),
            icon    : 'fast-forward',
            text    : __('End test')
        }
    };

    /**
     * Create the button based on the current context
     * @param {Object} context - the test context
     * @returns {jQueryElement} the button
     */
    var createElement = function createElement(context){
        var dataType = context.isLast ? 'end' : 'next';
        return $(buttonTpl(buttonData[dataType]));
    };

    /**
     * Update the button based on the context
     * @param {jQueryElement} $element - the element to update
     * @param {Object} context - the test context
     */
    var updateElement = function updateElement($element, context){
        var dataType = context.isLast ? 'end' : 'next';
        if($element.attr('data-control') !== buttonData[dataType].control){

            $element.attr('data-control', buttonData[dataType].control)
                    .attr('title', buttonData[dataType].title)
                    .find('.text').text(buttonData[dataType].text);

            if(dataType === 'next'){
                $element.find('.icon-' + buttonData.end.icon)
                        .removeClass('icon-' + buttonData.end.icon)
                        .addClass('icon-' + buttonData.next.icon);
            } else {
                $element.find('.icon-' + buttonData.next.icon)
                        .removeClass('icon-' + buttonData.next.icon)
                        .addClass('icon-' + buttonData.end.icon);
            }
        }
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({
        name : 'next',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData();
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};

            //plugin behavior
            /**
             * @param {Boolean} nextItemWarning - enable the display of a warning when going to the next item.
             * Note: the actual display of the warning depends on other conditions (see nextWarningHelper)
             */
            function doNext(nextItemWarning) {
                var context = testRunner.getTestContext(),
                    testOptions = context.options || {};

                var map = testRunner.getTestMap();
                var nextItemPosition = context.itemPosition + 1;

                // x-tao-option-unansweredWarning is a deprecated option whose behavior now matches the one of
                // x-tao-option-nextPartWarning with the unansweredOnly option
                var nextPartWarning = testOptions.nextPartWarning || testOptions.unansweredWarning;
                var unansweredOnly =
                    !testOptions.endTestWarning // this check to avoid an edge case where having both endTestWarning
                                                // and unansweredWarning options would prevent endTestWarning to behave normally
                    && testOptions.unansweredWarning;

                var warningScope = (nextPartWarning) ? 'part' : 'test';

                var warningHelper = nextWarningHelper({
                    endTestWarning:     testOptions.endTestWarning,
                    isLast:             context.isLast,
                    isLinear:           context.isLinear,
                    nextItemWarning:    nextItemWarning,
                    nextPartWarning:    nextPartWarning,
                    nextPart:           mapHelper.getItemPart(map, nextItemPosition),
                    remainingAttempts:  context.remainingAttempts,
                    testPartId:         context.testPartId,
                    unansweredWarning:  testOptions.unansweredWarning,
                    stats:              statsHelper.getInstantStats(warningScope, testRunner),
                    unansweredOnly:     unansweredOnly
                });

                function enableNav() {
                    testRunner.trigger('enablenav');
                }

                testRunner.trigger('disablenav');

                if(self.getState('enabled') !== false) {

                    if (warningHelper.shouldWarnBeforeEnd()) {
                        testRunner.trigger(
                            'confirm.endTest',
                            messages.getExitMessage(
                                __('You are about to submit the test. You will not be able to access this test once submitted. Click OK to continue and submit the test.'),
                                warningScope, testRunner),
                            _.partial(triggerNextAction, context), // if the test taker accept
                            enableNav                              // if he refuse
                        );

                    } else if (warningHelper.shouldWarnBeforeNext()) {
                        testRunner.trigger(
                            'confirm.next',
                            __('You are about to go to the next item. Click OK to continue and go to the next item.'),
                            _.partial(triggerNextAction, context), // if the test taker accept
                            enableNav                              // if he refuse
                        );

                    } else {
                        triggerNextAction(context);
                    }
                }
            }

            function triggerNextAction(context) {
                if(context.isLast){
                    self.trigger('end');
                }
                testRunner.next();
            }

            //create the button (detached)
            this.$element = createElement(testRunner.getTestContext());

            //attach behavior
            this.$element.on('click', function(e){
                e.preventDefault();
                testRunner.trigger('nav-next');
            });

            if(testConfig.allowShortcuts && pluginShortcuts.trigger){
                shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.trigger, this.getName(), true), function(e) {
                    if (self.getState('enabled') === true) {
                        testRunner.trigger('nav-next', true);
                    }
                }, {
                    avoidInput: true,
                    prevent: true
                });
            }

            //disabled by default
            this.disable();

            //change plugin state
            testRunner
                .on('loaditem', function(){
                    updateElement(self.$element, testRunner.getTestContext());
                })
                .on('enablenav', function(){
                    self.enable();
                })
                .on('disablenav', function(){
                    self.disable();
                })
                .on('hidenav', function(){
                    self.hide();
                })
                .on('shownav', function(){
                    self.show();
                })
                .on('nav-next', function(nextItemWarning) {
                    doNext(nextItemWarning);
                });
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){

            //attach the element to the navigation area
            var $container = this.getAreaBroker().getNavigationArea();
            $container.append(this.$element);
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            shortcut.remove('.' + this.getName());
            this.$element.remove();
        },

        /**
         * Enable the button
         */
        enable : function enable (){
            this.$element.removeProp('disabled')
                         .removeClass('disabled');
        },

        /**
         * Disable the button
         */
        disable : function disable (){
            this.$element.prop('disabled', true)
                         .addClass('disabled');
        },

        /**
         * Show the button
         */
        show: function show(){
            hider.show(this.$element);
        },

        /**
         * Hide the button
         */
        hide: function hide(){
            hider.hide(this.$element);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Navigation Plugin : Next Section
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/navigation/nextSection',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/helpers/messages',
    'tpl!taoQtiTest/runner/plugins/templates/button'
], function ($, _, __, hider, pluginFactory, messages, buttonTpl){
    'use strict';

    return pluginFactory({
        name : 'nextsection',
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();
            var testConfig = testRunner.getTestData().config;

            function toggle(){
                var options = testRunner.getTestContext().options;
                if(testConfig.nextSection && (options.nextSection || options.nextSectionWarning)){
                    self.show();
                } else {
                    self.hide();
                }
            }

            function nextSection() {
                testRunner.next('section');
            }

            this.$element = $(buttonTpl({
                control : 'next-section',
                title   : __('Skip to the next section'),
                icon    : 'fast-forward',
                text    : __('Next Section')
            }));

            this.$element.on('click', function(e){
                var context = testRunner.getTestContext();
                var enable = _.bind(self.enable, self);
                e.preventDefault();
                if(self.getState('enabled') !== false){
                    self.disable();

                    if(context.options.nextSectionWarning){
                        testRunner.trigger(
                            'confirm.nextsection',
                            messages.getExitMessage(
                                __('Once you close this section, you cannot return to it or change your answers.'),
                                'section', testRunner),
                            nextSection, // if the test taker accept
                            enable,      // if the test taker refuse
                            {
                                buttons: {
                                    labels: {
                                        ok: __('Close this Section'),
                                        cancel:  __('Review my Answers')
                                    }
                                }
                            }
                        );
                    } else {
                        nextSection();
                    }
                }
            });

            this.disable();
            toggle();

            testRunner
                .on('loaditem', toggle)
                .on('enablenav', function(){
                    self.enable();
                })
                .on('disablenav', function(){
                    self.disable();
                })
                .on('hidenav', function(){
                    self.hide();
                })
                .on('shownav', function(){
                    self.show();
                });
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){

            //attach the element to the navigation area
            var $container = this.getAreaBroker().getNavigationArea();
            $container.append(this.$element);
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            this.$element.remove();
        },

        /**
         * Enable the button
         */
        enable : function enable (){
            this.$element.removeProp('disabled')
                         .removeClass('disabled');
        },

        /**
         * Disable the button
         */
        disable : function disable (){
            this.$element.prop('disabled', true)
                         .addClass('disabled');
        },

        /**
         * Show the button
         */
        show: function show(){
            hider.show(this.$element);
        },

        /**
         * Hide the button
         */
        hide: function hide(){
            hider.hide(this.$element);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Navigation Plugin : Previous
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/navigation/previous',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'taoTests/runner/plugin',
    'util/shortcut',
    'util/namespace',
    'taoQtiTest/runner/helpers/navigation',
    'taoQtiTest/runner/helpers/map',
    'tpl!taoQtiTest/runner/plugins/templates/button'
], function ($, _, __, hider, pluginFactory, shortcut, namespaceHelper, navigationHelper, mapHelper, buttonTpl){
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name : 'previous',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;

            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData();
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};

            /**
             * Check if the "Previous" functionality should be available or not
             */
            var canDoPrevious = function canDoPrevious() {
                var testMap = testRunner.getTestMap();
                var context = testRunner.getTestContext();
                var previousSection;
                var previousPart;

                // check TestMap if empty
                if( _.isPlainObject(testMap) && _.size(testMap) === 0){
                    return false;
                }

                //first item of the test
                if (navigationHelper.isFirst(testMap, context.itemIdentifier)) {
                    return false;
                }

                //first item of a section
                if (navigationHelper.isFirstOf(testMap, context.itemIdentifier, 'section')) {

                    //when entering an adaptive section,
                    //you can't leave the section from the beginning
                    if(context.isCatAdaptive){
                        return false;
                    }

                    //if the previous section is adaptive or a timed section
                    previousSection = mapHelper.getItemSection(testMap, context.itemPosition - 1);
                    if(previousSection.isCatAdaptive || (previousSection.timeConstraint && !context.options.noExitTimedSectionWarning) ){
                        return false;
                    }
                }

                if (navigationHelper.isFirstOf(testMap, context.itemIdentifier, 'part')) {

                    //if the previous part is linear, we don't enter it too
                    previousPart = mapHelper.getItemPart(testMap, context.itemPosition - 1);
                    if(previousPart.isLinear){
                        return false;
                    }

                }
                return context.isLinear === false && context.canMoveBackward === true;
            };

            /**
             * Hide the plugin if the Previous functionality shouldn't be available
             */
            var toggle = function toggle(){
                if(canDoPrevious()){
                    self.show();
                } else {
                    self.hide();
                }
            };

            //build element (detached)
            this.$element =  $(buttonTpl({
                control : 'move-backward',
                title   : __('Submit and go to the previous item'),
                icon    : 'backward',
                text    : __('Previous')
            }));

            //attach behavior
            function doPrevious(previousItemWarning) {
                var context = testRunner.getTestContext();

                function enableNav() {
                    testRunner.trigger('disablenav');
                }

                testRunner.trigger('disablenav');

                if(self.getState('enabled') !== false){
                    if (previousItemWarning && context.remainingAttempts !== -1) {
                        testRunner.trigger(
                            'confirm.previous',
                            __('You are about to go to the previous item. Click OK to continue and go to the previous item.'),
                            testRunner.previous, // if the test taker accept
                            enableNav()          // if he refuses
                        );

                    } else {
                        testRunner.previous();
                    }
                }
            }

            this.$element.on('click', function(e){
                e.preventDefault();
                testRunner.trigger('nav-previous');
            });

            if(testConfig.allowShortcuts && pluginShortcuts.trigger){
                shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.trigger, this.getName(), true), function() {
                    if (canDoPrevious() && self.getState('enabled') === true) {
                        testRunner.trigger('nav-previous', [true]);
                    }
                }, {
                    avoidInput: true,
                    prevent: true
                });
            }

            //start disabled
            toggle();
            self.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', toggle)
                .on('enablenav', function(){
                    self.enable();
                })
                .on('disablenav', function(){
                    self.disable();
                })
                .on('hidenav', function(){
                    self.hide();
                })
                .on('shownav', function(){
                    self.show();
                })
                .on('nav-previous', function(previousItemWarning){
                    doPrevious(previousItemWarning);
                });
        },


        /**
         * Called during the runner's render phase
         */
        render : function render(){
            var $container = this.getAreaBroker().getNavigationArea();
            $container.append(this.$element);
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            shortcut.remove('.' + this.getName());
            this.$element.remove();
        },

        /**
         * Enable the button
         */
        enable : function enable (){
            this.$element.removeProp('disabled')
                         .removeClass('disabled');
        },

        /**
         * Disable the button
         */
        disable : function disable (){
            this.$element.prop('disabled', true)
                         .addClass('disabled');
        },

        /**
         * Show the button
         */
        show: function show(){
            hider.show(this.$element);
        },

        /**
         * Hide the button
         */
        hide: function hide(){
            hider.hide(this.$element);
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/navigation/review/navigator', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return " hidden";
  }

function program3(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <div class=\"qti-navigator-info collapsible\">\n                <span class=\"qti-navigator-label\">\n                    <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Test status", options) : helperMissing.call(depth0, "__", "Test status", options)))
    + "</span>\n                    <span class=\"icon-up\"></span>\n                    <span class=\"icon-down\"></span>\n                </span>\n        <ul class=\"collapsible-panel plain\">\n            <li class=\"qti-navigator-viewed\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Viewed items", options) : helperMissing.call(depth0, "__", "Viewed items", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-viewed\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Viewed", options) : helperMissing.call(depth0, "__", "Viewed", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n            </li>\n            <li class=\"qti-navigator-answered\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Completed items", options) : helperMissing.call(depth0, "__", "Completed items", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-answered\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Answered", options) : helperMissing.call(depth0, "__", "Answered", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n            </li>\n            <li class=\"qti-navigator-unanswered\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Unanswered items", options) : helperMissing.call(depth0, "__", "Unanswered items", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-unanswered\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Unanswered", options) : helperMissing.call(depth0, "__", "Unanswered", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n            </li>\n            <li class=\"qti-navigator-flagged\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Items marked for later review", options) : helperMissing.call(depth0, "__", "Items marked for later review", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-flagged\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Flagged", options) : helperMissing.call(depth0, "__", "Flagged", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n            </li>\n        </ul>\n    </div>\n    ";
  return buffer;
  }

function program5(depth0,data) {
  
  
  return "(<span class=\"qti-navigator-counter\">0</span>)";
  }

function program7(depth0,data) {
  
  
  return "icon-unanswered ";
  }

function program9(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Unanswered", options) : helperMissing.call(depth0, "__", "Unanswered", options)))
    + " (<span class=\"qti-navigator-counter\">0</span>)";
  return buffer;
  }

function program11(depth0,data) {
  
  
  return "icon-flagged ";
  }

function program13(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Flagged", options) : helperMissing.call(depth0, "__", "Flagged", options)))
    + " (<span class=\"qti-navigator-counter\">0</span>)";
  return buffer;
  }

  buffer += "<div class=\"qti-panel qti-navigator";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hidden), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n    <div class=\"qti-navigator-collapsible\">\n        <span class=\"qti-navigator-collapse icon icon-left\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Collapse the review panel", options) : helperMissing.call(depth0, "__", "Collapse the review panel", options)))
    + "\"></span>\n        <span class=\"qti-navigator-expand icon icon-right\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Expand the review panel", options) : helperMissing.call(depth0, "__", "Expand the review panel", options)))
    + "\"></span>\n    </div>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.showLegend), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n\n    <div class=\"qti-navigator-filters\">\n        <ul class=\"plain clearfix\">\n            <li class=\"qti-navigator-filter active\" data-mode=\"all\">\n                <span title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Reset filters", options) : helperMissing.call(depth0, "__", "Reset filters", options)))
    + "\" class=\"qti-navigator-tab\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "All", options) : helperMissing.call(depth0, "__", "All", options)))
    + "\n                    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.showLegend), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                </span>\n            </li>\n\n            <li class=\"qti-navigator-filter\" data-mode=\"unanswered\">\n                <span class=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.showLegend), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "qti-navigator-tab\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Only display the unanswered items", options) : helperMissing.call(depth0, "__", "Only display the unanswered items", options)))
    + "\">\n                    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.showLegend), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                </span>\n            </li>\n\n            <li class=\"qti-navigator-filter\" data-mode=\"flagged\">\n                <span class=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.showLegend), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "qti-navigator-tab\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Only display the items marked for review", options) : helperMissing.call(depth0, "__", "Only display the items marked for review", options)))
    + "\">\n                    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.showLegend), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                </span>\n            </li>\n        </ul>\n    </div>\n\n    <nav class=\"qti-navigator-tree\"></nav>\n\n    <div id=\"qti-navigator-linear\" class=\"qti-navigator-linear\">\n        <span class=\"icon icon-info\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\"></span>\n        <p class=\"qti-navigator-message\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\n        </p>\n    </div>\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/runner/plugins/navigation/review/navigatorTree', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <li class=\"qti-navigator-part collapsible ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.active), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        <span class=\"qti-navigator-label\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <span class=\"qti-navigator-text\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n            <span class=\"icon-up\"></span>\n            <span class=\"icon-down\"></span>\n        </span>\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isLinear), {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </li>\n    ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "active";
  }

function program4(depth0,data) {
  
  
  return "collapsed";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <div class=\"qti-navigator-linear-part collapsible-panel\">\n            <span class=\"icon icon-info\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\"></span>\n            <p class=\"qti-navigator-message\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\n            </p>\n            <p class=\"qti-navigator-actions\">\n                <button class=\"btn-info small\" data-position=\"";
  if (helper = helpers.position) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.position); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Start Test-part", options) : helperMissing.call(depth0, "__", "Start Test-part", options)))
    + "\">\n                    <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Start Test-part", options) : helperMissing.call(depth0, "__", "Start Test-part", options)))
    + "</span>\n                    <span class=\"icon-play r\"></span>\n                </button>\n            </p>\n        </div>\n        ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        <ul class=\"qti-navigator-sections collapsible-panel plain\">\n            ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.sections), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </ul>\n        ";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n            <li class=\"qti-navigator-section collapsible ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.active), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                <span class=\"qti-navigator-label\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                    <span class=\"qti-navigator-text\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n                    <span class=\"qti-navigator-counter\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.stats)),stack1 == null || stack1 === false ? stack1 : stack1.answered)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "/"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.stats)),stack1 == null || stack1 === false ? stack1 : stack1.total)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span>\n                </span>\n                <ul class=\"qti-navigator-items collapsible-panel plain\">\n                    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.items), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                </ul>\n            </li>\n            ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                    <li class=\"qti-navigator-item ";
  if (helper = helpers.cls) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.cls); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-position=\"";
  if (helper = helpers.position) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.position); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                        <span class=\"qti-navigator-label truncate\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                            <span class=\"qti-navigator-icon icon-";
  if (helper = helpers.icon) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.icon); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></span>\n                            <span class=\"qti-navigator-number\">";
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n                            ";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n                        </span>\n                    </li>\n                    ";
  return buffer;
  }

  buffer += "<ul class=\"qti-navigator-parts plain\">\n    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.parts), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</ul>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/navigation/review/navigator',[
    'jquery',
    'lodash',
    'i18n',
    'ui/component',
    'ui/autoscroll',
    'taoQtiTest/runner/helpers/map',
    'tpl!taoQtiTest/runner/plugins/navigation/review/navigator',
    'tpl!taoQtiTest/runner/plugins/navigation/review/navigatorTree'
], function ($, _, __, component, autoscroll, mapHelper, navigatorTpl, navigatorTreeTpl) {
    'use strict';

    /**
     * Some default values
     * @type {Object}
     * @private
     */
    var _defaults = {
        scope: 'test',
        canCollapse: false,
        preventsUnseen: true,
        hidden: false
    };

    /**
     * List of CSS classes
     * @type {Object}
     * @private
     */
    var _cssCls = {
        active: 'active',
        collapsed: 'collapsed',
        collapsible: 'collapsible',
        hidden: 'hidden',
        disabled: 'disabled',
        flagged: 'flagged',
        answered: 'answered',
        viewed: 'viewed',
        unseen: 'unseen',
        info: 'info',
        icon: 'qti-navigator-icon',
        scope: {
            test: 'scope-test',
            testPart: 'scope-test-part',
            testSection: 'scope-test-section'
        }
    };

    /**
     * List of icon CSS classes
     * @type {Array}
     * @private
     */
    var _iconCls = [
        _cssCls.info,
        _cssCls.flagged,
        _cssCls.answered,
        _cssCls.viewed
    ];

    /**
     * List of common CSS selectors
     * @type {Object}
     * @private
     */
    var _selectors = {
        component: '.qti-navigator',
        filterBar: '.qti-navigator-filters',
        filter: '.qti-navigator-filter',
        tree: '.qti-navigator-tree',
        collapseHandle: '.qti-navigator-collapsible',
        linearState: '.qti-navigator-linear',
        infoAnswered: '.qti-navigator-answered .qti-navigator-counter',
        infoViewed: '.qti-navigator-viewed .qti-navigator-counter',
        infoUnanswered: '.qti-navigator-unanswered .qti-navigator-counter',
        infoFlagged: '.qti-navigator-flagged .qti-navigator-counter',
        infoPanel: '.qti-navigator-info',
        infoPanelLabels: '.qti-navigator-info > .qti-navigator-label',
        tabInfoAll: '[data-mode="all"] .qti-navigator-counter',
        tabInfoUnanswered: '[data-mode="unanswered"] .qti-navigator-counter',
        tabInfoFlagged: '[data-mode="flagged"] .qti-navigator-counter',
        parts: '.qti-navigator-part',
        partLabels: '.qti-navigator-part > .qti-navigator-label',
        sections: '.qti-navigator-section',
        sectionLabels: '.qti-navigator-section > .qti-navigator-label',
        items: '.qti-navigator-item',
        itemLabels: '.qti-navigator-item > .qti-navigator-label',
        itemIcons: '.qti-navigator-item > .qti-navigator-icon',
        activeItem: '.qti-navigator-item.active',
        icons: '.qti-navigator-icon',
        linearStart: '.qti-navigator-linear-part button',
        counters: '.qti-navigator-counter',
        actives: '.active',
        collapsible: '.collapsible',
        collapsiblePanels: '.collapsible-panel',
        unseen: '.unseen',
        answered: '.answered',
        flagged: '.flagged',
        notFlagged: ':not(.flagged)',
        notAnswered: ':not(.answered)',
        notInformational: ':not(.info)',
        informational: '.info',
        hidden: '.hidden',
        disabled : '.disabled'
    };

    /**
     * Maps the filter mode to filter criteria.
     * Each filter criteria is a CSS selector used to find and mask the items to be discarded by the filter.
     * @type {Object}
     * @private
     */
    var _filterMap = {
        all: "",
        unanswered: [_selectors.answered, _selectors.informational].join(','),
        flagged: _selectors.notFlagged,
        answered: _selectors.notAnswered,
        filtered: _selectors.hidden
    };

    /**
     *
     * @type {Object}
     */
    var navigatorApi = {
        /**
         * Updates the stats on the flagged items in the current map
         * @param {Number} position
         * @param {Boolean} flag
         */
        updateStats: function updateStats(position, flag) {
            var map = this.map;
            var item;

            if (map) {
                item = mapHelper.getItemAt(map, position);

                if (item) {
                    item.flagged = flag;
                    mapHelper.updateItemStats(map, position);
                }
            }
        },

        /**
         * Gets the total number of items for the provided target
         * @param {Object} progression
         * @param {String} target
         * @returns {Number}
         */
        getProgressionTotal: function getProgressionTotal(progression, target) {
            var total;

            if ('questions' === target) {
                total = progression.questions;
            } else {
                total = progression.total;
            }

            return total;
        },

        /**
         * Set the marked state of an item
         * @param {Number|String|jQuery} position
         * @param {Boolean} flag
         */
        setItemFlag: function setItemFlag(position, flag) {
            var $item = position && position.jquery ? position : this.controls.$tree.find('[data-position=' + position + ']');
            var progression = this.progression;
            var icon;

            // update the map stats
            this.updateStats(position, flag);

            // update the item flag
            $item.toggleClass(_cssCls.flagged, flag);

            // set the item icon according to its state
            icon = _.find(_iconCls, _.bind($item.hasClass, $item)) || _cssCls.unseen;
            $item.find(_selectors.icons).attr('class', _cssCls.icon + ' icon-' + icon);

            // update the info panel
            progression.flagged = this.controls.$tree.find(_selectors.flagged).length;
            this.writeCount(this.controls.$infoFlagged, progression.flagged, this.getProgressionTotal(progression, 'questions'));

            // recompute the filters
            this.filter(this.currentFilter);
        },

        /**
         * Filters the items by a criteria
         * @param {String} criteria
         */
        filter: function filter(criteria) {
            var self = this;

            // remove the current filter by restoring all items
            var $items = this.controls.$tree.find(_selectors.items).removeClass(_cssCls.hidden);

            // filter the items according to the provided criteria
            var filterCb = _filterMap[criteria];
            if (filterCb) {
                $items.filter(filterCb).addClass(_cssCls.hidden);
            }

            // update the section counters
            this.controls.$tree.find(_selectors.sections).each(function () {
                var $section     = $(this);
                var $itemsFound  = $section.find(_selectors.items).not(_selectors.hidden);
                var $filtered    = $itemsFound.not(_selectors.disabled);
                self.writeCount($section.find(_selectors.counters), $filtered.length, $itemsFound.length);
            });
            this.currentFilter = criteria;
        },

        /**
         * Update the config
         * @param {Object} [config]
         * @returns {navigatorApi}
         */
        updateConfig: function updateConfig(config) {
            var $component = this.getElement();
            var scopeClass = _cssCls.scope[this.config.scope || _defaults.scope];

            // apply the new config
            config = _.merge(this.config, config || {});

            // enable/disable the collapsing of the panel
            $component.toggleClass(_cssCls.collapsible, config.canCollapse);

            // update the component CSS class according to the scope
            $component.removeClass(scopeClass);
            scopeClass = _cssCls.scope[this.config.scope || _defaults.scope];
            $component.addClass(scopeClass);

            return this;
        },

        /**
         * Keep the active item visible, auto scroll if needed
         */
        autoScroll: function autoScroll() {
            autoscroll(this.controls.$tree.find(_selectors.activeItem), this.controls.$tree);
        },

        /**
         * Updates the review screen
         * @param {Object} map The current test map
         * @param {Object} context The current test context
         * @returns {navigatorApi}
         * @fires navigator#update
         */
        update: function update(map, context) {
            var scopedMap = this.getScopedMap(map, context);
            var progression = scopedMap.stats || {
                questions: 0,
                answered: 0,
                flagged: 0,
                viewed: 0,
                total: 0
            };
            var totalQuestions = this.getProgressionTotal(progression, 'questions');

            this.map = map;
            this.progression = progression;

            // update the info panel
            this.writeCount(this.controls.$infoAnswered, progression.answered, totalQuestions);
            this.writeCount(this.controls.$infoUnanswered, totalQuestions - progression.answered, totalQuestions);
            this.writeCount(this.controls.$infoViewed, progression.viewed, this.getProgressionTotal(progression, 'total'));
            this.writeCount(this.controls.$infoFlagged, progression.flagged, totalQuestions);
            this.writeCount(this.controls.$infoAll, totalQuestions, null);


            // rebuild the tree
            if (!context.isLinear) {
                this.controls.$filterBar.show();
                this.controls.$linearState.hide();
                this.controls.$tree.html(navigatorTreeTpl(scopedMap));

                this.autoScroll();

                this.setState('prevents-unseen', this.config.preventsUnseen);
                if (this.config.preventsUnseen) {
                    // disables all unseen items to prevent the test taker has access to.
                    this.controls.$tree.find(_selectors.unseen).addClass(_cssCls.disabled);
                }
            } else {
                this.controls.$filterBar.hide();
                this.controls.$linearState.show();
                this.controls.$tree.empty();
            }

            // apply again the current filter
            this.filter(this.controls.$filters.filter(_selectors.actives).data('mode'));

            /**
             * @event navigator#update the navigation data have changed
             */
            this.trigger('update');

            return this;
        },

        /**
         * Gets the scoped map
         * @param {Object} map The current test map
         * @param {Object} context The current test context
         * @returns {object} The scoped map
         */
        getScopedMap: function getScopedMap(map, context) {
            var scopedMap = mapHelper.getScopeMapFromContext(map, context, this.config.scope);
            var testPart = mapHelper.getPart(scopedMap, context.testPartId) || {};
            var section = mapHelper.getSection(scopedMap, context.sectionId) || {};
            var item = mapHelper.getItem(scopedMap, context.itemIdentifier) || {};

            // set the active part/section/item
            testPart.active = true;
            section.active = true;
            item.active = true;

            // adjust each item with additional meta
            return mapHelper.each(scopedMap, function(itm) {
                var cls = [];
                var icon = '';

                if (itm.active) {
                    cls.push('active');
                }
                if (itm.informational) {
                    cls.push('info');
                    icon = icon || 'info';
                }
                if (itm.flagged) {
                    cls.push('flagged');
                    icon = icon || 'flagged';
                }
                if (itm.answered) {
                    cls.push('answered');
                    icon = icon || 'answered';
                }
                if (itm.viewed) {
                    cls.push('viewed');
                    icon = icon || 'viewed';
                } else {
                    cls.push('unseen');
                    icon = icon || 'unseen';
                }

                itm.cls = cls.join(' ');
                itm.icon = icon;
            });
        },

        /**
         * Updates a counter
         * @param {jQuery} $place
         * @param {Number} count
         * @param {Number|Null} total
         * @private
         */
        writeCount: function writeCount($place, count, total) {

            var display = 0;
            if($place.parent().hasClass('qti-navigator-tab')){
                display = Math.max(count, 0);
            }
            else if(total > 0){
                display = Math.min(count, total) + '/' + total;
            }
            $place.text(display);
        },

        /**
         * Selects an item
         * @param {String|jQuery} position The item's position
         * @param {Boolean} [open] Forces the tree to be opened on the selected item
         * @returns {jQuery} Returns the selected item
         */
        select: function select(position, open) {
            // find the item to select and extract its hierarchy
            var $tree = this.controls.$tree;
            var selected = position && position.jquery ? position : $tree.find('[data-position=' + position + ']');
            var hierarchy = selected.parentsUntil($tree);
            var previousPosition = 0;
            var $previous = $tree.find(_selectors.activeItem);
            if ( $previous.length ) {
                previousPosition = $previous.data('position');
            }

            // collapse the full tree and open only the hierarchy of the selected item
            if (open) {
                this.openOnly(hierarchy);
            }

            // select the item
            $tree.find(_selectors.actives).removeClass(_cssCls.active);
            hierarchy.add(selected).addClass(_cssCls.active);

            position = selected.data('position');

            /**
             * An item is selected
             *
             * @param {Number} position - The item position on which select
             * @param {Number} previousPosition - The item position from which select
             * @event navigator#selected
             */
            this.trigger('selected', position, previousPosition);

            return selected;
        },

        /**
         * Opens the tree on the selected item only
         * @returns {jQuery} Returns the selected item
         */
        openSelected: function openSelected() {
            // find the selected item and extract its hierarchy
            var $tree = this.controls.$tree;
            var selected = $tree.find(_selectors.items + _selectors.actives);
            var hierarchy = selected.parentsUntil($tree);

            // collapse the full tree and open only the hierarchy of the selected item
            this.openOnly(hierarchy);

            return selected;
        },

        /**
         * Collapses the full tree and opens only the provided branch
         * @param {jQuery} opened The element to be opened
         * @param {jQuery} [root] The root element from which collapse the panels
         */
        openOnly: function openOnly(opened, root) {
            (root || this.controls.$tree).find(_selectors.collapsible).addClass(_cssCls.collapsed);
            opened.removeClass(_cssCls.collapsed);
        },

        /**
         * Toggles a panel
         * @param {jQuery} panel The panel to toggle
         * @param {String} [collapseSelector] Selector of panels to collapse
         * @returns {Boolean} Returns `true` if the panel just expanded now
         */
        togglePanel: function togglePanel(panel, collapseSelector) {
            var collapsed = panel.hasClass(_cssCls.collapsed);

            if (collapseSelector) {
                this.controls.$tree.find(collapseSelector).addClass(_cssCls.collapsed);
            }

            if (collapsed) {
                panel.removeClass(_cssCls.collapsed);
            } else {
                panel.addClass(_cssCls.collapsed);
            }
            return collapsed;
        },

        /**
         * Toggles the display state of the component
         * @param {Boolean} [show] External condition that's tells if the component must be shown or hidden
         * @returns {navigatorApi}
         */
        toggle: function toggle(show) {
            if (typeof show === 'undefined') {
                show = this.is('hidden');
            }

            if (show) {
                this.show();
            } else {
                this.hide();
            }

            return this;
        }
    };

    /**
     *
     * @param {Object} config
     * @param {String} [config.scope] Limit the review screen to a particular scope: test, testPart, testSection
     * @param {Boolean} [config.preventsUnseen] Prevents the test taker to access unseen items
     * @param {Boolean} [config.canCollapse] Allow the test taker to collapse the component
     * @param {Boolean} [config.canFlag] Allow the test taker to flag items
     * @param {Boolean} [config.hidden] Hide the component at init
     * @param {Object} map The current test map
     * @param {Object} context The current test context
     * @returns {*}
     */
    function navigatorFactory(config, map, context) {

        var navigator;

        /**
         * Flags an item
         * @param {jQuery} $item
         */
        function flagItem($item) {
            var position = $item.data('position');
            var flagged = !$item.hasClass(_cssCls.flagged);

            // update the display
            navigator.setItemFlag(position, flagged);

            /**
             * An item is flagged
             * @event navigator#flag
             * @param {Number} position - The item position on which jump
             * @param {Boolean} flag - Tells whether the item is marked for review or not
             */
            navigator.trigger('flag', position, flagged);
        }

        /**
         * Jumps to an item
         * @param {jQuery} $item
         * @private
         */
        function jump($item) {
            var position = $item.data('position');

            /**
             * A jump to a particular item is required
             * @event navigator#jump
             * @param {Number} position - The item position on which jump
             */
            navigator.trigger('jump', position);
        }

        navigator = component(navigatorApi, _defaults)
            .setTemplate(navigatorTpl)


            // uninstalls the component
            .on('destroy', function () {
                this.controls = null;
            })

            // keep the activ item visible
            .on('show', function () {
                this.autoScroll();
            })

            // renders the component
            .on('render', function () {
                var self = this;

                // main component elements
                var $component = this.getElement();
                var $filterBar = $component.find(_selectors.filterBar);
                var $filters = $filterBar.find('li');
                var $tree = $component.find(_selectors.tree);

                // links the component to the underlying DOM elements
                this.controls = {
                    // access to info panel displaying counters

                    $infoAnswered: $component.find(_selectors.infoAnswered),
                    $infoViewed: $component.find(_selectors.infoViewed),
                    $infoAll: $component.find(_selectors.tabInfoAll),
                    $infoUnanswered: this.config.showLegend ?
                        $component.find(_selectors.infoUnanswered) :
                        $component.find(_selectors.tabInfoUnanswered),
                    $infoFlagged: this.config.showLegend ?
                        $component.find(_selectors.infoFlagged) :
                        $component.find(_selectors.tabInfoFlagged),

                    // access to filter switches
                    $filterBar: $filterBar,
                    $filters: $filters,

                    // access to the tree of parts/sections/items
                    $tree: $tree,

                    // access to the panel displayed when a linear part is reached
                    $linearState: $component.find(_selectors.linearState)
                };

                // apply options
                this.updateConfig();

                // click on the collapse handle: collapse/expand the review panel
                $component.on('click' + _selectors.component, _selectors.collapseHandle, function () {
                    if (!self.is('disabled')) {
                        $component.toggleClass(_cssCls.collapsed);
                        if ($component.hasClass(_cssCls.collapsed)) {
                            self.openSelected();
                        }
                    }
                });

                // click on the info panel title: toggle the related panel
                $component.on('click' + _selectors.component, _selectors.infoPanelLabels, function () {
                    if (!self.is('disabled')) {
                        self.togglePanel($(this).closest(_selectors.infoPanel), _selectors.infoPanel);
                    }
                });

                // click on a part title: toggle the related panel
                $tree.on('click' + _selectors.component, _selectors.partLabels, function () {
                    var $panel;

                    if (!self.is('disabled')) {
                        $panel = $(this).closest(_selectors.parts);

                        if (self.togglePanel($panel, _selectors.parts)) {
                            if ($panel.hasClass(_cssCls.active)) {
                                self.openSelected();
                            } else {
                                self.openOnly($panel.find(_selectors.sections).first(), $panel);
                            }
                        }
                    }

                });

                // click on a section title: toggle the related panel
                $tree.on('click' + _selectors.component, _selectors.sectionLabels, function () {
                    if (!self.is('disabled')) {
                        self.togglePanel($(this).closest(_selectors.sections), _selectors.sections);
                    }
                });

                // click on an item: jump to the position
                $tree.on('click' + _selectors.component, _selectors.itemLabels, function (event) {
                    var $item, $target;

                    if (!self.is('disabled')) {
                        $item = $(this).closest(_selectors.items);

                        if (!$item.hasClass(_cssCls.disabled)) {
                            $target = $(event.target);
                            if (self.config.canFlag && $target.is(_selectors.icons) && !$component.hasClass(_cssCls.collapsed)) {
                                // click on the icon, just flag the item, unless the panel is collapsed
                                if (!$item.hasClass(_cssCls.unseen) && !$item.hasClass(_cssCls.info)) {
                                    flagItem($item);
                                }
                            } else if (!$item.hasClass(_cssCls.active)){
                                // go to the selected item
                                self.select($item);
                                jump($item);
                            }
                        }
                    }
                });

                // click on the start button inside a linear part: jump to the position
                $tree.on('click' + _selectors.component, _selectors.linearStart, function () {
                    var $btn;

                    if (!self.is('disabled')) {
                        $btn = $(this);

                        // go to the first item of the linear part
                        if (!$btn.hasClass(_cssCls.disabled)) {
                            $btn.addClass(_cssCls.disabled);
                            jump($btn);
                        }
                    }

                });

                // click on a filter button
                $filterBar.on('click' + _selectors.component, _selectors.filter, function () {
                    var $btn, mode;

                    if (!self.is('disabled')) {
                        $btn = $(this);
                        mode = $btn.data('mode');

                        // select the button
                        $filters.removeClass(_cssCls.active);
                        $component.removeClass(_cssCls.collapsed);
                        $btn.addClass(_cssCls.active);

                        // filter the items
                        self.filter(mode);

                        //after filtering, ensure that the active item (if exists) is visible
                        self.autoScroll();
                    }
                });

                this.update(map, context);
            });

        // set default filter
        navigator.currentFilter = 'all';

        // the component will be ready
        return navigator.init(config);
    }

    return navigatorFactory;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Control Plugin : Review panel
 *
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/navigation/review/review',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/helpers/map',
    'taoQtiTest/runner/plugins/navigation/review/navigator'
], function ($, _, __, hider, shortcut, namespaceHelper, pluginFactory, mapHelper, navigatorFactory) {
    'use strict';

    /**
     * The display states of the buttons
     */
    var buttonData = {
        setFlag: {
            control: 'set-item-flag',
            title: __('Flag the current item for later review'),
            icon: 'anchor',
            text: __('Flag for Review')
        },
        unsetFlag: {
            control: 'unset-item-flag',
            title: __('Do not flag the current item for later review'),
            icon: 'anchor',
            text: __('Unflag for Review')
        },
        showReview: {
            control: 'show-review',
            title: __('Show the review screen'),
            icon: 'right',
            text: __('Show Review')
        },
        hideReview: {
            control: 'hide-review',
            title: __('Hide the review screen'),
            icon: 'left',
            text: __('Hide Review')
        }
    };

    /**
     * Gets the definition of the flagItem button related to the context
     * @param {Object} context - the test context
     * @returns {Object}
     */
    function getFlagItemButtonData(context) {
        var dataType = context.itemFlagged ? 'unsetFlag' : 'setFlag';
        return buttonData[dataType];
    }

    /**
     * Gets the definition of the toggleNavigator button related to the context
     * @param {Object} navigator - the navigator component
     * @returns {Object}
     */
    function getToggleButtonData(navigator) {
        var dataType = navigator.is('hidden') ? 'showReview' : 'hideReview';
        return buttonData[dataType];
    }

    /**
     * Update the button based on the provided data
     * @param {Component} button - the element to update
     * @param {Object} data - the button data
     */
    function updateButton(button, data) {
        var $button = button.getElement();
        if (button.is('rendered')) {
            if ($button.data('control') !== data.control) {
                $button
                    .data('control', data.control)
                    .attr('title', data.title);

                $button.find('.icon').attr('class', 'icon icon-' + data.icon);
                $button.find('.text').text(data.text);

                if (_.contains(data.control, 'flag')) {
                    if (button.is('active')) {
                        button.turnOff();
                    } else {
                        button.turnOn();
                    }
                }
            }
        }
    }

    /**
     * Checks if the current context allows to mark the item for review
     * @param {Object} testRunner
     * @returns {Boolean}
     */
    function canFlag(testRunner) {
        var context = testRunner.getTestContext();
        var map = testRunner.getTestMap();
        var item = mapHelper.getItemAt(map, context.itemPosition);
        return !!(!context.isLinear && context.options.markReview && !(item && item.informational));
    }

    /**
     * Creates the timer plugin
     */
    return pluginFactory({
        name: 'review',

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;
            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData();
            var testContext = testRunner.getTestContext();
            var testMap = testRunner.getTestMap();
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};
            var navigatorConfig = testConfig.review || {};
            var previousItemPosition;

            /**
             * Tells if the component is enabled
             * @returns {Boolean}
             */
            function isPluginAllowed() {
                var context = testRunner.getTestContext();
                return navigatorConfig.enabled && context && context.options && context.options.reviewScreen;
            }

            /**
             * Mark an item for review
             * @param {Number} position
             * @param {Boolean} flag
             * @returns {Promise}
             */
            function flagItem(position, flag) {
                self.disable();

                return testRunner.getProxy()
                    .callTestAction('flagItem', {
                        position: position,
                        flag: flag
                    })
                    .then(function () {
                        var context = testRunner.getTestContext();

                        // update the state in the context if the flagged item is the current one
                        if (context.itemPosition === position) {
                            context.itemFlagged = flag;
                        }

                        // update the display of the flag button
                        updateButton(self.flagItemButton, getFlagItemButtonData(context));

                        // update the item state
                        self.navigator.setItemFlag(position, flag);
                        self.enable();
                    })
                    .catch(function () {
                        // rollback on the item flag
                        self.navigator.setItemFlag(position, !flag);
                        self.enable();
                    });
            }

            /**
             * Mark the current item for review
             */
            function flagCurrentItem() {
                var context = testRunner.getTestContext();
                if (self.getState('enabled') !== false) {
                    flagItem(context.itemPosition, !context.itemFlagged);
                }
            }

            /**
             * Shows/hides the review panel
             *
             * @param [{Boolean} forcedState], true will show the panel
             */
            function togglePanel(forcedState) {
                var isHidden = _.isUndefined(forcedState) ? self.navigator.is('hidden') : forcedState;
                if (isHidden) {
                    self.explicitlyHidden = false;
                    self.navigator.show();
                } else {
                    self.explicitlyHidden = true;
                    self.navigator.hide();
                }
                updateButton(self.toggleButton, getToggleButtonData(self.navigator));
            }

            this.navigator = navigatorFactory(navigatorConfig, testMap, testContext)
                .on('selected', function(position, previousPosition){
                    previousItemPosition = previousPosition;
                })
                .on('jump', function (position) {
                    if (self.getState('enabled') !== false) {
                        self.disable();
                        testRunner.jump(position, 'item');
                    }
                })
                .on('flag', function (position, flag) {
                    if (self.getState('enabled') !== false) {
                        flagItem(position, flag);
                    }
                })
                .render();

            // restore current item in the navigator if movement not allowed
            testRunner.on('alert.notallowed', function() {
                self.navigator.select(previousItemPosition);
            });

            this.explicitlyHidden = false;

            // register buttons in the toolbox component
            this.toggleButton = this.getAreaBroker().getToolbox().createEntry(getToggleButtonData(this.navigator));
            this.toggleButton.on('click', function (e) {
                e.preventDefault();
                testRunner.trigger('tool-reviewpanel');
            });

            this.flagItemButton = this.getAreaBroker().getToolbox().createEntry(getFlagItemButtonData(testContext));
            this.flagItemButton.on('click', function (e) {
                e.preventDefault();
                testRunner.trigger('tool-flagitem');
            });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.flag) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.flag, this.getName(), true), function () {
                        testRunner.trigger('tool-flagitem');
                    }, {
                        avoidInput: true
                    });
                }

                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger('tool-reviewpanel');
                    }, {
                        avoidInput: true
                    });
                }
            }

            if (!isPluginAllowed()) {
                this.hide();
            }

            //disabled by default
            this.disable();

            togglePanel(testConfig.review.defaultOpen);

            //change plugin state
            testRunner
                .on('render', function () {
                    if (isPluginAllowed()) {
                        self.show();
                        updateButton(self.toggleButton, getToggleButtonData(self.navigator));
                    } else {
                        self.hide();
                    }
                })
                .on('loaditem', function () {
                    var context = testRunner.getTestContext();
                    var map = testRunner.getTestMap();

                    if (isPluginAllowed()) {
                        updateButton(self.flagItemButton, getFlagItemButtonData(context));
                        self.navigator
                            .update(map, context)
                            .updateConfig({
                                canFlag: !context.isLinear && context.options.markReview
                            });
                        self.show();
                        updateButton(self.toggleButton, getToggleButtonData(self.navigator));
                    } else {
                        self.hide();
                    }
                })
                .on('enabletools enablenav', function () {
                    if (isPluginAllowed()) {
                        self.enable();
                    }
                })
                .on('disabletools disablenav', function () {
                    if (isPluginAllowed()) {
                        self.disable();
                    }
                })
                .on('hidenav', function (){
                    self.hide();
                })
                .on('shownav', function (){
                    if (isPluginAllowed()) {
                        self.show();
                    }
                })
                .on('tool-flagitem', function () {
                    if (isPluginAllowed() && canFlag(testRunner)) {
                        flagCurrentItem();
                    }
                })
                .on('tool-reviewpanel', function () {
                    if (isPluginAllowed() && self.getState('enabled')) {
                        togglePanel();
                    }
                });
        },

        /**
         * Called during the runner's render phase
         */
        render: function render() {
            var areaBroker = this.getAreaBroker();
            var $panelContainer = areaBroker.getPanelArea();
            $panelContainer.append(this.navigator.getElement());
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + this.getName());
            this.navigator.destroy();
        },

        /**
         * Enables the button
         */
        enable: function enable() {
            var testRunner = this.getTestRunner();
            var testContext = testRunner.getTestContext();

            this.flagItemButton.enable();
            this.toggleButton.enable();
            this.navigator.enable();
            if (testContext.itemFlagged) {
                this.flagItemButton.turnOn();
            } else {
                this.flagItemButton.turnOff();
            }
        },

        /**
         * Disables the button
         */
        disable: function disable() {
            this.flagItemButton.disable();
            this.flagItemButton.turnOff();

            this.toggleButton.disable();

            this.navigator.disable();
        },

        /**
         * Shows the button
         */
        show: function show() {
            var testRunner = this.getTestRunner();
            if (canFlag(testRunner)) {
                this.flagItemButton.show();
            } else {
                this.flagItemButton.hide();
            }
            this.toggleButton.show();

            if (!this.explicitlyHidden) {
                this.navigator.show();
            } else {
                this.navigator.hide();
            }
        },

        /**
         * Hides the button
         */
        hide: function hide() {
            this.flagItemButton.hide();
            this.toggleButton.hide();
            this.navigator.hide();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Navigation Plugin : Skip
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/navigation/skip',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/helpers/messages',
    'tpl!taoQtiTest/runner/plugins/templates/button'
], function ($, _, __, hider, pluginFactory, messages, buttonTpl){
    'use strict';

    /**
     * The display of the skip
     */
    var buttonData = {
        skip : {
            control : 'skip',
            title   : __('Skip  and go to the next item'),
            icon    : 'external',
            text    : __('Skip')
        },
        end : {
            control : 'skip-end',
            title   : __('Skip and go to the end of the test'),
            icon    : 'external',
            text    : __('Skip and end test')
        }
    };

    /**
     * Create the button based on the current context
     * @param {Object} context - the test context
     * @returns {jQueryElement} the button
     */
    var createElement = function createElement(context){
        var dataType = context.isLast ? 'end' : 'skip';
        return $(buttonTpl(buttonData[dataType]));
    };

    /**
     * Update the button based on the context
     * @param {jQueryElement} $element - the element to update
     * @param {Object} context - the test context
     */
    var updateElement = function updateElement($element, context){
        var dataType = context.isLast ? 'end' : 'skip';
        if($element.attr('data-control') !== buttonData[dataType].control){

            $element.attr('data-control', buttonData[dataType].control)
                    .attr('title', buttonData[dataType].title)
                    .find('.text').text(buttonData[dataType].text);
        }
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name : 'skip',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();

            var toggle = function toggle(){
                var context = testRunner.getTestContext();
                if(context.options.allowSkipping === true){
                    self.show();
                    return true;
                }

                self.hide();
                return false;
            };

            function doSkip() {
                testRunner.skip();
            }

            this.$element = createElement(testRunner.getTestContext());

            this.$element.on('click', function(e){
                var enable = _.bind(self.enable, self);
                var context = testRunner.getTestContext();

                e.preventDefault();

                if(self.getState('enabled') !== false){
                    self.disable();
                    if(context.options.endTestWarning && context.isLast){
                        testRunner.trigger(
                            'confirm.endTest',
                            messages.getExitMessage(
                                __('You are about to submit the test. You will not be able to access this test once submitted. Click OK to continue and submit the test.'),
                                'test', testRunner),
                            doSkip, // if the test taker accept
                            enable  // if the test taker refuse
                        );
                    } else {
                        doSkip();
                    }
                }
            });

            toggle();
            self.disable();

            testRunner
                .on('loaditem', function(){
                    if(toggle()){
                        updateElement(self.$element, testRunner.getTestContext());
                    }
                })
                .on('enablenav', function(){
                    self.enable();
                })
                .on('disablenav', function(){
                    self.disable();
                })
                .on('hidenav', function(){
                    self.hide();
                })
                .on('shownav', function(){
                    self.show();
                });
        },

        /**
         * Called during the runner's render phase
         */
        render : function render(){
            var $container = this.getAreaBroker().getNavigationArea();
            $container.append(this.$element);
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy (){
            this.$element.remove();
        },

        /**
         * Enable the button
         */
        enable : function enable (){
            this.$element.removeProp('disabled')
                         .removeClass('disabled');
        },

        /**
         * Disable the button
         */
        disable : function disable (){
            this.$element.prop('disabled', true)
                         .addClass('disabled');
        },

        /**
         * Show the button
         */
        show: function show(){
            hider.show(this.$element);
        },

        /**
         * Hide the button
         */
        hide: function hide(){
            hider.hide(this.$element);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */

/**
 * http://www.imsglobal.org/question/qtiv2p2p1/QTIv2p2p1-ASI-InformationModelv1p0/imsqtiv2p2p1_asi_v1p0_InfoModelv1p0.html#DerivedCharacteristic_ItemSessionControl.Attr_validateResponses
 *
 * This attribute controls the behaviour of delivery engines when the candidate
 * submits an invalid response. An invalid response is defined to be a response
 * which does not satisfy the constraints imposed by the interaction with which
 * it is associated (see interaction for more information). When
 * validateResponses is turned on (true) then the candidates are not allowed to
 * submit the item until they have provided valid responses for all
 * interactions. When turned off (false) invalid responses may be accepted by
 * the system. The value of this attribute is only applicable when the item is
 * in a testPart with individual submission mode (see Navigation and
 * Submission).
 */

define('taoQtiTest/runner/plugins/navigation/validateResponses',[
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/helpers/currentItem'
], function(_, __, pluginFactory, currentItemHelper) {
    'use strict';

    /**
     * Plugin
     * @returns {Object}
     */
    return pluginFactory({

        /**
         * Plugin name
         * @type {String}
         */
        name: 'validateResponses',

        /**
         * Initialize plugin (called during runner's initialization)
         * @returns {this}
         */
        init: function init() {
            this.getTestRunner().before('move', function () {
                var self = this;
                var testContext = this.getTestContext();
                var isInteracting = !this.getItemState(testContext.itemIdentifier, 'disabled');

                if ( isInteracting && testContext.enableValidateResponses &&  testContext.validateResponses) {
                    return new Promise(function (resolve, reject) {
                        if(_.size(currentItemHelper.getDeclarations(self)) === 0){
                            return resolve();
                        }
                        if (currentItemHelper.isAnswered(self, false)) {
                            return resolve();
                        }
                        if (!self.getState('alerted.notallowed')) { // Only show one alert for itemSessionControl
                            self.setState('alerted.notallowed', true);
                            self.trigger(
                                'alert.notallowed',
                                __('A valid response to this item is required.'),
                                function () {
                                    self.trigger('resumeitem');
                                    reject();
                                    self.setState('alerted.notallowed', false);
                                }
                            );
                        }
                    });
                }

            });

            return this;
        }
    });

});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */

/**
 * Warn the test taker before closing the browser window
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/navigation/warnBeforeLeaving',[
    'i18n',
    'taoTests/runner/plugin'
], function (__, pluginFactory) {
    'use strict';

    /**
     * There's only a few chance to have this message displayed.
     * Most browsers doesn't support custom message anymore.
     * See https://www.chromestatus.com/feature/5349061406228480
     */
    var warnMessage = __('Please confirm you want to leave the test.');

    /**
     * The beforeunload listener
     * @param {Event} e
     * @returns {String} the custom message (for some browser, just need to be a string)
     */
    var warnListener = function warnListener(e){
        e.returnValue = warnMessage;
        return warnMessage;
    };

    /**
     * Plugin factory
     * @returns {Object}
     */
    return pluginFactory({

        /**
         * Plugin name
         * @type {String}
         */
        name: 'warnBeforeLeaving',

        /**
         * Initialize plugin (called during runner's initialization)
         */
        init: function init() {
            this.enable();
        },

        /**
         * Destroy plugin (called during runner's destruction)
         */
        destroy : function destroy(){
            this.disable();
        },

        /**
         * Enables the warning
         */
        enable : function enable(){
            window.addEventListener('beforeunload', warnListener);
        },

        /**
         * Disables the warning
         */
        disable : function disable(){
            window.removeEventListener('beforeunload', warnListener);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/security/disableRightClick',[
    'taoTests/runner/plugin'
], function (pluginFactory) {
    'use strict';

    return pluginFactory({

        name: 'disableRightClick',

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var rightClickEvents = ['contextmenu', 'mousedown', 'mouseup'];

            rightClickEvents.forEach(function(eventName) {
                window.document.addEventListener(eventName, function disableRightClick(event) {
                    if (event.button === 2) {
                        event.preventDefault();
                    }
                });
            });
        }
    });
});


/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */

/**
 * Answer Eliminator Plugin
 *
 * While the platform's answer eliminator works on a per-item base, this variation allows
 * answer elimination on a test level. Essentially it allows to add a class 'eliminable'
 * to a choice interaction, from there the aforementioned item-based behaviour and styling takes
 * over.
 *
 * Alternative styling will be on a per customer basis and should always be published as a recipe
 * in the theme-toolkit.
 *
 * @author Dieter Raber <dieter@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/answerElimination/eliminator',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoTests/runner/plugin'
], function ($, _, __, hider, shortcut, namespaceHelper, pluginFactory){
    'use strict';

    /**
     * The public name of the plugin
     * @type {String}
     */
    var pluginName = 'eliminator';

    /**
     * The prefix of actions triggered through the event loop
     * @type {String}
     */
    var actionPrefix = 'tool-' + pluginName + '-';


    /**
     * Some default options for the plugin
     * @type {Object}
     */
    var defaultConfig = {
        // when hiding the buttons, don't remove existing eliminations
        removeEliminationsOnClose: false,
        // when showing the buttons, restore previously set eliminations
        restoreEliminationsOnOpen: false
    };



    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: pluginName,

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;

            var testRunner = this.getTestRunner();
            var $container = testRunner.getAreaBroker().getContentArea().parent();
            var testConfig = testRunner.getTestData().config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[pluginName] || {};
            var config     = _.defaults(_.clone((testConfig.plugins || {})[pluginName]) || {}, defaultConfig);

            // register the button in the toolbox
            this.button = this.getAreaBroker().getToolbox().createEntry({
                control : 'eliminator',
                title : __('Eliminate choices'),
                icon : 'eliminate',
                text : __('Answer Eliminator')
            });

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isPluginEnabled() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};
                //to be activated with the special category x-tao-option-eliminator
                return !!options.eliminator;
            }

            /**
             * Is plugin activated ? if not, then we hide the plugin
             */
            function togglePluginButton() {
                if (isPluginEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }

            function togglePlugin() {
                if (!self.$choiceInteractions) {
                    return;
                }
                self.$choiceInteractions.toggleClass('eliminable');
                if (isEliminable()) {
                    enableEliminator();
                } else {
                    disableEliminator();
                }
            }

            function isEliminable() {
                if (!self.$choiceInteractions) {
                    return;
                }
                return self.$choiceInteractions.hasClass('eliminable');
            }

            function enableEliminator() {
                var $choices;
                if (!self.$choiceInteractions) {
                    return;
                }
                $choices = self.$choiceInteractions.find('.qti-choice');

                self.button.turnOn();
                self.trigger('start');

                if(config.restoreEliminationsOnOpen) {
                    $choices.each(function() {
                        var input = this.querySelector('.real-label input');
                        if(this.dataset.wasEliminated) {
                            this.dataset.wasEliminated = null;
                            this.classList.add('eliminated');
                            input.setAttribute('disabled', 'disabled');
                            input.checked = false;
                        }
                    });
                }
            }

            function disableEliminator() {
                var $choices;
                if (!self.$choiceInteractions) {
                    return;
                }
                $choices = self.$choiceInteractions.find('.qti-choice');

                self.$choiceInteractions.removeClass('eliminable');
                self.button.turnOff();
                self.trigger('end');

                $choices.each(function() {
                    if(this.classList.contains('eliminated')) {
                        this.dataset.wasEliminated = true;
                        this.classList.remove('eliminated');
                        this.querySelector('.real-label input').removeAttribute('disabled');
                    }
                });
            }

            //add a new mask each time the button is pressed
            this.button.on('click', function (e){
                e.preventDefault();
                testRunner.trigger(actionPrefix + 'toggle');
            });

            // handle the plugin's shortcuts
            if (testConfig.allowShortcuts) {
                _.forEach(pluginShortcuts, function (command, key) {
                    shortcut.add(namespaceHelper.namespaceAll(command, pluginName, true), function () {
                        // just fire the action using the event loop
                        testRunner.trigger(actionPrefix + key);
                    }, {
                        avoidInput: true
                    });
                });
            }

            //start disabled
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', togglePluginButton)
                .on('renderitem', function conditionalInit() {
                    // show button only when in the presence of choice interactions
                    self.$choiceInteractions = $container.find('.qti-choiceInteraction');
                    if(!self.$choiceInteractions.length) {
                        self.hide();
                        return;
                    }
                    if (isPluginEnabled()) {
                        self.show();
                    }
                })
                .on('enabletools renderitem', function (){
                    self.enable();
                })
                .on('disabletools unloaditem', function (){
                    self.disable();
                    disableEliminator();
                })

                // commands that controls the plugin
                .on(actionPrefix + 'toggle', function () {
                    if (isPluginEnabled()) {
                        togglePlugin();
                    }
                })
                // Answer-eliminator and Answer-masking are mutually exclusive tools
                .on('tool-answer-masking-toggle', function () {
                    if (isEliminable()) {
                        disableEliminator();
                    }
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy(){
            shortcut.remove('.' + pluginName);
        },

        /**
         * Enable the button
         */
        enable : function enable(){
            this.button.enable();
        },

        /**
         * Disable the button
         */
        disable : function disable(){
            this.button.disable();
        },

        /**
         * Show the button
         */
        show : function show(){
            this.button.show();
        },

        /**
         * Hide the button
         */
        hide : function hide(){
            this.button.hide();
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/tools/answerMasking/tpl/mask', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"answer-mask\">\n    <span class=\"answer-mask-toggle\"></span>\n</div>";
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */
/**
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/answerMasking/answerMasking',[
    'lodash',
    'jquery',
    'core/statifier',
    'ui/component',
    'tpl!taoQtiTest/runner/plugins/tools/answerMasking/tpl/mask'
], function(_, $, statifier, componentFactory, maskTpl) {
    'use strict';

    var ns = '.answerMasking';

    /**
     * @param {jQuery} $contentArea - DOM element containing the rendered item
     */
    return function answerMaskingFactory($contentArea) {
        var answerMasking,
            allMasks = [],

            maskApi = {
                /**
                 * Toggle mask visibility
                 * @returns {component}
                 */
                toggle: function toggle() {
                    if (this.is('masked')) {
                        return this.reveal();
                    } else {
                        return this.mask();
                    }
                },

                /**
                 * Show the choice under the current mask
                 * @returns {component}
                 */
                reveal: function reveal() {
                    var $container = this.getContainer();
                    $container.removeClass('masked');
                    $container.find('input').removeAttr('disabled');

                    this.setState('masked', false);

                    return this;
                },

                /**
                 * Cover the whole choice with the mask
                 * @returns {component}
                 */
                mask: function mask() {
                    var $container = this.getContainer();
                    $container.addClass('masked');
                    $container.find('input').attr('disabled', 'disabled');

                    this.setState('masked', true);

                    return this;
                }
            };

        /**
         * Creates a ui/component to serve as a mask over a QTI Choice
         * @param {jQuery} $container - the qti-choice element
         * @returns {component}
         */
        function createMask($container) {
            return componentFactory(maskApi)
                .setTemplate(maskTpl)
                .on('render', function() {
                    var self = this,
                        $component = this.getElement();

                    $component.on('click' + ns, function(e) {
                        e.stopPropagation();
                        e.preventDefault();

                        self.toggle();
                    });
                })
                .on('destroy', function() {
                    var $component = this.getElement();
                    $component.off(ns);
                })
                .init()
                .render($container)
                .mask();
        }

        /**
         * The answer masking helper
         */
        answerMasking = {
            /**
             * Enable the answer masking functionality by creating masks over the Qti Choices
             */
            enable: function enable() {
                var $choiceInteractions = $contentArea.find('.qti-choiceInteraction'),
                    $qtiChoices = $contentArea.find('.qti-choice');

                allMasks = [];

                $choiceInteractions.addClass('maskable');

                $qtiChoices.each(function () {
                    var $choice = $(this);
                    allMasks.push(createMask($choice));
                });

                this.setState('enabled', true);
            },

            /**
             * Remove any answerMasking-related markup from the rendered item
             */
            disable: function disable() {
                var $choiceInteractions = $contentArea.find('.qti-choiceInteraction');
                $choiceInteractions.removeClass('maskable');

                allMasks.forEach(function(mask) {
                    mask.reveal(); // remove class on container
                    mask.destroy();
                });

                allMasks = [];

                this.setState('enabled', false);
            },

            /**
             * Return the current state of the masks
             * @returns {Boolean[]} - true if the choice is masked, false if the choice is revealed
             */
            getMasksState: function getMasksState() {
                var state = allMasks.map(function (mask) {
                    return mask.is('masked');
                });
                return state;
            },

            /**
             * Restore a previously saved state for the masked choices
             * @param {Boolean[]} state - array of boolean, most probably given by the getMasksState method
             */
            setMasksState: function setMasksState(state) {
                state = state || [];

                state.forEach(function (masked, index) {
                    var mask = allMasks[index];

                    if (_.isObject(mask) && _.isFunction(mask.reveal) && ! masked) {
                        mask.reveal();
                    }
                });
            }
        };

        statifier(answerMasking);

        return answerMasking;
    };
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 *
 */
/**
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/answerMasking/plugin',[
    'jquery',
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoQtiTest/runner/plugins/tools/answerMasking/answerMasking'
], function ($, _, __, pluginFactory, hider, shortcut, namespaceHelper, answerMaskingFactory) {
    'use strict';

    /**
     * The public name of the plugin
     * @type {String}
     */
    var pluginName = 'answer-masking';

    /**
     * The prefix of actions triggered through the event loop
     * @type {String}
     */
    var actionPrefix = 'tool-' + pluginName + '-';

    /**
     * Stores the masking state for each item in the test
     * @type {Object}
     */
    var itemStates = {};

    /**
     * Default Configuration
     */
    var defaultConfig = {
        restoreStateOnToggle: true,
        restoreStateOnMove: true
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: pluginName,

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;

            var testRunner = this.getTestRunner(),
                testData = testRunner.getTestData() || {},
                testConfig = testData.config || {},
                pluginConfig = _.defaults((testConfig.plugins || {})[pluginName] || {}, defaultConfig),
                pluginShortcuts = (testConfig.shortcuts || {})[pluginName] || {},
                $contentArea = this.getAreaBroker().getContentArea();

            var answerMasking = answerMaskingFactory($contentArea);

            function isPluginEnabled() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};
                //to be activated with the special category x-tao-option-answerMasking
                return options.answerMasking && itemContainsChoiceInteraction();
            }

            function itemContainsChoiceInteraction() {
                var $container = self.getAreaBroker().getContentArea().parent();
                return $container.find('.qti-choiceInteraction').length;
            }

            function togglePluginButton() {
                if (isPluginEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }

            function togglePlugin() {
                if (! answerMasking.getState('enabled')) {
                    enableMasking();
                } else {
                    disableMasking();
                }
            }

            function enableMasking() {
                var testContext = testRunner.getTestContext(),
                    itemId = testContext.itemIdentifier;

                answerMasking.enable();
                if (pluginConfig.restoreStateOnToggle) {
                    answerMasking.setMasksState(itemStates[itemId]);
                }
                self.button.turnOn();
                self.trigger('start');
            }

            function disableMasking() {
                var testContext = testRunner.getTestContext(),
                    itemId = testContext.itemIdentifier;

                if (answerMasking.getState('enabled')) {
                    itemStates[itemId] = answerMasking.getMasksState();
                }

                answerMasking.disable();
                self.button.turnOff();
                self.trigger('end');
            }

            // create buttons
            this.button = this.getAreaBroker().getToolbox().createEntry({
                title: __('Answer Masking'),
                icon: 'result-nok',
                control: 'answer-masking',
                text: __('Answer Masking')
            });

            // attach user events
            this.button
                .on('click', function(e) {
                    e.preventDefault();
                    testRunner.trigger(actionPrefix + 'toggle');
                });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger(actionPrefix + 'toggle');
                    }, { avoidInput: true, prevent: true });
                }
            }

            //start disabled
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', function() {
                    var testContext = testRunner.getTestContext(),
                        itemId = testContext.itemIdentifier;

                    if (! pluginConfig.restoreStateOnMove) {
                        itemStates[itemId] = [];
                    }

                    togglePluginButton();
                })
                .on('enabletools renderitem', function () {
                    togglePluginButton(); // we repeat this here as we need the rendered item markup in order to decide whether the plugin is enabled
                    self.enable();
                })
                .on('beforeunloaditem', function() {
                    disableMasking();
                })
                .on('disabletools unloaditem', function () {
                    self.disable();
                    disableMasking();
                })
                .on(actionPrefix + 'toggle', function () {
                    if (isPluginEnabled()) {
                        togglePlugin();
                    }
                })
                // Answer-eliminator and Answer-masking are mutually exclusive tools
                .on('tool-eliminator-toggle', function () {
                    disableMasking();
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + this.getName());
        },

        /**
         * Enable the button
         */
        enable: function enable() {
            this.button.enable();
        },

        /**
         * Disable the button
         */
        disable: function disable() {
            this.button.disable();
        },

        /**
         * Show the button
         */
        show: function show() {
            this.button.show();
        },

        /**
         * Hide the button
         */
        hide: function hide() {
            this.button.hide();
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/tools/areaMasking/mask', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"mask\">\n   <div class=\"inner\"></div>\n   <div class=\"controls\">\n        <a href=\"#\" class=\"view\"  title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Preview the covered area", options) : helperMissing.call(depth0, "__", "Preview the covered area", options)))
    + "\"><span class=\"icon-preview\"></span></a>\n        <a href=\"#\" class=\"close\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Close the mask", options) : helperMissing.call(depth0, "__", "Close the mask", options)))
    + "\"><span class=\"icon-result-nok\"></span></a>\n   </div>\n</div>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA;
 */

/**
 * Create a movable and resizable element in order to mask areas.
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/areaMasking/mask',[
    'lodash',
    'ui/movableComponent',
    'tpl!taoQtiTest/runner/plugins/tools/areaMasking/mask'
], function (_, movableComponent, areaMaskingTpl) {
    'use strict';

    var defaultConfig = {
        previewDelay: 3000,
        stackingScope: 'test-runner'
    };

    /**
     * Creates a new masking component
     * @returns {maskComponent} the component (uninitialized)
     */
    function maskingComponentFactory () {

        /**
         * @typedef {Object} maskComponent
         */
        var maskComponent = movableComponent({
            /**
             * Preview the content under the masked area
             * @returns {maskComponent} chains
             *
             * @fires maskComponent#preview
             */
            preview : function preview(){
                var self   = this;
                var delay  = this.config.previewDelay || 1000;
                if( this.is('rendered') && !this.is('disabled') && !this.is('previewing') ){
                    this.setState('previewing', true)
                        .trigger('preview');
                    _.delay(function(){
                        self.setState('previewing', false);
                    }, delay);
                }
                return this;
            }
        }, defaultConfig);


        maskComponent
            .setTemplate(areaMaskingTpl)
            .on('render', function(){
                var self     = this;
                var $element = this.getElement();

                $element
                    .on('click touchstart', '.view', function(e){
                        e.preventDefault();
                        self.preview();
                    })
                    .on('click touchstart', '.close', function(e){
                        e.preventDefault();
                        self.destroy();
                    });
            });

        return maskComponent;
    }

    return maskingComponentFactory;
});


/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA;
 */

/**
 * Area Masking Plugin
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/areaMasking/areaMasking',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoTests/runner/plugin',
    'taoQtiTest/runner/plugins/tools/areaMasking/mask'
], function ($, _, __, hider, shortcut, namespaceHelper, pluginFactory, maskComponent){
    'use strict';

    /**
     * The public name of the plugin
     * @type {String}
     */
    var pluginName = 'area-masking';

    /**
     * The prefix of actions triggered through the event loop
     * @type {String}
     */
    var actionPrefix = 'tool-' + pluginName + '-';

    /**
     * Some default options for the plugin
     * @type {Object}
     */
    var defaultConfig = {
        max : 5,
        foo : true
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: pluginName,

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;

            var testRunner = this.getTestRunner();
            var $container = testRunner.getAreaBroker().getContentArea().parent();
            var testConfig = testRunner.getTestData().config || {};
            var config     = _.defaults(_.clone((testConfig.plugins || {})[pluginName]) || {}, defaultConfig);
            var pluginShortcuts = (testConfig.shortcuts || {})[pluginName] || {};

            function addMask() {
                maskComponent()
                    .on('render', function(){
                        self.masks.push(this);
                        self.button.turnOn();

                        /**
                         * @event areaMasking#maskadd
                         */
                        self.trigger('maskadd');
                    })
                    .on('destroy', function(){
                        self.masks = _.without(self.masks, this);
                        if(self.masks.length < config.max){
                            self.enable();
                        }
                        if (self.masks.length === 0) {
                            self.button.turnOff();
                            self.trigger('close');
                        }

                        /**
                         * @event areaMasking#maskclose
                         */
                        self.trigger('maskclose');
                    })
                    .init({
                        x : self.masks.length * 10,
                        y : self.masks.length * 10
                    })
                    .render($container);
            }

            //keep a ref to all masks
            this.masks = [];

            // register the element in the Toolbox
            this.button = this.getAreaBroker().getToolbox().createEntry({
                control : 'area-masking',
                text : __('Masking'),
                title : __('Covers parts of the item'),
                icon : 'eye-slash'
            });

            //add a new mask each time the button is pressed
            this.button.on('click', function (e){
                e.preventDefault();
                testRunner.trigger(actionPrefix + 'toggle');
            });

            // handle the plugin's shortcuts
            if (testConfig.allowShortcuts) {
                _.forEach(pluginShortcuts, function (command, key) {
                    shortcut.add(namespaceHelper.namespaceAll(command, pluginName, true), function () {
                        // just fire the action using the event loop
                        testRunner.trigger(actionPrefix + key);
                    }, {
                        avoidInput: true
                    });
                });
            }

            //start disabled
            this.disable();

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isEnabled() {
                var context = testRunner.getTestContext(),
                    options = context.options || {};
                //to be activated with the special category x-tao-option-areaMasking
                return !!options.areaMasking;
            }

            /**
             * Is plugin activated ? if not, then we hide the plugin
             */
            function togglePlugin() {
                if (isEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }
            //update plugin state based on changes
            testRunner
                .on('loaditem', togglePlugin)
                .on('enabletools renderitem', function (){
                    self.enable();
                })
                .on('disabletools unloaditem', function (){
                    self.disable();
                    //remove all masks
                    _.invoke(self.masks, 'destroy');
                })
                // commands that controls the plugin
                .on(actionPrefix + 'toggle', function () {
                    if (isEnabled()) {
                        if (self.masks.length === 0) {
                            self.trigger('open');
                        }
                        if (self.masks.length < config.max) {
                            addMask();
                        } else if (config.max === 1) {
                            _.invoke(self.masks, 'destroy');
                        }
                    }
                });

        },

        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy(){
            shortcut.remove('.' + pluginName);
        },

        /**
         * Enable the button
         */
        enable : function enable(){
            this.button.enable();
        },

        /**
         * Disable the button
         */
        disable : function disable(){
            this.button.disable();
        },

        /**
         * Show the button
         */
        show : function show(){
            this.button.show();
        },

        /**
         * Hide the button
         */
        hide : function hide(){
            this.button.hide();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Tool Plugin : Calculator
 *
 * @author Sam <sam@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/calculator',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'ui/calculator',
    'util/shortcut',
    'util/namespace',
    'taoTests/runner/plugin'
], function ($, _, __, hider, calculatorFactory, shortcut, namespaceHelper, pluginFactory){
    'use strict';

    var _default = {
        height : 360,
        width : 240,
        top : 50,
        left : 10,
        stackingScope: 'test-runner'
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({
        name : 'calculator',
        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();
            var areaBroker = this.getAreaBroker();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginsConfig = testConfig.plugins || {};
            var config = pluginsConfig.calculator || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isEnabled() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};

                //to be activated with the special category x-tao-option-calculator
                return !!options.calculator;
            }

            /**
             * Is calculator activated ? if not, then we hide the plugin
             */
            function togglePlugin() {
                if (isEnabled()) {//allow calculator
                    self.show();
                } else {
                    self.hide();
                }
            }

            /**
             * Build the calculator component
             * @param {Function} [calcTpl] - an optional alternative template for the calculator
             */
            function buildCalculator(calcTpl){
                self.calculator = calculatorFactory(_.defaults({
                    renderTo: self.$calculatorContainer,
                    replace: true,
                    draggableContainer: areaBroker.getContainer(),
                    alternativeTemplate : calcTpl || null
                }, _default)).on('show', function () {
                    self.trigger('open');
                    self.button.turnOn();
                }).on('hide', function () {
                    self.trigger('close');
                    self.button.turnOff();
                }).show();
            }

            /**
             * Show/hide the calculator
             */
            function toggleCalculator() {
                if (self.getState('enabled') !== false) {
                    if (self.calculator) {
                        //just show/hide the calculator widget
                        if (self.calculator.is('hidden')) {
                            self.calculator.show();
                        } else {
                            self.calculator.hide();
                        }
                    } else {
                        //build calculator widget
                        if(config.template){
                            require(['tpl!' + config.template.replace(/\.tpl$/, '')], function(calcTpl){
                                buildCalculator(calcTpl);
                            }, function(){
                                //in case of error, display the default calculator:
                                buildCalculator();
                            });
                        }else{
                            buildCalculator();
                        }

                    }
                }
            }

            //build element (detached)
            this.button = this.getAreaBroker().getToolbox().createEntry({
                control : 'calculator',
                title : __('Open Calculator'),
                icon : 'table',
                text : __('Calculator')
            });
            this.$calculatorContainer = $('<div class="widget-calculator">');

            //init calculator instance var, it will be created only necessary
            this.calculator = null;

            //attach behavior
            this.button.on('click', function (e){
                //prevent action if the click is made inside the form which is a sub part of the button
                if($(e.target).closest('.widget-calculator').length){
                    return;
                }

                e.preventDefault();
                testRunner.trigger('tool-calculator');
            });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger('tool-calculator');
                    }, {
                        avoidInput: true,
                        allowIn: '.widget-calculator'
                    });
                }
            }

            //start disabled
            togglePlugin();
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', togglePlugin)
                .on('enabletools renderitem', function (){
                    self.enable();
                })
                .on('disabletools unloaditem', function (){
                    self.disable();
                    if(self.calculator){
                        //destroy calculator to create a new instance of calculator each time
                        self.calculator.destroy();
                        self.calculator = null;
                    }
                })
                .on('tool-calculator', function () {
                    if (isEnabled()) {
                        toggleCalculator();
                    }
                });
        },
        /**
         * Called during the runner's render phase
         */
        render : function render(){
            var areaBroker = this.getAreaBroker();
            areaBroker.getContainer().append(this.$calculatorContainer);
        },
        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy(){
            shortcut.remove('.' + this.getName());

            this.$calculatorContainer.remove();
            if(this.calculator){
                this.calculator.destroy();
            }
        },
        /**
         * Enable the button
         */
        enable : function enable(){
            this.button.enable();
        },
        /**
         * Disable the button
         */
        disable : function disable(){
            this.button.disable();
            if(this.calculator){
                this.calculator.hide();
            }
        },
        /**
         * Show the button
         */
        show : function show(){
            this.button.show();
        },
        /**
         * Hide the button
         */
        hide : function hide(){
            this.button.hide();
            if(this.calculator){
                this.calculator.hide();
            }
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/tools/comment/comment', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div data-control=\"qti-comment\" class=\"hidden\">\n    <textarea data-control=\"qti-comment-text\" placeholder=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Your comment…", options) : helperMissing.call(depth0, "__", "Your comment…", options)))
    + "\"></textarea>\n    <button data-control=\"qti-comment-cancel\" class=\"btn-info small\"></span>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Cancel", options) : helperMissing.call(depth0, "__", "Cancel", options)))
    + "</button>\n    <button data-control=\"qti-comment-send\" class=\"btn-info small\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Send", options) : helperMissing.call(depth0, "__", "Send", options)))
    + "</button>\n</div>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Tool Plugin : Comment form
 *
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/tools/comment/comment',[
    'jquery',
    'i18n',
    'taoTests/runner/plugin',
    'ui/hider',
    'ui/stacker',
    'util/shortcut',
    'util/namespace',
    'tpl!taoQtiTest/runner/plugins/tools/comment/comment'
], function ($, __, pluginFactory, hider, stackerFactory, shortcut, namespaceHelper, commentTpl) {
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: 'comment',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;

            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};
            var stacker = stackerFactory('test-runner');

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isEnabled() {
                var context = testRunner.getTestContext();
                return !!context.options.allowComment;
            }

            /**
             * Can we comment ? if not, then we hide the plugin
             */
            function togglePlugin() {
                if (isEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }

            /**
             * Show/hide the comment panel
             */
            function toggleComment() {
                if (self.getState('enabled') !== false) {
                    //just show/hide the form
                    hider.toggle(self.$form);
                    if (!hider.isHidden(self.$form)) {
                        //reset the form on each display
                        self.$input.val('').focus();
                        self.button.turnOn();
                        stacker.bringToFront(self.$form);
                    } else {
                        self.button.turnOff();
                    }
                }
            }

            // register button in toolbox
            this.button = this.getAreaBroker().getToolbox().createEntry({
                control: 'comment',
                title: __('Leave a comment'),
                icon: 'tag',
                text: __('Comment')
            });

            //get access to controls
            this.button.on('render', function() {
                self.$button = self.button.getElement();
                self.$form = $(commentTpl()).appendTo(self.$button);
                self.$input = self.$button.find('[data-control="qti-comment-text"]');
                self.$cancel = self.$button.find('[data-control="qti-comment-cancel"]');
                self.$submit = self.$button.find('[data-control="qti-comment-send"]');

                stacker.autoBringToFront(self.$form);

                //hide the form without submit
                self.$cancel.on('click', function () {
                    hider.hide(self.$form);
                    self.button.turnOff();
                });

                //submit the comment, then hide the form
                self.$submit.on('click', function () {
                    var comment = self.$input.val();

                    if (comment) {
                        self.disable();
                        self.button.turnOff();

                        testRunner.getProxy()
                            .callTestAction('comment', {
                                comment: comment
                            })
                            .then(function () {
                                hider.hide(self.$form);
                                self.enable();
                            })
                            .catch(function () {
                                hider.hide(self.$form);
                                self.enable();
                            });
                    }
                });
            });


            //attach behavior
            this.button.on('click', function (e) {
                //prevent action if the click is made inside the form which is a sub part of the button
                if ($(e.target).closest('[data-control="qti-comment"]').length) {
                    return;
                }

                e.preventDefault();
                testRunner.trigger('tool-comment');
            });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger('tool-comment');
                    }, {
                        avoidInput: true
                    });
                }
            }

            //start disabled
            togglePlugin();
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', togglePlugin)
                .on('renderitem enabletools', function () {
                    self.enable();
                })
                .on('unloaditem disabletools', function () {
                    self.disable();
                })
                .on('tool-comment', function () {
                    if (isEnabled()) {
                        toggleComment();
                    }
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + this.getName());
        },

        /**
         * Enable the button
         */
        enable: function enable() {
            this.button.enable();
        },

        /**
         * Disable the button
         */
        disable: function disable() {
            if (this.$form) {
                hider.hide(this.$form);
            }
            this.button.disable();
            this.button.turnOff();
        },

        /**
         * Show the button
         */
        show: function show() {
            this.button.show();
        },

        /**
         * Hide the button
         */
        hide: function hide() {
            if (this.$form) {
                hider.hide(this.$form);
            }
            this.button.hide();
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/tools/documentViewer/panel', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"document-viewer-plugin hidden\">\n    <div class=\"viewer-overlay\"></div>\n    <div class=\"viewer-panel\">\n        <div class=\"viewer-header\">\n            <span class=\"viewer-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n            <span class=\"icon icon-close\"></span>\n        </div>\n        <div class=\"viewer-content\">";
  if (helper = helpers.content) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.content); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n        <div class=\"viewer-footer\"></div>\n    </div>\n</div>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Tool Plugin : View a document
 *
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/tools/documentViewer/documentViewer',[
    'jquery',
    'lodash',
    'ui/hider',
    'ui/documentViewer',
    'ui/documentViewer/providers/pdfViewer',
    'taoTests/runner/plugin',
    'tpl!taoQtiTest/runner/plugins/tools/documentViewer/panel'
], function ($, _, hider, viewerFactory, pdfViewer, pluginFactory, panelTpl) {
    'use strict';

    /**
     * The name of the plugin
     * @type {String}
     */
    var pluginName = 'documentViewer';

    /**
     * Shows the panel, trigger the `panelshow` event
     *
     * @param plugin
     */
    function showPanel(plugin) {
        hider.show(plugin.controls.$panel);
        plugin.trigger('panelshow');
        $(window).on('resize.' + plugin.getName(), _.debounce(_.partial(resizeViewer, plugin), 50));
    }

    /**
     * Hides the panel, trigger the `panelhide` event
     *
     * @param plugin
     */
    function hidePanel(plugin) {
        hider.hide(plugin.controls.$panel);
        plugin.trigger('panelhide');
        $(window).off('resize.' + plugin.getName());
    }

    /**
     * Hides the panel if it is visible
     *
     * @param plugin
     * @returns {Boolean} Returns `true` if the panel was visible and has been hidden
     */
    function hideIfVisible(plugin) {
        var isVisible = !hider.isHidden(plugin.controls.$panel, true);
        if (isVisible) {
            hidePanel(plugin);
        }
        return isVisible;
    }

    /**
     * Initializes the event handlers for the panel container
     *
     * @param plugin
     */
    function initPanelEvents(plugin) {
        var namespace = '.' + plugin.getName();
        var stopEvents = ['click', 'mousedown', 'mouseup', 'touchstart', 'touchend', 'keyup', 'keydow', 'keypress', 'scroll', 'drop'].join(namespace + ' ') + namespace;
        var hideViewer = _.partial(hidePanel, plugin);

        function stopPropagation(e) {
            e.stopImmediatePropagation();
            e.stopPropagation();
        }

        plugin.controls.$overlay
            .off(namespace)
            .on('click' + namespace, hideViewer)
            .on(stopEvents, stopPropagation);

        plugin.controls.$panel
            .off(namespace)
            .on('click' + namespace, '.icon-close', hideViewer)
            .on(stopEvents, stopPropagation);
    }

    /**
     * Resizes the viewer to fit the panel content area
     * @param plugin
     */
    function resizeViewer(plugin) {
        var $content = plugin.controls.$content;
        plugin.viewer.setSize($content.width(), $content.height());
    }

    // all document viewers need to be registered
    viewerFactory.registerProvider('pdf', pdfViewer);

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: pluginName,

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;
            var testRunner = this.getTestRunner();
            var $panel = $(panelTpl());

            /**
             * @param {Object} data
             * @param {String} data.label - document title
             * @param {String} data.document - document url
             */
            function displayViewer(data) {
                if (self.getState('enabled') !== false) {
                    showPanel(self);
                    self.controls.$title.text(data.label);
                    resizeViewer(self);
                    self.viewer.load(data.document, 'pdf');
                }
            }

            this.controls = {
                $panel: $panel,
                $overlay: $panel.find('.viewer-overlay'),
                $title: $panel.find('.viewer-title'),
                $content: $panel.find('.viewer-content')
            };

            this.viewer = viewerFactory({
                renderTo: this.controls.$content,
                replace: true,
                fitToWidth: true,
                allowSearch: true
            });

            //update plugin state based on changes
            testRunner
                .on('renderitem enabletools', function () {
                    self.enable();
                })
                .on('renderitem', function () {
                    self.getAreaBroker().getContentArea()
                        .append(self.controls.$panel)
                        .off('.' + self.getName())
                        .on('viewDocument.' + self.getName(), function (event) {
                            var data = event.originalEvent.detail;
                            displayViewer(data);
                        });
                    initPanelEvents(self);
                })
                .on('move', function () {
                    hideIfVisible(self);
                })
                .on('skip', function () {
                    hideIfVisible(self);
                })
                .on('unloaditem disabletools', function () {
                    self.disable();
                })
                .on('tool-documentViewer', function(data) {
                    displayViewer(data);
                });
        },

        /**
         * Called during the runner's render phase
         */
        render: function render() {
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            this.getAreaBroker().getContentArea().off('.' + this.getName());

            if (this.viewer) {
                this.viewer.destroy();
            }

            if (this.controls.$panel) {
                this.controls.$panel.remove();
            }

            this.viewer = null;
            this.controls = {};
        },

        /**
         * Enable the button
         */
        enable: function enable() {
        },

        /**
         * Disable the button
         */
        disable: function disable() {
            hideIfVisible(this);
        },

        /**
         * Show the button
         */
        show: function show() {
        },

        /**
         * Hide the button
         */
        hide: function hide() {
            hideIfVisible(this);
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA;
 */
/**
 * This plugin allows the test taker to select text inside an item.
 * Highlight is preserved when navigating between items
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/highlighter/highlighter',[
    'lodash',
    'jquery',
    'ui/highlighter'
], function (
    _,
    $,
    highlighterFactory
) {
    'use strict';
    var selection;

    if (!window.getSelection) throw new Error('Browser does not support getSelection()');

    selection = window.getSelection();

    /**
     * Returns an array of active ranges.
     * If browser doesn't support multiple Ranges, returns only the first range
     * see note on https://w3c.github.io/selection-api/#methods
     *
     * @returns {Range[]}
     */
    function getAllRanges() {
        var i, allRanges = [];

        for (i = 0; i < selection.rangeCount; i++) {
            allRanges.push(selection.getRangeAt(i));
        }
        return allRanges;
    }

    /**
     * The highlighter Factory
     */
    return function(testRunner) {

        /**
         * Are we in highlight mode, meaning that each new selection is automatically highlighted
         * without having to press any button
         * @type {boolean}
         */
        var isHighlighting = false;

        /**
         * Store, for each item, an array containing the its highlight index
         * @type {Object}
         */
        var itemsHighlights = {};

        /**
         * The helper that does the highlight magic
         */
        var highlightHelper = highlighterFactory({
            className: 'txt-user-highlight',
            containerSelector: '.qti-itemBody'
        });

        // add event to automatically highlight the recently made selection if needed
        $(document).on('mouseup.highlighter', function() {
            if (isHighlighting && !selection.isCollapsed) {
                highlightHelper.highlightRanges(getAllRanges());
                selection.removeAllRanges();
            }
        });

        /**
         * The highlighter instance
         */
        return {
            /**
             * toggle highlighting mode on and off
             * @param {Boolean} bool - wanted state
             */
            toggleHighlighting: function toggleHighlighting(bool) {
                isHighlighting = bool;
                if (isHighlighting) {
                    testRunner.trigger('plugin-start.highlighter');
                } else {
                    testRunner.trigger('plugin-end.highlighter');
                }
            },

            /**
             * Either highlight the current or selection, or toggle highlighting mode
             */
            trigger: function trigger() {
                if (!isHighlighting) {
                    if (!selection.isCollapsed) {
                        testRunner.trigger('plugin-start.highlighter');
                        highlightHelper.highlightRanges(getAllRanges());
                        testRunner.trigger('plugin-end.highlighter');
                        selection.removeAllRanges();
                    } else {
                        this.toggleHighlighting(true);
                    }
                } else {
                    this.toggleHighlighting(false);
                }
            },

            /**
             * save the highlight index for the current item
             * @param itemId
             */
            saveHighlight: function saveHighlight(itemId) {
                var index = highlightHelper.getHighlightIndex();
                if (index && index.length > 0) {
                    itemsHighlights[itemId] = index;
                }
            },


            /**
             * restore the highlight index on the current item
             * @param itemId
             */
            restoreHighlight: function restoreHighlight(itemId) {
                var index = itemsHighlights[itemId];
                if (index && index.length > 0) {
                    highlightHelper.highlightFromIndex(index);
                }
            },

            /**
             * remove all highlights
             */
            clearHighlights: function clearHighlights() {
                highlightHelper.clearHighlights();
                selection.removeAllRanges();
            }
        };
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Tool Plugin : Text Highlighter
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/highlighter/plugin',[
    'jquery',
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoQtiTest/runner/plugins/tools/highlighter/highlighter'
], function ($, _, __, pluginFactory, hider, shortcut, namespaceHelper, highlighterFactory) {
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: 'highlighter',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;

            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};

            var highlighter = highlighterFactory(testRunner);

            // create buttons
            this.buttonMain = this.getAreaBroker().getToolbox().createEntry({
                title: __('Highlight Text'),
                icon: 'text-marker',
                control: 'highlight-trigger',
                text: __('Highlight')
            });

            this.buttonRemove = this.getAreaBroker().getToolbox().createEntry({
                title: __('Clear all active highlights'),
                icon: 'result-nok',
                control: 'highlight-clear',
                text: __('Clear Highlights')
            });

            // attach user events
            this.buttonMain
                .on('mousedown', function(e) { // using 'mousedown' instead of 'click' to avoid losing current selection
                    e.preventDefault();
                    testRunner.trigger('tool-highlight');
                });

            this.buttonRemove
                .on('click', function(e) {
                    e.preventDefault();
                    testRunner.trigger('tool-highlight-remove');
                });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger('tool-highlight');
                    }, { avoidInput: true, prevent: true });
                }
            }

            //start disabled
            this.disable();

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isEnabled() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};
                //to be activated with the special category x-tao-option-highlighter
                return !!options.highlighter;
            }

            /**
             * Is plugin activated ? if not, then we hide the plugin
             */
            function togglePlugin() {
                if (isEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }

            //update plugin state based on changes
            testRunner
                .on('loaditem', togglePlugin)
                .on('enabletools renderitem', function () {
                    self.enable();
                })
                .on('renderitem', function() {
                    var testContext = testRunner.getTestContext();
                    if(isEnabled()){
                        highlighter.restoreHighlight(testContext.itemIdentifier);
                    }
                })
                .on('beforeunloaditem', function() {
                    var testContext = testRunner.getTestContext();
                    if(isEnabled()){
                        highlighter.saveHighlight(testContext.itemIdentifier);
                    }
                })
                .on('disabletools unloaditem', function () {
                    self.disable();
                    highlighter.toggleHighlighting(false);
                })
                .on('tool-highlight', function () {
                    if (isEnabled()) {
                        highlighter.trigger();
                    }
                })
                .on('tool-highlight-remove', function () {
                    highlighter.clearHighlights();
                })
                .on('plugin-start.highlighter', function() {
                    self.buttonMain.turnOn();
                })
                .on('plugin-end.highlighter', function() {
                    self.buttonMain.turnOff();
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + this.getName());
            $(document).off('.highlighter');
        },

        /**
         * Enable the button
         */
        enable: function enable() {
            this.buttonMain.enable();
            this.buttonRemove.enable();
        },

        /**
         * Disable the button
         */
        disable: function disable() {
            this.buttonMain.disable();
            this.buttonRemove.disable();
        },

        /**
         * Show the button
         */
        show: function show() {
            this.buttonMain.show();
            this.buttonRemove.show();
        },

        /**
         * Hide the button
         */
        hide: function hide() {
            this.buttonMain.hide();
            this.buttonRemove.hide();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Tool Plugin : item Theme Switcher
 *
 * @author
 */
define('taoQtiTest/runner/plugins/tools/itemThemeSwitcher/itemThemeSwitcher',[
    'jquery',
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'ui/hider',
    'ui/themes',
    'util/shortcut',
    'util/namespace'
], function ($, _, __, pluginFactory, hider, themeHandler, shortcut, namespaceHelper) {
    'use strict';

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: 'itemThemeSwitcher',

        /**
         * Install step, add behavior before the lifecycle.
         */
        install: function install() {
            //define the "itemThemeSwitcher" store as "volatile" (removed on browser change).
            this.getTestRunner().getTestStore().setVolatile(this.getName());
        },

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;
            var pluginName = this.getName();
            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};
            var themesConfig = themeHandler.get('items') || {};
            var state = {
                availableThemes: [],
                defaultTheme: '',
                selectedTheme: ''
            };
            var allMenuEntries = [];

            /**
             * Load the selected theme
             * @param themeId
             */
            function changeTheme(themeId) {
                var $qtiItem = $('.qti-item');
                var previousTheme = state.selectedTheme;
                state.selectedTheme = themeId;

                if ($qtiItem) {
                    _.defer(function(){
                        $qtiItem.trigger('themechange', [state.selectedTheme]);
                    });
                }
                if (self.storage) {
                    self.storage.setItem('itemThemeId', themeId);
                }

                if (previousTheme !== state.selectedTheme) {
                    testRunner.trigger('themechange', state.selectedTheme, previousTheme);
                }

                allMenuEntries.forEach(function (menuEntry) {
                    if (menuEntry.getId() === themeId) {
                        menuEntry.turnOn();
                    } else {
                        menuEntry.turnOff();
                    }
                });
            }

            //init plugin state
            if (themesConfig) {
                if (themesConfig.default) {
                    state.defaultTheme = themesConfig.default;
                    state.selectedTheme = themesConfig.default;
                }
                if (themesConfig.available) {
                    _.forEach(themesConfig.available, function (theme) {
                        state.availableThemes.push({
                            id: theme.id,
                            label: theme.name
                        });
                    });
                }
            }

            // register toolbox button
            this.menuButton = this.getAreaBroker().getToolbox().createMenu({
                control: 'color-contrast',
                title: __('Change the current color preset'),
                icon: 'contrast',
                text: __('Contrast')
            }).on('click', function (e) {
                e.preventDefault();
                testRunner.trigger('tool-themeswitcher-toggle');
            }).on('openmenu', function() {
                testRunner.trigger('plugin-open.' + pluginName, state.selectedTheme);
            }).on('closemenu', function() {
                testRunner.trigger('plugin-close.' + pluginName, state.selectedTheme);
            });

            // register menu entries
            state.availableThemes.forEach(function (theme) {
                var themeEntry = self.getAreaBroker().getToolbox().createEntry({
                    control: theme.id,
                    title: theme.label,
                    icon: 'preview',
                    text: __(theme.label)
                });

                themeEntry.setMenuId('color-contrast');

                themeEntry.on('click', function(e) {
                    var themeId = this.config.control;
                    e.preventDefault();

                    self.menuButton.turnOffAll();
                    this.turnOn();

                    changeTheme(themeId);
                });

                if (state.defaultTheme === theme.id) {
                    themeEntry.on('render', function() {
                        this.turnOn();
                    });
                }
                allMenuEntries.push(themeEntry);
            });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger('tool-themeswitcher-toggle');
                    }, {
                        avoidInput: true
                    });
                }
            }

            //start disabled
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', function() {
                    self.show();
                })
                .on('renderitem', function () {
                    self.enable();
                    changeTheme(state.selectedTheme);
                })
                .on('enabletools', function() {
                    self.enable();
                })
                .on('disabletools unloaditem', function () {
                    self.disable();
                })
                .on('tool-themeswitcher-toggle', function () {
                    if (self.getState('enabled') !== false) {
                        self.menuButton.toggleMenu();
                    }
                });

            return testRunner.getPluginStore(this.getName())
                .then(function (itemThemesStore) {
                    self.storage = itemThemesStore;
                    self.storage.getItem('itemThemeId')
                        .then(function (itemThemeId) {
                            if (itemThemeId && state.selectedTheme !== itemThemeId) {
                                changeTheme(itemThemeId);
                            }
                        });
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + this.getName());
        },

        /**
         * Enable the button
         */
        enable: function enable() {
            this.menuButton.enable();
        },

        /**
         * Disable the button
         */
        disable: function disable() {
            this.menuButton.disable();

        },

        /**
         * Show the button
         */
        show: function show() {
            this.menuButton.show();
        },

        /**
         * Hide the button
         */
        hide: function hide() {
            this.menuButton.hide();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */
/**
 * A compound mask is a mask built with multiple ui/components that interacts with each other.
 * The compound mask itself is not a ui/component but mimic most of its API.
 *
 * Most mask transformations (resize, drag) are achieved by updating a very simple transform model (position, dimensions)
 * which is latter applied to the actual individual components at a proper time
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/lineReader/compoundMask',[
    'jquery',
    'lodash',
    'core/statifier',
    'core/eventifier',
    'ui/component',
    'ui/component/placeable',
    'ui/component/draggable',
    'ui/component/resizable',
    'ui/component/stackable'
], function(
    $,
    _,
    statifier,
    eventifier,
    componentFactory,
    makePlaceable,
    makeDraggable,
    makeResizable,
    makeStackable
) {
    'use strict';

    var defaultDimensions = {
        outerWidth:  600,
        outerHeight: 400,
        innerWidth:  500,
        innerHeight: 20
    };
    var defaultPosition = {
        outerX: 0,
        outerY: 0,
        innerX: 50,
        innerY: 50
    };
    var defaultOptions = {
        dragMinWidth: 10,
        dragMinHeight: 10,
        resizeHandleSize: 10,
        innerDragHeight: 20
    };
    var stackingOptions = {
        stackingScope: 'test-runner'
    };
    var constrains;

    /**
     * @param {Object} options
     * @param {Number} options.resizeHandleSize - size of the resize handlers on each resizable edge
     * @param {Number} options.dragMinWidth - minimal width for the draggable area of each component.
     * @param {Number} options.dragMinHeight - minimal height for the draggable area of each component.
     * @param {Number} options.innerDragHeight - height of the inner window drag handle
     * @param {Object} dimensions
     * @param {Number} dimensions.outerWidth - overall mask width
     * @param {Number} dimensions.outerHeight - overall mask height
     * @param {Number} dimensions.innerWidth - inner window width
     * @param {Number} dimensions.innerHeight - inner window height
     * @param {Number} position
     * @param {Number} position.outerX - overall mask x
     * @param {Number} position.outerY - overall mask y
     * @param {Number} position.innerX - inner window mask x
     * @param {Number} position.innerY - inner window mask y
     */
    return function compoundMaskFactory(options, dimensions, position) {
        var compoundMask,
            allParts = {},
            innerDrag,
            closer,
            visualGuides = {};

        /**
         * ============================================
         * Definition of Mask & Overlay component types
         * ============================================
         */

        /**
         * Create a mask component. They are used for masking (obviously) but also resizing the compound mask
         * @param {Object} maskConfig
         * @param {String} maskConfig.id
         * @param {Function} maskConfig.place - size and position the mask according to the transform model
         * @param {Function} maskConfig.placeOverlay - size and position the overlay according to the transform model
         * @param {Function} maskConfig.beforeResize - used to set the resize limit depending on which edge the resizing occurs
         * @param {Function} maskConfig.onResize - how the resize affect the transform model
         * @param {Object} maskConfig.edges - Interact configuration to specify which edges can be used for resizing
         * @param {Number} maskConfig.minWidth
         * @param {Number} maskConfig.minHeight
         */
        function createMask(maskConfig) {
            var mask,
                maskAPI = {
                    place: maskConfig.place,
                    placeOverlay: maskConfig.placeOverlay,

                    styleResizableEdges: function styleResizableEdges() {
                        var $element = this.getElement();
                        _.forOwn(this.config.edges, function (isResizable, edgeId) {
                            if (isResizable) {
                                $element.addClass('border-' + edgeId);
                            }
                        });
                    }
                };

            mask = componentFactory(maskAPI, maskConfig);
            makeResizable(mask);
            makeStackable(mask, stackingOptions);

            return mask
                .on('render', function() {
                    var $element = this.getElement();

                    this.styleResizableEdges();

                    $element
                        .addClass('line-reader-mask ' + maskConfig.id)
                        .on('mousedown', function() {
                            bringAllToFront();
                        });

                    // uncomment this to see what's going on with masks:
                    // $element.css({ border: '1px solid olive'});
                })
                .on('resizestart', function () {
                    innerDrag.hide();
                    closer.hide();
                    invokeOnOverlays('hide');
                    invokeOnMasks('setState', ['resizing', true]);
                })
                .on('beforeresize', maskConfig.beforeResize || _.noop)
                .on('resize', maskConfig.onResize || _.noop)
                .on('resizeend', function () {
                    applyTransformsToOverlays();
                    applyTransformsToInnerDrag();
                    applyTransformsToCloser();

                    invokeOnMasks('setState', ['resizing', false]);
                    invokeOnOverlays('show');
                    innerDrag.show();
                    closer.show();
                })
                .init();
        }


        /**
         * Create a overlay component. Overlay are invisible and are used for dragging.
         * When clicked, the whole mask is hidden and only the overlay is displayed, after being resized to fit the whole mask surface
         * this allows for performance improvement as well as giving the dragged element proper dragging boundaries.
         * Also, visual guides are added, like a fake inner window, during the drag
         * @param {Object} overlayConfig
         * @param {String} overlayConfig.id
         */
        function createOverlay(overlayConfig) {
            var overlay,
                overlayAPI = {
                    transformOverlay: function transformOverlay() {
                        var $element = this.getElement();

                        this._sizeBackup = this.getSize();
                        this._posBackup = this.getPosition();

                        this.setSize(dimensions.outerWidth, dimensions.outerHeight)
                            .moveTo(position.outerX, position.outerY);
                        $element.addClass('moving');

                        this.setState('transformed', true);
                    },

                    restoreOverlay: function restoreOverlay() {
                        var $element = this.getElement();

                        if (this.is('transformed')) {

                            this.setSize(this._sizeBackup.width, this._sizeBackup.height)
                                .moveTo(this._posBackup.x, this._posBackup.y);
                            $element.removeClass('moving');

                            this._sizeBackup = null;
                            this._posBackup = null;

                            this.setState('transformed', false);
                        }
                    },

                    appendVisualGuides: function appendVisualGuides() {
                        var $element = this.getElement(),
                            borderWidth = 1, // this mirror the $lrBorderWidth css variable
                            borderOffset = borderWidth * 2;

                        $element.append(visualGuides.$maskBg);
                        $element.append(visualGuides.$innerWindow);

                        visualGuides.$maskBg.css({
                            width:  dimensions.outerWidth - borderOffset,
                            height: dimensions.outerHeight - borderOffset,
                            'border-top-width':     dimensions.topHeight - borderOffset,
                            'border-right-width':   dimensions.rightWidth - borderOffset,
                            'border-bottom-width':  dimensions.bottomHeight - borderOffset,
                            'border-left-width':    dimensions.leftWidth - borderOffset
                        });

                        visualGuides.$innerWindow.css({
                            width:  dimensions.innerWidth,
                            height: dimensions.innerHeight,
                            left:   dimensions.leftWidth - borderOffset,
                            top:    dimensions.topHeight - borderOffset
                        });
                    },

                    removeVisualGuides: function removeVisualGuides() {
                        visualGuides.$maskBg.remove();
                        visualGuides.$innerWindow.remove();
                    }
                };

            overlay = componentFactory(overlayAPI, overlayConfig);
            makeDraggable(overlay);
            makeStackable(overlay, stackingOptions);

            return overlay
                .on('render', function() {
                    var self = this,
                        $element = this.getElement(),
                        // captures touch and mouse
                        // also fixes issue with IE not capturing 'mousedown' etc
                        pointerEventsPrefix = window.PointerEvent ? 'pointer' : 'mouse';


                    $element
                        .addClass('line-reader-overlay ' + overlayConfig.id)
                        .on(pointerEventsPrefix + 'down', function() {
                            bringAllToFront();
                            self.transformOverlay();
                        })
                        .on(pointerEventsPrefix + 'up', function() {
                            self.restoreOverlay();
                        });

                    // uncomment this to see what's going on with overlays:
                    // $element.css({ opacity: 0.5, 'background-color': 'yellow', border: '1px solid brown '});
                })
                .on('dragstart', function() {
                    innerDrag.hide();
                    closer.hide();
                    invokeOnMasks('hide');
                    this.appendVisualGuides();
                })
                .on('dragmove', function moveAllPartsTogether(xOffsetRelative, yOffsetRelative) {
                    // update the transform model
                    position.outerX += xOffsetRelative;
                    position.outerY += yOffsetRelative;
                    position.innerX += xOffsetRelative;
                    position.innerY += yOffsetRelative;
                })
                .on('dragend', function() {
                    this.removeVisualGuides();
                    // although they are already display, calling show() again on the overlays
                    // will force their z-Index at the top of the stack
                    invokeOnAll('show');
                    innerDrag.show();
                    closer.show();

                    // apply the new transform model
                    applyTransforms();
                })
                .init();
        }


        /**
         * ==========================
         * Inner Drag Handle & Closer
         * ==========================
         */

        /**
         * This handle allows to drag the inner window
         */
        function createInnerDragHandle() {
            // uncomment this (and a few lines below) if debugging is needed:
            // var $boundingBox = $('<div>').css({ position: 'fixed', 'box-sizing': 'border-box', border: '1px solid red' });

            innerDrag = componentFactory();

            makeStackable(innerDrag, stackingOptions);
            makeDraggable(innerDrag, {
                dragRestriction: function dragRestriction() {
                    var fixedXY = allParts.nw.mask.getElement().offset(),
                        rect;

                    rect = {
                        x: fixedXY.left + constrains.minWidth,
                        y: fixedXY.top + (constrains.minHeight + dimensions.innerHeight + options.resizeHandleSize),
                        width: dimensions.outerWidth - (constrains.minWidth * 2 ),
                        height: dimensions.outerHeight -
                            (dimensions.innerHeight + constrains.minHeight + constrains.minBottomHeight - options.innerDragHeight)
                    };

                    // uncomment to see what's going on:
                    // allParts.ne.mask.getContainer().append($boundingBox);
                    // $boundingBox.css({ width: rect.width, height: rect.height, top: rect.y, left: rect.x });

                    return rect;
                }
            })
                .on('render', function() {
                    var $element = this.getElement(),
                        $dragIcon = $('<div>', {
                            'class': 'icon icon-move'
                        });

                    $element.addClass('line-reader-inner-drag');
                    $element.append($dragIcon);
                    $element.on('mousedown', function(e) {
                        e.stopPropagation();
                        bringAllToFront();
                    });
                })
                .on('dragstart', function() {
                    closer.hide();
                    invokeOnOverlays('hide');
                    invokeOnMasks('setState', ['resizing', true]);
                })
                .on('dragmove', function(xOffsetRelative, yOffsetRelative) {
                    position.innerX += xOffsetRelative;
                    position.innerY += yOffsetRelative;

                    dimensions.leftWidth += xOffsetRelative;
                    dimensions.topHeight += yOffsetRelative;

                    dimensions.rightWidth   -= xOffsetRelative;
                    dimensions.bottomHeight -= yOffsetRelative;

                    applyTransformsToMasks();
                })
                .on('dragend', function() {
                    invokeOnOverlays('show');
                    innerDrag.bringToFront();
                    closer.show();
                    invokeOnMasks('setState', ['resizing', false]);

                    applyTransformsToOverlays();
                })
                .init();
        }

        /**
         * Close button for the compound mask
         */
        function createCloser() {
            closer = componentFactory();

            makeStackable(closer, stackingOptions);
            makePlaceable(closer)
                .on('render', function() {
                    var self = this,
                        $element = this.getElement(),
                        $closeIcon = $('<div>', {
                            'class': 'icon icon-result-nok'
                        });

                    $element.append($closeIcon);
                    $element.addClass('line-reader-closer');

                    $element.on('mousedown', function() {
                        bringAllToFront();
                    });

                    $element.on('click', function(e) {
                        e.stopPropagation();
                        self.trigger('click');
                    });
                })
                .init();
        }

        /**
         * =================
         * Utility functions
         * =================
         */
        function bringAllToFront() {
            invokeOnAll('bringToFront');
            innerDrag.bringToFront();
            closer.bringToFront();
        }

        function invokeOnAll(fn, args) {
            invokeOnMasks(fn, args);
            invokeOnOverlays(fn, args);
        }

        function invokeOnMasks(fn, args) {
            invokeOn('mask', fn, args);
        }

        function invokeOnOverlays(fn, args) {
            invokeOn('overlay', fn, args);
        }

        /**
         * Invoke a method on all compound mask parts, whether mask or overlays
         * @param {String} target - mask | overlay
         * @param {String} fn - the name of the method to invoke
         * @param {*[]} args - arguments passed on invoke
         */
        function invokeOn(target, fn, args) {
            _.forOwn(allParts, function(part) {
                if (_.isObject(part[target]) && _.isFunction(part[target][fn])) {
                    part[target][fn].apply(part[target], args);
                }
            });
        }

        /**
         * =================================
         * Transform model related functions
         * =================================
         */

        function applyTransforms() {
            applyTransformsToMasks();
            applyTransformsToOverlays();
            applyTransformsToInnerDrag();
            applyTransformsToCloser();
        }

        function applyTransformsToMasks() {
            invokeOnMasks('place');
        }

        function applyTransformsToOverlays() {
            _.forOwn(allParts, function(part) {
                part.mask.placeOverlay(part.overlay);
            });
        }

        function applyTransformsToInnerDrag() {
            if (innerDrag) {
                innerDrag
                    .setSize(dimensions.innerWidth, options.innerDragHeight)
                    .moveTo(
                        position.innerX,
                        position.innerY + dimensions.innerHeight + options.resizeHandleSize
                    );
            }
        }

        function applyTransformsToCloser() {
            if (closer) {
                closer
                    .setSize(
                        constrains.minWidth - options.resizeHandleSize,
                        constrains.minHeight - options.resizeHandleSize
                    )
                    .moveTo(
                        position.outerX + dimensions.outerWidth - constrains.minWidth + 3, // manual adjustment so it looks better
                        position.outerY + options.resizeHandleSize
                    );
            }
        }

        /**
         * Check that the given transform model respect the current constrains.
         * If not, correct them
         */
        function correctTransforms() {
            if (dimensions.topHeight < constrains.minHeight) {
                dimensions.topHeight = constrains.minHeight;
                position.innerY = position.outerY + constrains.minHeight;
            }
            if (dimensions.innerHeight < constrains.minHeight) {
                dimensions.innerHeight = constrains.minHeight;
            }
            if (dimensions.bottomHeight < constrains.minBottomHeight) {
                dimensions.bottomHeight = constrains.minBottomHeight;
            }
            dimensions.outerHeight = dimensions.topHeight + dimensions.innerHeight + dimensions.bottomHeight;

            if (dimensions.leftWidth < constrains.minWidth) {
                dimensions.leftWidth = constrains.minWidth;
                position.innerX = position.outerX + constrains.minWidth;
            }
            if (dimensions.innerWidth < constrains.minWidth) {
                dimensions.innerWidth = constrains.minWidth;
            }
            if (dimensions.rightWidth < constrains.minWidth) {
                dimensions.rightWidth = constrains.minWidth;
            }
            dimensions.outerWidth = dimensions.leftWidth + dimensions.innerWidth + dimensions.rightWidth;
        }

        /**
         * Update the transform model during a resize affecting the top height
         * @param {Number} newHeight
         * @param {Number} newY
         * @param {Boolean} fromTop - if the resize occurs from the top
         */
        function setTopHeight(newHeight, newY, fromTop) {
            dimensions.topHeight = newHeight;

            if (fromTop) {
                dimensions.outerHeight = newHeight + dimensions.innerHeight + dimensions.bottomHeight;
                position.outerY = newY;
            } else {
                dimensions.innerHeight = dimensions.outerHeight - newHeight - dimensions.bottomHeight;
                position.innerY = position.outerY + newHeight;
            }
        }

        /**
         * Update the transform model during a resize affecting the right width
         * @param {Number} newWidth
         * @param {Number} newX
         * @param {Boolean} fromLeft - if the resize occurs from the left
         */
        function setRightWidth(newWidth, newX, fromLeft) {
            dimensions.rightWidth = newWidth;

            if (fromLeft) {
                dimensions.innerWidth = newX - position.innerX;
            } else {
                dimensions.outerWidth = dimensions.leftWidth + dimensions.innerWidth + newWidth;
            }
        }

        /**
         * Update the transform model during a resize affecting the bottom height
         * @param {Number} newHeight
         * @param {Number} newY
         * @param {Boolean} fromTop - if the resize occurs from the top
         */
        function setBottomHeight(newHeight, newY, fromTop) {
            dimensions.bottomHeight = newHeight;

            if (fromTop) {
                dimensions.innerHeight = newY - position.innerY;
                dimensions.bottomHeight = newHeight;
            } else {
                dimensions.outerHeight = dimensions.topHeight + dimensions.innerHeight + newHeight;
            }
        }

        /**
         * Update the transform model during a resize affecting the left width
         * @param {Number} newWidth
         * @param {Number} newX
         * @param {Boolean} fromLeft - if the resize occurs from the left
         */
        function setLeftWidth(newWidth, newX, fromLeft) {
            dimensions.leftWidth = newWidth;

            if (fromLeft) {
                dimensions.outerWidth = newWidth + dimensions.innerWidth + dimensions.rightWidth;
                position.outerX = newX;
            } else {
                dimensions.innerWidth = dimensions.outerWidth - newWidth - dimensions.rightWidth;
                position.innerX = position.outerX + newWidth;
            }
        }


        /**
         * ======================================
         * Mask parts and other elements creation
         * ======================================
         */

        function createCompoundMask() {

            // North
            createPart({
                id: 'n',
                edges: { top: true, right: false, bottom: true, left: false },

                // move and dimension the mask
                place: function place() {
                    this.moveTo(
                        position.innerX,
                        position.outerY
                    ).setSize(
                        dimensions.innerWidth,
                        dimensions.topHeight
                    );
                },

                // move and dimension the overlay
                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x,
                        pos.y + options.resizeHandleSize
                    ).setSize(
                        size.width,
                        size.height - (options.resizeHandleSize * 2)
                    );
                },

                // set a resize limit whenever resize happens on an inner edge (here, the top inner edge, eg. the bottom of the mask),
                // so the min/max width/height limit for "inner component" is respected
                beforeResize: function beforeResize(width, height, fromLeft, fromTop) {
                    this.config.maxHeight = (fromTop)
                        ? null
                        : dimensions.topHeight + (dimensions.innerHeight - constrains.minHeight);
                },

                // set the new transform values (dimension and position) resulting from the current mask resize, and apply them
                onResize: function onResize(width, height, fromLeft, fromTop, x, y) {
                    setTopHeight(height, y, fromTop);
                    applyTransformsToMasks();
                }
            });

            // North-east
            createPart({
                id: 'ne',
                edges: { top: true, right: true, bottom: false, left: false },

                place: function place() {
                    this.moveTo(
                        position.innerX + dimensions.innerWidth,
                        position.outerY
                    ).setSize(
                        dimensions.rightWidth,
                        dimensions.topHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x,
                        pos.y + options.resizeHandleSize
                    ).setSize(
                        size.width - options.resizeHandleSize,
                        size.height - (options.resizeHandleSize * 2)
                    );
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x, y) {
                    setTopHeight(height, y, fromTop);
                    setRightWidth(width, x, fromLeft);
                    applyTransformsToMasks();
                }
            });

            // East
            createPart({
                id: 'e',
                edges: { top: false, right: true, bottom: false, left: true },

                place: function place() {
                    this.moveTo(
                        position.innerX + dimensions.innerWidth,
                        position.innerY
                    ).setSize(
                        dimensions.rightWidth,
                        dimensions.innerHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x + options.resizeHandleSize,
                        pos.y - options.resizeHandleSize
                    ).setSize(
                        size.width - (options.resizeHandleSize * 2),
                        size.height + (options.resizeHandleSize * 2)
                    );
                },

                beforeResize: function beforeResize(width, height, fromLeft) {
                    this.config.maxWidth = (fromLeft)
                        ? dimensions.rightWidth + (dimensions.innerWidth - constrains.minWidth)
                        : null;
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x) {
                    setRightWidth(width, x, fromLeft);
                    applyTransformsToMasks();
                }
            });

            // South east
            createPart({
                id: 'se',
                edges: { top: false, right: true, bottom: true, left: false },
                minHeight: constrains.minBottomHeight,

                place: function place() {
                    this.moveTo(
                        position.innerX + dimensions.innerWidth,
                        position.innerY + dimensions.innerHeight
                    ).setSize(
                        dimensions.rightWidth,
                        dimensions.bottomHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x,
                        pos.y + options.resizeHandleSize
                    ).setSize(
                        size.width - options.resizeHandleSize,
                        size.height - (options.resizeHandleSize * 2)
                    );
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x, y) {
                    setRightWidth(width, x, fromLeft);
                    setBottomHeight(height, y, fromTop);
                    applyTransformsToMasks();
                }
            });

            // South
            createPart({
                id: 's',
                edges: { top: true, right: false, bottom: true, left: false },
                minHeight: constrains.minBottomHeight,

                place: function place() {
                    this.moveTo(
                        position.innerX ,
                        position.innerY + dimensions.innerHeight
                    ).setSize(
                        dimensions.innerWidth,
                        dimensions.bottomHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x,
                        pos.y + options.resizeHandleSize
                    ).setSize(
                        size.width,
                        size.height - (options.resizeHandleSize * 2)
                    );
                },

                beforeResize: function beforeResize(width, height, fromLeft, fromTop) {
                    this.config.maxHeight = (fromTop)
                        ? dimensions.bottomHeight + (dimensions.innerHeight - constrains.minHeight)
                        : null;
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x, y) {
                    setBottomHeight(height, y, fromTop);
                    applyTransformsToMasks();
                }
            });

            // South-west
            createPart({
                id: 'sw',
                edges: { top: false, right: false, bottom: true, left: true },
                minHeight: constrains.minBottomHeight,

                place: function place() {
                    this.moveTo(
                        position.outerX,
                        position.innerY + dimensions.innerHeight
                    ).setSize(
                        dimensions.leftWidth,
                        dimensions.bottomHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x + options.resizeHandleSize,
                        pos.y + options.resizeHandleSize
                    ).setSize(
                        size.width - options.resizeHandleSize,
                        size.height - (options.resizeHandleSize * 2)
                    );
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x, y) {
                    setBottomHeight(height, y, fromTop);
                    setLeftWidth(width, x, fromLeft);
                    applyTransformsToMasks();
                }
            });

            // West
            createPart({
                id: 'w',
                edges: { top: false, right: true, bottom: false, left: true },

                place: function place() {
                    this.moveTo(
                        position.outerX,
                        position.innerY
                    ).setSize(
                        dimensions.leftWidth,
                        dimensions.innerHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x + options.resizeHandleSize,
                        pos.y - options.resizeHandleSize
                    ).setSize(
                        size.width - (options.resizeHandleSize * 2),
                        size.height + (options.resizeHandleSize * 2)
                    );
                },

                beforeResize: function beforeResize(width, height, fromLeft) {
                    this.config.maxWidth = (fromLeft)
                        ? null
                        : dimensions.leftWidth + (dimensions.innerWidth - constrains.minWidth);
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x) {
                    setLeftWidth(width, x, fromLeft);
                    applyTransformsToMasks();
                }
            });

            // North-west
            createPart({
                id: 'nw',
                edges: { top: true, right: false, bottom: false, left: true },

                place: function place() {
                    this.moveTo(
                        position.outerX,
                        position.outerY
                    ).setSize(
                        dimensions.leftWidth,
                        dimensions.topHeight
                    );
                },

                placeOverlay: function placeOverlay(overlay) {
                    var pos = this.getPosition(),
                        size = this.getSize();
                    overlay.moveTo(
                        pos.x + options.resizeHandleSize,
                        pos.y + options.resizeHandleSize
                    ).setSize(
                        size.width - options.resizeHandleSize,
                        size.height - (options.resizeHandleSize * 2)
                    );
                },

                onResize: function onResize(width, height, fromLeft, fromTop, x, y) {
                    setTopHeight(height, y, fromTop);
                    setLeftWidth(width, x, fromLeft);
                    applyTransformsToMasks();
                }
            });
        }

        function createPart(partConfig) {
            allParts[partConfig.id] = {
                mask: createMask(_.assign({}, constrains, partConfig)),
                overlay: createOverlay(partConfig)
            };
        }


        function createVisualGuides() {
            visualGuides.$maskBg = $('<div>', {
                'class': 'mask-bg'
            });
            visualGuides.$innerWindow = $('<div>', {
                'class': 'inner-window'
            });
        }


        /**
         * =========================
         * The compoundMask instance
         * =========================
         */

        dimensions  = _.defaults(dimensions || {}, defaultDimensions);
        position    = _.defaults(position   || {}, defaultPosition);
        options     = _.defaults(options    || {}, defaultOptions);

        constrains = {
            minWidth:           (options.resizeHandleSize * 2) + options.dragMinWidth,
            minHeight:          (options.resizeHandleSize * 2) + options.dragMinHeight,
            minBottomHeight:    (options.resizeHandleSize * 2) + options.innerDragHeight
        };

        compoundMask = {
            init: function init() {
                var self = this;

                this.setTransforms(dimensions, position);

                createCompoundMask();
                createVisualGuides();
                createInnerDragHandle();
                createCloser();

                closer.on('click', function() {
                    self.hide();
                    self.trigger('close');
                });

                return this;
            },

            render: function render($container) {
                invokeOnAll('render', [$container]);
                innerDrag.render($container);
                closer.render($container);
                applyTransforms();
                return this;
            },

            destroy: function destroy() {
                invokeOnAll('destroy');
                visualGuides = null;
                innerDrag = null;
                closer = null;
                return this;
            },

            show: function show() {
                invokeOnAll('show');
                innerDrag.show();
                closer.show();
                this.setState('hidden', false);
                return this;
            },

            hide: function hide() {
                invokeOnAll('hide');
                innerDrag.hide();
                closer.hide();
                this.setState('hidden', true);
                return this;
            },

            /**
             * Allow updating the transform model
             * @param {Object} dim
             * @param {Number} dim.outerWidth - overall mask width
             * @param {Number} dim.outerHeight - overall mask height
             * @param {Number} dim.innerWidth - inner window width
             * @param {Number} dim.innerHeight - inner window height
             * @param {Number} pos
             * @param {Number} pos.outerX - overall mask x
             * @param {Number} pos.outerY - overall mask y
             * @param {Number} pos.innerX - inner window x
             * @param {Number} pos.innerY - inner window y
             */
            setTransforms: function setTransforms(dim, pos) {
                dimensions  = _.defaults(dim || {}, dimensions);
                position    = _.defaults(pos || {}, position);

                // automatically complete the dimensions
                dimensions.topHeight    = pos.innerY - pos.outerY;
                dimensions.rightWidth   = dim.outerWidth - (pos.innerX - pos.outerX) - dim.innerWidth;
                dimensions.bottomHeight = dim.outerHeight - (pos.innerY - pos.outerY) - dim.innerHeight;
                dimensions.leftWidth    = pos.innerX - pos.outerX;

                correctTransforms();
                applyTransforms();
            },

            getDimensions: function getDimensions() {
                return dimensions;
            },

            getPosition: function getPosition() {
                return position;
            },

            getParts: function getParts() {
                return allParts;
            }
        };

        statifier(compoundMask);
        eventifier(compoundMask);

        return compoundMask;
    };
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */

/**
 * Test Runner Tool Plugin : Line Reader
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/runner/plugins/tools/lineReader/plugin',[
    'jquery',
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoQtiTest/runner/plugins/tools/lineReader/compoundMask'
], function ($, _, __, pluginFactory, hider, shortcut, namespaceHelper, compoundMaskFactory) {
    'use strict';

    /**
     * The public name of the plugin
     * @type {String}
     */
    var pluginName = 'line-reader';

    /**
     * The prefix of actions triggered through the event loop
     * @type {String}
     */
    var actionPrefix = 'tool-' + pluginName + '-';

    /**
     * Options for the compoundMask factory
     * @type {Object}
     */
    var maskOptions = {
        dragMinWidth: 7,
        dragMinHeight: 7,
        resizeHandleSize: 7,
        innerDragHeight: 20
    };

    var dimensions,
        position;

    /**
     * These functions are a first effort to place the mask on the first line on the item
     * They make a lot of assumptions:
     * - the item starts with a text
     * - the padding is set on the .qti-item container
     * - the padding is consistent with the minWidth/minHeight configuration of the mask
     * - and some other...
     * @param {jQuery} $container - where the mask is appended
     */
    function getDimensions($container) {
        var $qtiContent = $container.find('#qti-content'),
            $qtiItem = $qtiContent.find('.qti-item'),

            lineHeight = Math.ceil(parseFloat($qtiContent.css('line-height'))) || 20; // reasonable default line height

        return {
            outerWidth:     $qtiItem.width() + (maskOptions.resizeHandleSize * 4) + (maskOptions.dragMinWidth * 2),
            outerHeight:    175, // reasonable default height
            innerWidth:     $qtiItem.width(),
            innerHeight:    lineHeight
        };
    }
    function getPosition($container) {
        var $qtiContent = $container.find('#qti-content'),
            $qtiItem = $qtiContent.find('.qti-item'),

            itemPosition = $qtiItem.position() || {},

            paddingLeft = parseInt($qtiItem.css('padding-left'), 10),
            paddingTop = parseInt($qtiItem.css('padding-top'), 10),

            textPadding = 3, // this is to let the text breathe a bit

            innerX = parseInt(itemPosition.left, 10) + paddingLeft - textPadding,
            innerY = parseInt(itemPosition.top, 10) + paddingTop - textPadding;

        return {
            outerX: innerX - (maskOptions.resizeHandleSize * 2) - maskOptions.dragMinWidth,
            outerY: 0,
            innerX: innerX,
            innerY: innerY
        };
    }

    function containerWidthHasChanged($container) {
        var newDimensions = getDimensions($container);
        return newDimensions.outerWidth !== dimensions.outerWidth;
    }

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: pluginName,

        /**
         * Initialize the plugin (called during runner's init)
         */
        init: function init() {
            var self = this,

                testRunner = this.getTestRunner(),
                testData = testRunner.getTestData() || {},
                testConfig = testData.config || {},
                pluginShortcuts = (testConfig.shortcuts || {})[pluginName] || {},
                $container = testRunner.getAreaBroker().getContentArea().parent();

            this.compoundMask = compoundMaskFactory(maskOptions)
                .init()
                .render($container)
                .on('close', function() {
                    closeMask();
                })
                .hide();

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isEnabled() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};
                //to be activated with the special category x-tao-option-lineReader
                return !!options.lineReader;
            }

            function toggleButton() {
                if (isEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }

            function toggleMask() {
                if (self.compoundMask.getState('hidden')) {
                    if (containerWidthHasChanged($container)) {
                        transformMask($container);
                    }
                    openMask();
                } else {
                    closeMask();
                }
            }

            function openMask() {
                self.compoundMask.show();
                self.trigger('start');
                self.button.turnOn();
            }

            function closeMask() {
                if (! self.compoundMask.getState('hidden')) {
                    self.compoundMask.hide();
                }
                self.trigger('end');
                self.button.turnOff();
            }

            function transformMask($maskContainer) {
                dimensions = getDimensions($maskContainer);
                position = getPosition($maskContainer);
                self.compoundMask.setTransforms(
                    _.clone(dimensions),
                    _.clone(position)
                );
            }

            // create button
            this.button = this.getAreaBroker().getToolbox().createEntry({
                title: __('Line Reader'),
                icon: 'insert-horizontal-line',
                control: 'line-reader',
                text: __('Line Reader')
            });

            // attach user events
            this.button
                .on('click', function(e) {
                    e.preventDefault();
                    testRunner.trigger(actionPrefix + 'toggle');
                });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.toggle) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.toggle, this.getName(), true), function () {
                        testRunner.trigger(actionPrefix + 'toggle');
                    }, { avoidInput: true, prevent: true });
                }
            }

            //start disabled
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', toggleButton)
                .on('renderitem', function() {
                    transformMask($container);
                })
                .on('enabletools renderitem', function () {
                    self.enable();
                })
                .on('disabletools unloaditem', function () {
                    self.disable();
                    closeMask();
                })
                .on(actionPrefix + 'toggle', function () {
                    if (isEnabled()) {
                        toggleMask();
                    }
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            this.compoundMask.destroy();
            shortcut.remove('.' + this.getName());
        },

        /**
         * Enable the button
         */
        enable: function enable() {
            this.button.enable();
        },

        /**
         * Disable the button
         */
        disable: function disable() {
            this.button.disable();
        },

        /**
         * Show the button
         */
        show: function show() {
            this.button.show();
        },

        /**
         * Hide the button
         */
        hide: function hide() {
            this.button.hide();
        }
    });
});


define('tpl!taoQtiTest/runner/plugins/tools/magnifier/magnifierPanel', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<div class=\"magnifier\">\n    <div class=\"level\">";
  if (helper = helpers.level) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.level); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    <div class=\"overlay\"></div>\n    <div class=\"inner\"></div>\n    <div class=\"controls close\">\n        <a href=\"#\" class=\"closeMagnifier\" data-control=\"closeMagnifier\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Close Magnifier", options) : helperMissing.call(depth0, "__", "Close Magnifier", options)))
    + "\"><span class=\"icon-result-nok\"></span></a>\n    </div>\n    <div class=\"controls zoom\">\n        <a href=\"#\" class=\"control\"  data-control=\"zoomOut\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Magnify less", options) : helperMissing.call(depth0, "__", "Magnify less", options)))
    + "\"><span class=\"icon-remove\"></span></a>\n        <a href=\"#\" class=\"control\" data-control=\"zoomIn\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Magnify more", options) : helperMissing.call(depth0, "__", "Magnify more", options)))
    + "\"><span class=\"icon-add\"></span></a>\n    </div>\n</div>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/tools/magnifier/magnifierPanel',[
    'jquery',
    'lodash',
    'ui/movableComponent',
    'tpl!taoQtiTest/runner/plugins/tools/magnifier/magnifierPanel'
], function ($, _, movableComponent, magnifierPanelTpl) {
    'use strict';

    /**
     * The screen pixel ratio
     * @type {Number}
     */
    var screenRatio = window.screen.width / window.screen.height;

    /**
     * Standard debounce delay for heavy process
     * @type {Number}
     */
    var debounceDelay = 50;

    /**
     * Standard scrolling throttling for the scrolling
     * It can be lower than the debounce delay as it is lighter in process and it improves the user experience
     * @type {Number}
     */
    var scrollingDelay = 20;

    /**
     * The default base size
     * @type {Number}
     */
    var defaultBaseSize = 116;

    /**
     * The minimum zoom level
     * @type {Number}
     */
    var defaultLevelMin = 2;

    /**
     * The maximum zoom level
     * @type {Number}
     */
    var defaultLevelMax = 8;

    /**
     * The default zoom level
     * @type {Number}
     */
    var defaultLevel = defaultLevelMin;

    /**
     * Some default values
     * @type {Object}
     */
    var defaultConfig = {
        level: defaultLevel,
        levelMin: defaultLevelMin,
        levelMax: defaultLevelMax,
        levelStep: .5,
        baseSize: defaultBaseSize,
        width: defaultBaseSize * defaultLevel,
        height: defaultBaseSize * defaultLevel / screenRatio,
        minWidth: defaultBaseSize * defaultLevelMin,
        minHeight: defaultBaseSize * defaultLevelMin / screenRatio,
        maxRatio: .5,
        stackingScope: 'test-runner'
    };

    /**
     * Creates a magnifier panel component
     * @param {Object} config
     * @param {Number} [config.level] - The default zoom level
     * @param {Number} [config.levelMin] - The minimum allowed zoom level
     * @param {Number} [config.levelMax] - The maximum allowed zoom level
     * @param {Number} [config.levelStep] - The level increment applied when using the controls + and -
     * @param {Number} [config.baseSize] - The base size used to assign the width and the height according to the zoom level
     * @param {Number} [config.maxRatio] - The ratio for the maximum size regarding the size of the window
     * @returns {magnifierPanel} the component (initialized)
     */
    function magnifierPanelFactory(config) {
        var initConfig = _.defaults(config || {}, defaultConfig);
        var zoomLevelMin = parseFloat(initConfig.levelMin);
        var zoomLevelMax = parseFloat(initConfig.levelMax);
        var zoomLevelStep = parseFloat(initConfig.levelStep);
        var zoomLevel = adjustZoomLevel(initConfig.level);
        var maxRatio = parseFloat(initConfig.maxRatio);
        var baseSize = parseInt(initConfig.baseSize, 10);
        var zoomSize = baseSize * zoomLevel;
        var $initTarget = null;
        var controls = null;
        var observer = null;
        var targetWidth, targetHeight, dx, dy;
        var scrolling = [];

        /**
         * @typedef {Object} magnifierPanel
         */
        var magnifierPanel = movableComponent({
            /**
             * Gets the current zoom level
             * @returns {Number}
             */
            getZoomLevel: function getZoomLevel() {
                return zoomLevel;
            },

            /**
             * Gets the targeted content the magnifier will zoom
             * @returns {jQuery}
             */
            getTarget: function getTarget() {
                return controls && controls.$target;
            },

            /**
             * Sets the targeted content the magnifier will zoom
             * @param {jQuery} $newTarget
             * @returns {magnifierPanel}
             * @fires targetchange
             * @fires update
             */
            setTarget: function setTarget($newTarget) {
                if (controls) {
                    controls.$target = $newTarget;
                    controls.$viewTarget = null;

                    setScrollingListener();

                    /**
                     * @event magnifierPanel#targetchange
                     * @param {jQuery} $target
                     */
                    this.trigger('targetchange', controls.$target);

                    this.update();
                } else {
                    $initTarget = $newTarget;
                }

                return this;
            },

            /**
             * Sets the zoom level of the magnifier
             * @param {Number} level
             * @returns {magnifierPanel}
             * @fires zoom
             */
            zoomTo: function zoomTo(level) {
                if (level && _.isFinite(level)) {
                    zoomLevel = adjustZoomLevel(level);
                }

                applyZoomLevel();
                showZoomLevel();
                updateMaxSize();
                updateZoom();

                /**
                 * @event magnifierPanel#zoom
                 * @param {Number} zoomLevel
                 */
                this.trigger('zoom', zoomLevel);

                return this;
            },

            /**
             * Increments the zoom level of the magnifier
             * @param {Number} step
             * @returns {magnifierPanel}
             * @fires zoom
             */
            zoomBy: function zoomBy(step) {
                if (step && _.isFinite(step)) {
                    this.zoomTo(zoomLevel + parseFloat(step));
                }
                return this;
            },

            /**
             * Zoom-in using the configured level step
             * @returns {magnifierPanel}
             * @fires zoom
             */
            zoomIn: function zoomIn() {
                return this.zoomBy(zoomLevelStep);
            },

            /**
             * Zoom-out using the configured level step
             * @returns {magnifierPanel}
             * @fires zoom
             */
            zoomOut: function zoomOut() {
                return this.zoomBy(-zoomLevelStep);
            },

            /**
             * Places the magnifier sight at a particular position on the target content
             * @param {Number} x
             * @param {Number} y
             * @returns {magnifierPanel}
             */
            zoomAt: function zoomAt(x, y) {
                var position;
                if (controls) {
                    position = this.translate(x, y);
                    controls.$inner.css({
                        top: -position.top,
                        left: -position.left
                    });
                }
            },

            /**
             * Translates screen coordinates to zoom coordinates
             * @param {Number} x
             * @param {Number} y
             * @returns {Object}
             */
            translate: function translate(x, y) {
                return {
                    top: translateMagnifier(y, targetHeight, this.config.height),
                    left: translateMagnifier(x, targetWidth, this.config.width)
                };
            },

            /**
             * Updates the magnifier with the target content
             * @returns {magnifierPanel}
             * @fires update
             */
            update: function update() {
                if (controls && controls.$target) {
                    controls.$clone = controls.$target.clone().removeAttr('id');
                    controls.$clone.find('iframe').remove();
                    controls.$clone.find('[name],[id],[data-serial]').removeAttr('name id data-serial');
                    controls.$inner.empty().append(controls.$clone);

                    applySize();
                    applyZoomLevel();
                    updateZoom();
                    updateMaxSize();
                    applyScrolling();

                    /**
                     * @event magnifierPanel#update
                     */
                    this.trigger('update');
                }

                return this;
            }
        }, defaultConfig);

        /**
         * Will update the magnifier content with the actual content
         * @type {Function}
         */
        var updateMagnifier = _.debounce(_.bind(magnifierPanel.update, magnifierPanel), debounceDelay);

        /**
         * Will update the magnifier content with the scrolling position
         * @type {Function}
         */
        var scrollingListenerCallback = _.throttle(function (event) {

            var $target = $(event.target);
            var scrollingTop = event.target.scrollTop;
            var scrollLeft = event.target.scrollLeft;
            var scrollId, scrollData;

            //check if the element is already known as a scrollable element
            if (controls && controls.$clone && $target.data('magnifier-scroll')) {

                scrollId = $target.data('magnifier-scroll');
                scrollData = _.find(scrolling, {id: scrollId});
                scrollData.scrollTop = scrollingTop;
                scrollData.scrollLeft = scrollLeft;

                //if in clone, scroll it
                scrollInClone(scrollData);

            } else {
                //if the element is not yet identified as a scrollable element, tag it and register its id
                scrollId = _.uniqueId('scrolling_');
                $target.attr('data-magnifier-scroll', scrollId);
                scrolling.push({
                    id: scrollId,
                    scrollTop: scrollingTop,
                    scrollLeft: scrollLeft
                });

                //update all
                magnifierPanel.update();
            }

        }, scrollingDelay);

        /**
         * Scroll an element in the clone
         *
         * @param {Object} scrollData
         * @param {String} scrollData.id
         * @param {Number} [scrollData.scrollTop]
         * @param {Number} [scrollData.scrollLeft]
         */
        function scrollInClone(scrollData) {
            var $clonedTarget;
            if (controls && controls.$clone && scrollData && scrollData.id) {
                $clonedTarget = controls.$clone.find('[data-magnifier-scroll=' + scrollData.id + ']');
                if ($clonedTarget.length) {
                    if (_.isNumber(scrollData.scrollTop)) {
                        $clonedTarget[0].scrollTop = scrollData.scrollTop;
                    }
                    if (_.isNumber(scrollData.scrollLeft)) {
                        $clonedTarget[0].scrollLeft = scrollData.scrollLeft;
                    }
                }
            }
        }

        /**
         * Initializes the listener for scrolling event and transfer the scrolling
         */
        function setScrollingListener() {
            window.addEventListener('scroll', scrollingListenerCallback, true);
        }

        /**
         * Stops the listener for scrolling event
         */
        function removeScrollingListener() {
            window.removeEventListener('scroll', scrollingListenerCallback, true);
        }

        /**
         * Applies scrolling programmatically from the recorded list of elements to be scrolled
         */
        function applyScrolling() {
            _.forEach(scrolling, scrollInClone);
        }

        /**
         * Adjusts a provided zoom level to fit the constraints
         * @param {Number|String} level
         * @returns {Number}
         */
        function adjustZoomLevel(level) {
            return Math.max(zoomLevelMin, Math.min(parseFloat(level), zoomLevelMax));
        }

        /**
         * Applies the zoom level to the content
         */
        function applyZoomLevel() {
            if (controls) {
                controls.$inner.css({
                    transform: 'scale(' + zoomLevel + ')'
                });
            }
        }

        /**
         * Shows the zoom level using a CSS animation
         */
        function showZoomLevel() {
            var $newZoomLevel;
            if (controls) {
                $newZoomLevel = controls.$zoomLevel.clone(true).html(zoomLevel);
                controls.$zoomLevel.before($newZoomLevel).remove();
                controls.$zoomLevel = $newZoomLevel;
            }
        }

        /**
         * Updates the max size according to the window's size
         */
        function updateMaxSize() {
            var $window = $(window);
            magnifierPanel.config.maxWidth = $window.width() * maxRatio;
            magnifierPanel.config.maxHeight = $window.height() * maxRatio;
        }

        /**
         * Forwards the size of the target to the cloned content
         */
        function applySize() {
            if (controls && controls.$clone) {
                targetWidth = controls.$target.width();
                targetHeight = controls.$target.height();

                controls.$clone
                    .width(targetWidth)
                    .height(targetHeight);
            }
        }

        /**
         * Place the zoom sight at the right place inside the magnifier
         */
        function updateZoom() {
            var position;
            if (controls && controls.$target) {
                position = magnifierPanel.getPosition();

                position.x += dx + controls.$target.scrollLeft();
                position.y += dy + controls.$target.scrollTop();

                magnifierPanel.zoomAt(position.x, position.y);
            }
        }

        /**
         * Creates the observer that will react to DOM changes to update the magnifier
         */
        function createObserver() {
            observer = new window.MutationObserver(updateMagnifier);
        }

        /**
         * Starts to observe the DOM of the magnifier target
         */
        function startObserver() {
            if (controls && controls.$target) {
                observer.observe(controls.$target.get(0), {
                    childList: true,        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.
                    attributes: true,       // Set to true if mutations to target's attributes are to be observed.
                    characterData: true,    // Set to true if mutations to target's data are to be observed.
                    subtree: true           // Set to true if mutations to target and target's descendants are to be observed.
                });
            }
            setScrollingListener();
        }

        /**
         * Stops to observe the DOM of the magnifier target
         */
        function stopObserver() {
            observer.disconnect();
            removeScrollingListener();
        }

        /**
         * Translates a screen coordinate into the magnifier
         * @param {Number} coordinate
         * @param {Number} actualSize
         * @param {Number} magnifierSize
         * @returns {Number}
         */
        function translateMagnifier(coordinate, actualSize, magnifierSize) {
            var delta = 0;
            var ratio = zoomLevel;

            if (actualSize) {
                delta = ((actualSize * (zoomLevel - 1)) / 2);
                ratio = (actualSize * zoomLevel - magnifierSize) / (actualSize - magnifierSize);
            }

            return coordinate * ratio - delta;
        }

        /**
         * Gets the top element from a particular absolute point.
         * @param {Number} x - the page X-coordinate of the point
         * @param {Number} y - the page Y-coordinate of the point
         * @returns {HTMLElement}
         */
        function getElementFromPoint(x, y) {
            var el;

            if (controls) {
                controls.$overlay.addClass('hidden');
            }

            el = document.elementFromPoint(x, y);

            if (controls) {
                controls.$overlay.removeClass('hidden');
            }

            return el;
        }

        /**
         * Find the related node in the target. The both trees must have the same content.
         * @param {jQuery|HTMLElement} node - the node for which find a relation
         * @param {jQuery|HTMLElement} root - the root of the tree that contains the actual node
         * @param {jQuery|HTMLElement} target - the root of the tree that could contains the related node
         * @returns {jQuery}
         */
        function findSourceNode(node, root, target) {
            var $node = $(node);
            var $root = $(root);
            var $target = $(target);
            var indexes = [$node.index()];

            // compute map of node's parents indexes
            $node.parents().each(function () {
                var $this = $(this);
                if (!$this.is($root)) {
                    indexes.push($this.index());
                } else {
                    return false;
                }
            });

            // the last index is related to the root, so ignore it
            indexes.pop();

            // now try to find the same node using the path provided by the indexes map
            if (indexes.length) {
                $node = $target;
                _.forEachRight(indexes, function (index) {
                    $node = $node.children().eq(index);
                    if (!$node.length) {
                        return false;
                    }
                });
            } else {
                // nothing to search for...
                $node = $();
            }
            return $node;
        }

        initConfig.width = zoomSize;
        initConfig.height = zoomSize / screenRatio;
        initConfig.minWidth = baseSize * zoomLevelMin;
        initConfig.minHeight = baseSize * zoomLevelMin / screenRatio;

        magnifierPanel
            .setTemplate(magnifierPanelTpl)
            .on('render', function () {
                var self = this;
                var $component = this.getElement();

                this.setState('hidden', true);

                // compute the padding of the magnifier content
                dx = ($component.outerWidth() - $component.width()) / 2;
                dy = ($component.outerHeight() - $component.height()) / 2;

                controls = {
                    $target: $initTarget,
                    $inner: $('.inner', $component),
                    $zoomLevel: $('.level', $component),
                    $overlay: $('.overlay', $component)
                };
                $initTarget = null;

                // click on zoom-in or zoom-out controls
                $component.on('click touchstart', '.zoom', function (event) {
                    var $button = $(event.target).closest('.control');
                    var action = $button.data('control');

                    event.preventDefault();
                    if (action && self[action]) {
                        self[action]();
                    }
                });

                // click on close controls
                $component.on('click touchstart', '.closeMagnifier', function (event) {
                    event.preventDefault();
                    self.hide();
                    self.trigger('close');
                });

                // interact through the magnifier glass with the zoomed content
                $component.on('click touchstart', '.overlay', function (event) {
                    if (!self.is('noclick')) {
                        findSourceNode(
                            getElementFromPoint(event.pageX, event.pageY),
                            controls.$inner,
                            controls.$target
                        ).click().focus();
                    } else {
                        // was a 'dragend' click, just ignore
                        self.setState('noclick', false);
                    }
                });

                createObserver();
                updateMaxSize();
                applyZoomLevel();
            })
            .on('dragstart resizestart', function () {
                // prevent the 'dragend' click to be understood as an actual click
                this.setState('noclick', true);
            })
            .on('move resize', function () {
                updateZoom();
            })
            .on('show', function () {
                updateMagnifier();
                startObserver();
            })
            .on('hide', function () {
                stopObserver();
            })
            .on('resize', function () {
                updateMaxSize();
            })
            .on('destroy', function () {
                stopObserver();
                $initTarget = null;
                controls = null;
                observer = null;
            })
            .init(initConfig);

        return magnifierPanel;
    }

    return magnifierPanelFactory;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/runner/plugins/tools/magnifier/magnifier',[
    'jquery',
    'lodash',
    'i18n',
    'taoTests/runner/plugin',
    'ui/hider',
    'util/shortcut',
    'util/namespace',
    'taoQtiTest/runner/plugins/tools/magnifier/magnifierPanel'
], function ($, _, __, pluginFactory, hider, shortcut, namespaceHelper, magnifierPanelFactory) {
    'use strict';

    /**
     * The public name of the plugin
     * @type {String}
     */
    var pluginName = 'magnifier';

    /**
     * The prefix of actions triggered through the event loop
     * @type {String}
     */
    var actionPrefix = 'tool-' + pluginName + '-';

    /**
     * Some default options for the plugin
     * @type {Object}
     */
    var defaultOptions = {
        zoomMin: 2,    // Smallest magnification factor
        zoomMax: 8,    // Biggest magnification factor
        zoomStep: .5   // Increment between min an max
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name: pluginName,

        /**
         * Initializes the plugin (called during runner's init)
         */
        init: function init() {
            var self = this;

            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginConfig = _.defaults((testConfig.plugins || {})[pluginName] || {}, defaultOptions);
            var pluginShortcuts = (testConfig.shortcuts || {})[pluginName] || {};
            var magnifierPanel = null;

            /**
             * Creates the magnifier panel on demand
             * @returns {magnifierPanel}
             * @fires plugin-magnifier-create.magnifier
             */
            function getMagnifierPanel() {
                var $container;

                if (!magnifierPanel) {
                    $container = testRunner.getAreaBroker().getContainer();

                    magnifierPanel = magnifierPanelFactory({
                        levelMin: pluginConfig.zoomMin,
                        levelMax: pluginConfig.zoomMax,
                        levelStep: pluginConfig.zoomStep
                    })
                        .on('show', function () {
                            /**
                             * @event plugin-magnifier-show.magnifier
                             */
                            self.trigger('magnifier-show');
                        })
                        .on('hide', function () {
                            /**
                             * @event plugin-magnifier-hide.magnifier
                             */
                            self.trigger('magnifier-hide');
                        })
                        .on('zoom', function (level) {
                            /**
                             * @event plugin-magnifier-zoom.magnifier
                             * @param {Number} zoomLevel
                             */
                            self.trigger('magnifier-zoom', level);
                        })
                        .on('close', function () {
                            hideMagnifier();
                        })
                        .setTarget($container)
                        .render($container.parent());

                    /**
                     * @event plugin-magnifier-create.magnifier
                     */
                    self.trigger('magnifier-create');
                }
                return magnifierPanel;
            }

            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isEnabled() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};
                //to be activated with the special category x-tao-option-magnifier
                return !!options.magnifier;
            }

            /**
             * Shows/hides the plugin GUI according to context
             */
            function togglePlugin() {
                if (isEnabled()) {
                    self.show();
                } else {
                    self.hide();
                }
            }

            /**
             * Shows/hides the magnifier
             */
            function toggleMagnifier() {
                if (self.getState('enabled')) {
                    if (self.getState('active')) {
                        hideMagnifier();
                    } else {
                        showMagnifier();
                    }
                }
            }

            /**
             * Opens the magnifier panel
             * @fires plugin-magnifier-show.magnifier
             */
            function showMagnifier() {
                getMagnifierPanel();

                if (magnifierPanel.is('hidden')) {
                    magnifierPanel.show();
                }
                self.button.turnOn();
                testRunner.trigger('plugin-open.' + pluginName);

                self.setState('active', true);
            }

            /**
             * Closes the magnifier panel
             * @fires plugin-magnifier-hide.magnifier
             */
            function hideMagnifier() {
                self.setState('active', false);

                self.button.turnOff();
                testRunner.trigger('plugin-close.' + pluginName);

                if (magnifierPanel && !magnifierPanel.is('hidden')) {
                    magnifierPanel.hide();
                }
            }

            // build element
            this.button = this.getAreaBroker().getToolbox().createEntry({
                control: 'magnify',
                title: __('Displays a customisable magnifier'),
                text: __('Magnifying Glass'),
                icon: 'find'
            });

            // attach behavior
            this.button.on('click', function (event) {
                event.preventDefault();
                testRunner.trigger(actionPrefix + 'toggle');
            });


            // handle the plugin's shortcuts
            if (testConfig.allowShortcuts) {
                _.forEach(pluginShortcuts, function (command, key) {
                    shortcut.add(namespaceHelper.namespaceAll(command, pluginName, true), function () {
                        // just fire the action using the event loop
                        testRunner.trigger(actionPrefix + key);
                    }, {
                        avoidInput: true
                    });
                });
            }

            //start disabled
            togglePlugin();
            this.disable();

            //update plugin state based on changes
            testRunner
            // runner life cycle
                .on('loaditem', function () {
                    togglePlugin();
                    self.disable();
                })
                .on('renderitem', function () {
                    if (magnifierPanel) {
                        magnifierPanel
                            .update()
                            .zoomTo(pluginConfig.zoomMin);
                    }
                })
                .on('enabletools renderitem', function () {
                    self.enable();
                })
                .on('disabletools unloaditem', function () {
                    if (self.getState('active')) {
                        hideMagnifier();
                    }
                    self.disable();
                })
                .on('destroy', function () {
                    if (magnifierPanel) {
                        magnifierPanel.destroy();
                    }
                    magnifierPanel = null;
                })

                // commands that controls the magnifier
                .on(actionPrefix + 'toggle', function () {
                    if (isEnabled()) {
                        toggleMagnifier();
                    }
                })
                .on(actionPrefix + 'in', function () {
                    if (isEnabled() && self.getState('enabled') && self.getState('active')) {
                        getMagnifierPanel().zoomIn();
                    }
                })
                .on(actionPrefix + 'out', function () {
                    if (isEnabled() && self.getState('enabled') && self.getState('active')) {
                        getMagnifierPanel().zoomOut();
                    }
                })
                .on(actionPrefix + 'close', function () {
                    if (self.getState('active')) {
                        hideMagnifier();
                    }
                });
        },

        /**
         * Called during the runner's destroy phase
         */
        destroy: function destroy() {
            shortcut.remove('.' + pluginName);
        },

        /**
         * Enables the button
         */
        enable: function enable() {
            this.button.enable();
        },

        /**
         * Disables the button
         */
        disable: function disable() {
            this.button.disable();
        },

        /**
         * Shows the button
         */
        show: function show() {
            this.button.show();
        },

        /**
         * Hides the button
         */
        hide: function hide() {
            this.button.hide();
        }
    });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016  (original work) Open Assessment Technologies SA;
 *
 * @author dieter <dieter@taotesting.com>
 * @author Alexander Zagovorichev <zagovorichev@1pt.com>
 */

define('taoQtiTest/runner/plugins/tools/zoom',[
    'jquery',
    'i18n',
    'ui/hider',
    'ui/transformer',
    'util/shortcut',
    'util/namespace',
    'taoTests/runner/plugin'
], function ($, __, hider, transformer, shortcut, namespaceHelper, pluginFactory){
    'use strict';

    /**
     * The standard zoom level, in percentage
     * @type {Number}
     */
    var standard = 100;

    /**
     * Zoom-In/Zoom-Out steps
     * @type {Number}
     */
    var increment = 10;

    /**
     * The zoom boundaries, in percentage
     * @type {Object}
     */
    var threshold = {
        lower: 10,
        upper: 200
    };

    /**
     * Sets the zoom level
     * @param {jQuery} $target
     * @param {Number} level - Zoom percentage
     */
    var setZoomLevel = function($target, level) {
        transformer.setTransformOrigin($target, '0 0');
        transformer.scale($target, level / 100);
    };

    /**
     * Restores the standard zoom level
     * @param {jQuery} $target
     */
    var resetZoom = function($target) {
        transformer.reset($target);
    };

    /**
     * Forces a browser repaint
     * Solution from http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes?answertab=votes#tab-top
     * @param {jQuery} $target
     */
    var forceRepaint = function($target) {
        var sel = $target[0];
        if (sel) {
            sel.style.display = 'none';
            sel.offsetHeight; // no need to store this anywhere, the reference is enough
            sel.style.display = '';
        }
    };

    /**
     * Returns the configured plugin
     */
    return pluginFactory({

        name : 'zoom',

        /**
         * Initialize the plugin (called during runner's init)
         */
        init : function init(){
            var self = this;
            var testRunner = this.getTestRunner();
            var testData = testRunner.getTestData() || {};
            var testConfig = testData.config || {};
            var pluginShortcuts = (testConfig.shortcuts || {})[this.getName()] || {};



            /**
             * Checks if the plugin is currently available
             * @returns {Boolean}
             */
            function isConfigured() {
                var context = testRunner.getTestContext() || {},
                    options = context.options || {};
                //to be activated with the special category x-tao-option-zoom
                return !!options.zoom;
            }

            /**
             * Is zoom activated ? if not, then we hide the plugin
             */
            function togglePlugin() {
                if (isConfigured()) {//allow zoom
                    self.show();
                } else {
                    self.hide();
                }
            }

            function zoomAction(dir) {

                var inc = increment * dir;
                var el, sx, sy, before, after, margin;

                if (self.$zoomTarget) {
                    el = self.$zoomTarget[0];

                    before = el.getBoundingClientRect();

                    sx = self.$container.scrollLeft();
                    sy = self.$container.scrollTop();

                    self.zoom = Math.max(threshold.lower, Math.min(threshold.upper, self.zoom + inc));

                    if (self.zoom === standard) {
                        resetZoom(self.$zoomTarget);
                    } else {
                        setZoomLevel(self.$zoomTarget, self.zoom);
                    }

                    // force a browser repaint to fix a scrollbar issue with WebKit
                    forceRepaint(self.$zoomTarget);

                    after = el.getBoundingClientRect();

                    sx = Math.max(0, sx + (after.width - before.width) / 2);
                    sy = Math.max(0, sy + (after.height - before.height) / 2);

                    self.$container.scrollLeft(sx).scrollTop(sy);
                }
            }

            function zoomIn() {
                if (self.getState('enabled') !== false) {
                    zoomAction(1);
                }
            }

            function zoomOut() {
                if (self.getState('enabled') !== false) {
                    zoomAction(-1);
                }
            }

            //build element (detached)
            this.buttonZoomOut = this.getAreaBroker().getToolbox().createEntry({
                control : 'zoomOut',
                title : __('Zoom out'),
                icon : 'remove'
            });

            this.buttonZoomIn = this.getAreaBroker().getToolbox().createEntry({
                control : 'zoomIn',
                title : __('Zoom in'),
                icon : 'add'
            });

            //attach behavior
            this.buttonZoomIn.on('click', function (e){
                e.preventDefault();
                testRunner.trigger('tool-zoomin');
            });

            //attach behavior
            this.buttonZoomOut.on('click', function (e){
                e.preventDefault();
                testRunner.trigger('tool-zoomout');
            });

            if (testConfig.allowShortcuts) {
                if (pluginShortcuts.in) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.in, this.getName(), true), function () {
                        testRunner.trigger('tool-zoomin');
                    }, {
                        avoidInput: true
                    });
                }

                if (pluginShortcuts.out) {
                    shortcut.add(namespaceHelper.namespaceAll(pluginShortcuts.out, this.getName(), true), function () {
                        testRunner.trigger('tool-zoomout');
                    }, {
                        avoidInput: true
                    });
                }
            }

            //start disabled
            togglePlugin();
            this.disable();

            //update plugin state based on changes
            testRunner
                .on('loaditem', function (){
                    self.zoom = standard;

                    togglePlugin();
                    self.disable();
                })
                .on('renderitem', function (){
                    self.$container = $('#qti-content');
                    self.$zoomTarget = $('.qti-item');

                    self.enable();
                })
                .on('enabletools', function() {
                    self.enable();
                })
                .on('disabletools unloaditem', function (){
                    self.disable();
                })
                .on('tool-zoomin', zoomIn)
                .on('tool-zoomout', zoomOut);
        },
        /**
         * Called during the runner's destroy phase
         */
        destroy : function destroy(){
            shortcut.remove('.' + this.getName());
        },
        /**
         * Enable the button
         */
        enable : function enable(){
            this.buttonZoomIn.enable();
            this.buttonZoomOut.enable();
        },
        /**
         * Disable the button
         */
        disable : function disable(){
            this.buttonZoomIn.disable();
            this.buttonZoomOut.disable();
        },
        /**
         * Show the button
         */
        show : function show(){
            this.buttonZoomIn.show();
            this.buttonZoomOut.show();
        },
        /**
         * Hide the button
         */
        hide : function hide(){
            this.buttonZoomIn.hide();
            this.buttonZoomOut.hide();
        }
    });
});


(function(c){var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
('.test-runner-scope .content-wrapper p.key-navigation-group,.test-runner-scope .content-wrapper div.key-navigation-group{padding:5px !important}.test-runner-scope .content-wrapper .key-navigation-group:not(.qti-extendedTextInteraction):not(.qti-textEntryInteraction){border-width:1px !important;border-style:solid;border-color:transparent}.test-runner-scope .content-wrapper .key-navigation-group:not(.qti-extendedTextInteraction):not(.qti-textEntryInteraction).focusin{border-color:#0e5d91 !important;outline:none}.test-runner-scope .content-wrapper .key-navigation-group:not(.qti-extendedTextInteraction):not(.qti-textEntryInteraction).qti-interaction .qti-choice.key-navigation-highlight{background:#e7eff4 !important}.test-runner-scope .content-wrapper span.key-navigation-group{border:none !important}.test-runner-scope .content-wrapper span.key-navigation-group.focusin{outline:solid #0e5d91 1px !important;outline-offset:1px}.test-runner-scope .test-sidebar .key-navigation-group.focusin{background:#e7eff4}.test-runner-scope .test-sidebar .key-navigation-group .qti-navigator-filters .key-navigation-highlight .qti-navigator-tab{border-width:2px}.test-runner-scope .test-sidebar .key-navigation-group .qti-navigator-filters .key-navigation-highlight:focus{outline:none}.test-runner-scope .test-sidebar .key-navigation-group .qti-navigator-filters .key-navigation-highlight:focus .qti-navigator-tab{border-top-color:#222 !important;border-left-color:#222 !important;border-right-color:#222 !important}.test-runner-scope .test-sidebar .key-navigation-group li.qti-navigator-item.key-navigation-highlight{padding-left:8px;border-left:solid 2px #222}.test-runner-scope .test-sidebar .key-navigation-group li.qti-navigator-item.key-navigation-highlight .key-navigation-highlight:focus{outline:none}.test-runner-scope .bottom-action-bar.content-action-bar.key-navigation-group.focusin{-webkit-box-shadow:0 0 6px 2px #3e7da7;-moz-box-shadow:0 0 6px 2px #3e7da7;-ms-box-shadow:0 0 6px 2px #3e7da7;-o-box-shadow:0 0 6px 2px #3e7da7;box-shadow:0 0 6px 2px #3e7da7}.test-runner-scope .bottom-action-bar.content-action-bar.key-navigation-group .key-navigation-highlight:focus{margin-bottom:0;border-bottom-color:#e7eff4 !important;outline:none}.test-runner-scope .bottom-action-bar.content-action-bar.key-navigation-group .key-navigation-highlight:focus.active{border-bottom-color:transparent !important;background:#e7eff4 !important}.test-runner-scope .bottom-action-bar.content-action-bar.key-navigation-group .key-navigation-highlight:focus:not(.active):not(:active) .li-inner{color:#e7eff4}header .settings-menu .key-navigation-group{padding-right:5px}header .settings-menu .key-navigation-group.focusin{background-color:rgba(14,93,145,0.5);padding-bottom:10px}header .settings-menu .key-navigation-highlight:focus{height:54px;color:white !important;border-bottom:solid 2px white !important}\n\n/*# sourceMappingURL=key-navigation.css.map */.countdown{opacity:0;position:relative;display:inline-block;overflow:hidden;text-align:center;vertical-align:top;line-height:1.2;padding:0 20px;margin-top:-1px;height:100%}.countdown.rendered{opacity:1;-webkit-transition:opacity, 300ms, linear, 0s;-moz-transition:opacity, 300ms, linear, 0s;-ms-transition:opacity, 300ms, linear, 0s;-o-transition:opacity, 300ms, linear, 0s;transition:opacity, 300ms, linear, 0s}.countdown .label{max-width:130px;display:block;font-size:12px;font-size:1.2rem}\n\n/*# sourceMappingURL=countdown.css.map */.timer-box{opacity:0;padding-top:0;white-space:nowrap;-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-wrap:nowrap;-ms-flex-wrap:nowrap;flex-wrap:nowrap;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end}.timer-box.rendered{opacity:1;-webkit-transition:opacity, 300ms, linear, 0s;-moz-transition:opacity, 300ms, linear, 0s;-ms-transition:opacity, 300ms, linear, 0s;-o-transition:opacity, 300ms, linear, 0s;transition:opacity, 300ms, linear, 0s}.timer-box .timer-toggler{text-decoration:none;color:#fff;line-height:1.3;opacity:.68;padding:8px 20px;position:relative;top:-1px;left:20px;z-index:2;-webkit-transition:opacity, .5s, ease-out, 0s;-moz-transition:opacity, .5s, ease-out, 0s;-ms-transition:opacity, .5s, ease-out, 0s;-o-transition:opacity, .5s, ease-out, 0s;transition:opacity, .5s, ease-out, 0s}.timer-box .timer-toggler:hover,.timer-box .timer-toggler:active,.timer-box .timer-toggler:focus{outline:unset}.timer-box .timer-toggler:hover{opacity:.93;-webkit-transition:opacity, .5s, ease-out, 0s;-moz-transition:opacity, .5s, ease-out, 0s;-ms-transition:opacity, .5s, ease-out, 0s;-o-transition:opacity, .5s, ease-out, 0s;transition:opacity, .5s, ease-out, 0s}.timer-box.zen .timer-toggler{opacity:.93;-webkit-transition:opacity, .5s, ease-out, 0s;-moz-transition:opacity, .5s, ease-out, 0s;-ms-transition:opacity, .5s, ease-out, 0s;-o-transition:opacity, .5s, ease-out, 0s;transition:opacity, .5s, ease-out, 0s}.timer-box.zen .countdown .time{opacity:0;-webkit-transition:opacity, 1s, ease-out, 0s;-moz-transition:opacity, 1s, ease-out, 0s;-ms-transition:opacity, 1s, ease-out, 0s;-o-transition:opacity, 1s, ease-out, 0s;transition:opacity, 1s, ease-out, 0s}.timer-box .countdown::before{content:\' \';background:rgba(255,255,255,0.3);width:1px;height:20px;position:absolute;left:0;top:5px}.timer-box .countdown:first-child::before{content:none}.timer-box .countdown[data-scope=test][data-type=min]{-ms-flex-order:5;-webkit-order:5;order:5}.timer-box .countdown[data-scope=test]{-ms-flex-order:10;-webkit-order:10;order:10}.timer-box .countdown[data-scope=testPart][data-type=min]{-ms-flex-order:15;-webkit-order:15;order:15}.timer-box .countdown[data-scope=testPart]{-ms-flex-order:20;-webkit-order:20;order:20}.timer-box .countdown[data-scope=section][data-type=min]{-ms-flex-order:25;-webkit-order:25;order:25}.timer-box .countdown[data-scope=section]{-ms-flex-order:30;-webkit-order:30;order:30}.timer-box .countdown[data-scope=item][data-type=min]{-ms-flex-order:35;-webkit-order:35;order:35}.timer-box .countdown[data-scope=item]{-ms-flex-order:40;-webkit-order:40;order:40}\n\n/*# sourceMappingURL=timerbox.css.map */');

//# sourceMappingURL=testPlugins.min.js.map